<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.568965517241">
	<global_window_position top="10" left="10" height="1044" width="1301"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="michael.20070926121838"><vh>@chapters</vh></v>
<v t="mr7771.20060608154252" a="ETV"><vh>code</vh>
<v t="michael.20061230173452" a="E"><vh>Todos</vh>
<v t="michael.20061230174132"><vh>Refactorings</vh></v>
<v t="michael.20061230173452.1"><vh>Bugs</vh></v>
</v>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="mr7771.20060608164004" a="E"><vh>Base</vh>
<v t="michael.20060717214039" tnodeList="michael.20060717214039,mr7771.20060609151433"><vh>@file __init__.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551" tnodeList="michael.20060619145551,mr7771.20060609151433,michael.20060619145551.1,michael.20060619145930,michael.20060619145551.4,michael.20060619145551.5,michael.20060619145551.6,michael.20060619145551.7,michael.20060619145551.8,michael.20060619145551.9,michael.20060619145930.1,michael.20060619145551.10,michael.20060619145551.11,michael.20060619145551.12,michael.20060619145551.13,michael.20060619145551.14,michael.20061119143304,michael.20060619145551.15,michael.20060619145551.16,michael.20060619145551.17,michael.20060619145551.18,michael.20060619145551.19,michael.20060619145551.20,michael.20060619145551.21,michael.20060619145551.22,michael.20060619145551.23,michael.20060619145551.24,michael.20060619145551.25,michael.20060619150413,michael.20060619145551.30,michael.20060619145551.31,michael.20060623161820,michael.20060623161820.1,michael.20060623161820.2,michael.20060619145551.32,michael.20060623160939,michael.20060623160939.1,michael.20060623160939.3,michael.20060623160939.4,michael.20060623160939.5,michael.20060623160939.6,michael.20060623160939.7,michael.20060623160939.8,michael.20060619150413.1,michael.20060619145551.26,michael.20060619145551.27,michael.20060619145551.28,michael.20060619145551.29,michael.20061119143714,michael.20060619145551.35,michael.20060619145551.36,michael.20060619145551.37,michael.20061109181208,michael.20060619145551.38,michael.20060619145551.39,michael.20070115204524,michael.20060619145551.40,michael.20060619145551.41,michael.20060619145551.42,michael.20061123163317,michael.20060619145551.43,michael.20070115161719,michael.20060619145551.44,michael.20060619145551.45,michael.20060619145551.46,michael.20060619145551.47,michael.20060619145551.48,michael.20060619145551.49,michael.20060619145551.50,michael.20060619145551.51,michael.20060619145551.52,michael.20060619145551.53,michael.20060619145551.54,michael.20060619145551.55,michael.20060619145551.56,michael.20060619145551.57,michael.20060619145551.58,michael.20060619145551.59,michael.20060619145551.60,michael.20060619145551.61,michael.20060619145551.62,michael.20060619145551.63,michael.20060619145551.64,michael.20060619145551.65,michael.20060619145551.66,michael.20060619145551.67,michael.20060619145551.68,michael.20060619145551.69,michael.20060619145551.70,michael.20060619145551.71,michael.20060619145551.72,michael.20060619145551.73,michael.20060619145551.74,michael.20060619145551.75,michael.20060619145551.76,michael.20060619145551.77,michael.20060619145551.78,michael.20060619145551.79,michael.20060619145551.80,michael.20060619145551.81,michael.20060619145551.82,michael.20060619145551.83,michael.20060619145551.84,michael.20060619150519,michael.20060619145551.2,michael.20060619145551.85,michael.20060619145551.86,michael.20060619145551.87,michael.20060619145551.88,michael.20060619145551.107,michael.20060915184406,michael.20060915190443,michael.20060619145551.106,michael.20060915184406.1,michael.20060619145551.108,michael.20060619145551.109,michael.20061118232041,michael.20060619145551.110,michael.20060619145551.111,michael.20060930013205,michael.20060619145930.2,michael.20070112120451,michael.20060619145551.33,michael.20060619145551.34,michael.20060619145551.89,michael.20060619145551.90,michael.20060619145551.91,michael.20060619145551.92,michael.20060619145551.93,michael.20060619145551.94,michael.20060814190211,michael.20060814190211.1,michael.20060814190211.2,michael.20060814190211.3,michael.20060814190211.4,michael.20060619145551.95,michael.20060619145551.96,michael.20060619145551.97,michael.20060619145551.98,michael.20060619145551.99,michael.20060619145551.100,michael.20060619145551.101,michael.20060619145551.102,michael.20060619145551.103,michael.20060619145551.104,michael.20060619145551.105,michael.20060619145930.3,michael.20060619145551.115,michael.20061027121652,michael.20060619145551.117,michael.20061027121652,michael.20060619145551.119,michael.20061027121652,michael.20060619145551.121,michael.20061027121652,michael.20060619150542,michael.20060619145551.123,michael.20060619145551.124,michael.20060619145551.125,michael.20060619145551.126,michael.20060619145551.127,michael.20060619145551.128,michael.20060619145551.129,michael.20060720224306,michael.20060619145551.130,michael.20060619145551.131,michael.20060619145551.132,michael.20060619145551.133,michael.20060619145551.134,michael.20060619145551.194,michael.20060619145551.135,michael.20061027224620,michael.20060623154957,michael.20060619145551.136,michael.20060619145551.137,michael.20060619145551.138,michael.20060619145551.139,michael.20060619145551.140,michael.20060619145551.141,michael.20060619145551.144,michael.20060619145551.148,michael.20060619145551.150,michael.20060619145551.142,michael.20060619145551.143,michael.20060623154957.1,michael.20060619145551.146,michael.20060619145551.151,michael.20060619145551.152,michael.20060619145551.187,michael.20060619145551.188,michael.20060619145551.147,michael.20060623154957.2,michael.20060619145551.153,michael.20060619145551.154,michael.20060619145551.155,michael.20060713212925,michael.20060619145551.156,michael.20061027120904,michael.20061027120904.2,michael.20061027120904.3,michael.20060623154040,michael.20060619145551.159,michael.20061109182534,michael.20061109182534.1,michael.20061109182534.2,michael.20061121143813,michael.20060619145551.160,michael.20061121143813.1,michael.20061121143813.2,michael.20061121143813.3,michael.20061121143813.4,michael.20061121143813.5,michael.20061121143813.6,michael.20061121143813.7,michael.20061121143813.8,michael.20061121143813.9,michael.20060619145551.161,michael.20060619145551.162,michael.20060619145551.163,michael.20060619145551.164,michael.20060619145551.165,michael.20060619145551.166,michael.20060619145551.167,michael.20060619145551.168,michael.20060619145551.169,michael.20060619145551.170,michael.20060619145551.171,michael.20060619145551.172,michael.20060619145551.173,michael.20060619145551.191,michael.20061109182534.3,michael.20060724150058,michael.20060724135631,michael.20060619145551.200,michael.20060724164954,michael.20060619145551.204,michael.20060619145551.205,michael.20060619145551.206,michael.20060619145551.208,michael.20060619145551.209,michael.20060619145551.210,michael.20060619145551.211,michael.20060619145551.212,michael.20060619145551.213,michael.20060619145551.214,michael.20060619145551.215,michael.20060619145551.216,michael.20060619145551.217,michael.20060619145551.207,michael.20060623154957.3,michael.20060619145551.145,michael.20060619145551.174,michael.20060619145551.175,michael.20060623154040.1,michael.20061230152555,michael.20061201004146,michael.20060619145551.177,michael.20060713212925,michael.20060623154040.2,michael.20060619145551.178,michael.20060713212925,michael.20060623154040.2,michael.20060619145551.179,michael.20060619145551.180,michael.20060619145551.181,michael.20060619145551.182,michael.20060619145551.183,michael.20060619145551.184,michael.20060619153005,michael.20060619153005.1,michael.20060619153005.2,michael.20060619145551.185,michael.20060619145551.186,michael.20060623154957.4,michael.20060619145551.157,michael.20060619145551.158,michael.20060619145551.189,michael.20060619145551.149,michael.20060623154957.5,michael.20060619145551.190,michael.20060619145551.192,michael.20060619145551.193,michael.20060619150055,michael.20060619145551.195,michael.20060619145551.196,michael.20060619145551.197,michael.20060619145551.198,michael.20060621123928,michael.20060619145551.201,michael.20060619145551.202,michael.20060619145551.218,michael.20060619145551.219,michael.20060619145551.220,michael.20060619145551.221,michael.20060619145551.222,michael.20060619145551.223,michael.20060619145551.224,michael.20060619145551.225,michael.20060619145551.226,michael.20060619145551.227,michael.20060619145551.228,michael.20060619145551.229,michael.20061129124501,michael.20060619145551.230,michael.20060619145551.231,michael.20060619145551.232,michael.20060619145551.233,michael.20060619151509,michael.20060619151509.1,michael.20060619151509.2,michael.20060619151509.3,michael.20060619151846"><vh>@file task.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060619145551.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060619145930"><vh>Exceptions</vh>
<v t="michael.20060619145551.4"><vh>class AttributeError</vh>
<v t="michael.20060619145551.5"><vh>&lt;&lt; class AttributeError declarations &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.6"><vh>class RecursionError</vh>
<v t="michael.20060619145551.7"><vh>&lt;&lt; class RecursionError declarations &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.8"><vh>class _IncompleteError</vh>
<v t="michael.20060619145551.9"><vh>__init__</vh></v>
</v>
</v>
<v t="michael.20060619145930.1"><vh>Proxies for self referencing</vh>
<v t="michael.20060619145551.10"><vh>class _MeProxy</vh>
<v t="michael.20060619145551.11"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.12"><vh>__init__</vh></v>
<v t="michael.20060619145551.13"><vh>__getattr__</vh></v>
<v t="michael.20060619145551.14"><vh>__setattr__</vh></v>
<v t="michael.20061119143304"><vh>__iter__</vh></v>
<v t="michael.20060619145551.15"><vh>add_attrib</vh></v>
</v>
<v t="michael.20060619145551.16"><vh>class _MeProxyRecalc</vh>
<v t="michael.20060619145551.17"><vh>__setattr__</vh></v>
</v>
<v t="michael.20060619145551.18"><vh>class _MeProxyError</vh>
<v t="michael.20060619145551.19"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.20"><vh>__init__</vh></v>
<v t="michael.20060619145551.21"><vh>__setattr__</vh></v>
</v>
<v t="michael.20060619145551.22"><vh>class _MeProxyWarn</vh>
<v t="michael.20060619145551.23"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.24"><vh>__init__</vh></v>
<v t="michael.20060619145551.25"><vh>__setattr__</vh></v>
</v>
</v>
<v t="michael.20060619150413"><vh>Task instrumentation</vh>
<v t="michael.20060619145551.30"><vh>_int_to_arg</vh></v>
<v t="michael.20060619145551.31"><vh>_correct_labels</vh>
<v t="michael.20060623161820"><vh>&lt;&lt; localize dot variables &gt;&gt;</vh></v>
<v t="michael.20060623161820.1"><vh>&lt;&lt; loop initialization &gt;&gt;</vh></v>
<v t="michael.20060623161820.2"><vh>&lt;&lt; add label if necessary &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.32" a="M"><vh>_instrument</vh>
<v t="michael.20060623160939"><vh>&lt;&lt; localize dot variables &gt;&gt;</vh></v>
<v t="michael.20060623160939.1"><vh>&lt;&lt; define local functions list_to_dict and is_local &gt;&gt;</vh></v>
<v t="michael.20060623160939.3" a="M"><vh>&lt;&lt; loop initialization &gt;&gt;</vh></v>
<v t="michael.20060623160939.4"><vh>&lt;&lt; calculate new tab point &gt;&gt;</vh></v>
<v t="michael.20060623160939.5"><vh>&lt;&lt; calculate argument &gt;&gt;</vh></v>
<v t="michael.20060623160939.6"><vh>&lt;&lt; change "store fast" to "store attribute" &gt;&gt;</vh></v>
<v t="michael.20060623160939.7"><vh>&lt;&lt; change "load fast" to "load attribute" &gt;&gt;</vh></v>
<v t="michael.20060623160939.8"><vh>&lt;&lt; create new code and function objects and return &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060619150413.1"><vh>Wrappers</vh>
<v t="michael.20060619145551.26"><vh>class _Path</vh>
<v t="michael.20060619145551.27"><vh>__init__</vh></v>
<v t="michael.20060619145551.28"><vh>__getattr__</vh></v>
<v t="michael.20060619145551.29"><vh>__str__</vh></v>
<v t="michael.20061119143714"><vh>__iter__</vh></v>
</v>
<v t="michael.20060619145551.35"><vh>_val</vh></v>
<v t="michael.20060619145551.36"><vh>_ref</vh></v>
<v t="michael.20060619145551.37"><vh>_sref</vh></v>
<v t="michael.20061109181208"><vh>_refsum</vh></v>
<v t="michael.20060619145551.38"><vh>class _ValueWrapper</vh>
<v t="michael.20060619145551.39"><vh>__init__</vh></v>
<v t="michael.20070115204524" a="M"><vh>unicode</vh></v>
<v t="michael.20060619145551.40"><vh>_vw</vh></v>
<v t="michael.20060619145551.41"><vh>_cmp</vh></v>
<v t="michael.20060619145551.42"><vh>__getattr__</vh></v>
<v t="michael.20061123163317"><vh>__getitem__</vh></v>
<v t="michael.20060619145551.43"><vh>__str__</vh></v>
<v t="michael.20070115161719"><vh>__unicode__</vh></v>
<v t="michael.20060619145551.44"><vh>__repr__</vh></v>
<v t="michael.20060619145551.45"><vh>__nonzero__</vh></v>
<v t="michael.20060619145551.46"><vh>__lt__</vh></v>
<v t="michael.20060619145551.47"><vh>__le__</vh></v>
<v t="michael.20060619145551.48"><vh>__eq__</vh></v>
<v t="michael.20060619145551.49"><vh>__ne__</vh></v>
<v t="michael.20060619145551.50"><vh>__gt__</vh></v>
<v t="michael.20060619145551.51"><vh>__ge__</vh></v>
<v t="michael.20060619145551.52"><vh>__add__</vh></v>
<v t="michael.20060619145551.53"><vh>__sub__</vh></v>
<v t="michael.20060619145551.54"><vh>__mul__</vh></v>
<v t="michael.20060619145551.55"><vh>__floordiv__</vh></v>
<v t="michael.20060619145551.56"><vh>__mod__</vh></v>
<v t="michael.20060619145551.57"><vh>__divmod__</vh></v>
<v t="michael.20060619145551.58"><vh>__pow__</vh></v>
<v t="michael.20060619145551.59"><vh>__lshift__</vh></v>
<v t="michael.20060619145551.60"><vh>__rshift__</vh></v>
<v t="michael.20060619145551.61"><vh>__and__</vh></v>
<v t="michael.20060619145551.62"><vh>__xor__</vh></v>
<v t="michael.20060619145551.63"><vh>__or__</vh></v>
<v t="michael.20060619145551.64"><vh>__div__</vh></v>
<v t="michael.20060619145551.65"><vh>__radd__</vh></v>
<v t="michael.20060619145551.66"><vh>__rsub__</vh></v>
<v t="michael.20060619145551.67"><vh>__rmul__</vh></v>
<v t="michael.20060619145551.68"><vh>__rdiv__</vh></v>
<v t="michael.20060619145551.69"><vh>__rtruediv__</vh></v>
<v t="michael.20060619145551.70"><vh>__rfloordiv__</vh></v>
<v t="michael.20060619145551.71"><vh>__rmod__</vh></v>
<v t="michael.20060619145551.72"><vh>__rdivmod__</vh></v>
<v t="michael.20060619145551.73"><vh>__rpow__</vh></v>
<v t="michael.20060619145551.74"><vh>__rlshift__</vh></v>
<v t="michael.20060619145551.75"><vh>__rrshift__</vh></v>
<v t="michael.20060619145551.76"><vh>__rand__</vh></v>
<v t="michael.20060619145551.77"><vh>__rxor__</vh></v>
<v t="michael.20060619145551.78"><vh>__ror__</vh></v>
<v t="michael.20060619145551.79"><vh>__int__</vh></v>
<v t="michael.20060619145551.80"><vh>__long__</vh></v>
<v t="michael.20060619145551.81"><vh>__float__</vh></v>
<v t="michael.20060619145551.82"><vh>__len__</vh></v>
<v t="michael.20060619145551.83"><vh>__iter__</vh></v>
<v t="michael.20060619145551.84"><vh>__hash__</vh></v>
</v>
</v>
<v t="michael.20060619150519"><vh>Utilities</vh>
<v t="michael.20060619145551.2"><vh>class _NEVER_USED_</vh></v>
<v t="michael.20060619145551.85"><vh>class _StringConverter</vh>
<v t="michael.20060619145551.86"><vh>__init__</vh></v>
<v t="michael.20060619145551.87"><vh>__getitem__</vh></v>
<v t="michael.20060619145551.88"><vh>__getattr__</vh></v>
</v>
<v t="michael.20060619145551.107"><vh>Multi</vh></v>
<v t="michael.20060915184406" a="M"><vh>create_relative_path</vh></v>
<v t="michael.20060915190443" a="M"><vh>create_absolute_path</vh></v>
<v t="michael.20060619145551.106"><vh>_split_path</vh></v>
<v t="michael.20060915184406.1"><vh>_to_datetime</vh></v>
<v t="michael.20060619145551.108"><vh>_get_tasks_of_sources</vh></v>
<v t="michael.20060619145551.109"><vh>_build_balancing_list</vh>
<v t="michael.20061118232041" a="M"><vh>&lt;&lt; define inspect_depends_on &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.110"><vh>_as_string</vh></v>
<v t="michael.20060619145551.111"><vh>_step_tasks</vh></v>
</v>
<v t="michael.20060930013205"><vh>Cache</vh></v>
<v t="michael.20060619145930.2"><vh>Resource Allocators</vh>
<v t="michael.20070112120451"><vh>VariableLoad</vh></v>
<v t="michael.20060619145551.33"><vh>_calc_load</vh></v>
<v t="michael.20060619145551.34"><vh>_calc_maxload</vh></v>
<v t="michael.20060619145551.89"><vh>class AllocationAlgorithm</vh>
<v t="michael.20060619145551.90"><vh>test_allocation</vh></v>
<v t="michael.20060619145551.91"><vh>allocate</vh></v>
</v>
<v t="michael.20060619145551.92"><vh>class StrictAllocator</vh>
<v t="michael.20060619145551.93"><vh>_distribute_len_loads</vh></v>
<v t="michael.20060619145551.94"><vh>test_allocation</vh>
<v t="michael.20060814190211"><vh>&lt;&lt; correct length &gt;&gt;</vh></v>
<v t="michael.20060814190211.1"><vh>&lt;&lt; correct duration &gt;&gt;</vh></v>
<v t="michael.20060814190211.2"><vh>&lt;&lt; check end &gt;&gt;</vh></v>
<v t="michael.20060814190211.3"><vh>&lt;&lt; correct effort and (re)calculate length &gt;&gt;</vh></v>
<v t="michael.20060814190211.4"><vh>&lt;&lt; set adjust_date and delta &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.95"><vh>allocate</vh></v>
<v t="michael.20060619145551.96"><vh>balance</vh></v>
</v>
<v t="michael.20060619145551.97"><vh>class SmartAllocator</vh>
<v t="michael.20060619145551.98" a="M"><vh>balance</vh></v>
</v>
<v t="michael.20060619145551.99"><vh>class SloppyAllocator</vh>
<v t="michael.20060619145551.100"><vh>test_allocation</vh></v>
<v t="michael.20060619145551.101"><vh>test_allocation_length</vh></v>
<v t="michael.20060619145551.102"><vh>test_allocation_effort</vh></v>
<v t="michael.20060619145551.103"><vh>allocate</vh></v>
<v t="michael.20060619145551.104"><vh>allocate_length</vh></v>
<v t="michael.20060619145551.105"><vh>allocate_effort</vh></v>
</v>
</v>
<v t="michael.20060619145930.3"><vh>Load Calculators</vh>
<v t="michael.20060619145551.115"><vh>YearlyMax</vh>
<v t="michael.20061027121652"><vh>&lt;&lt; calculate calendar and time_diff &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.117"><vh>WeeklyMax</vh>
<v t="michael.20061027121652"><vh>&lt;&lt; calculate calendar and time_diff &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.119"><vh>MonthlyMax</vh>
<v t="michael.20061027121652"><vh>&lt;&lt; calculate calendar and time_diff &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.121"><vh>DailyMax</vh>
<v t="michael.20061027121652"><vh>&lt;&lt; calculate calendar and time_diff &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060619150542"><vh>Task</vh>
<v t="michael.20060619145551.123"><vh>class _TaskProperty</vh>
<v t="michael.20060619145551.124"><vh>__init__</vh></v>
<v t="michael.20060619145551.125"><vh>__get__</vh></v>
</v>
<v t="michael.20060619145551.126"><vh>class _RoundingTaskProperty</vh>
<v t="michael.20060619145551.127"><vh>__init__</vh></v>
<v t="michael.20060619145551.128"><vh>__get__</vh></v>
</v>
<v t="michael.20060619145551.129"><vh>class Task</vh>
<v t="michael.20060720224306" a="M"><vh>&lt;&lt; description &gt;&gt;</vh></v>
<v t="michael.20060619145551.130"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.131"><vh>__init__</vh></v>
<v t="michael.20060619145551.132"><vh>__iter__</vh></v>
<v t="michael.20060619145551.133"><vh>__repr__</vh></v>
<v t="michael.20060619145551.134"><vh>__cmp__</vh></v>
<v t="michael.20060619145551.194"><vh>__getattr__</vh></v>
<v t="michael.20060619145551.135"><vh>_idendity_</vh></v>
<v t="michael.20061027224620" a="M"><vh>_set_hook</vh></v>
<v t="michael.20060623154957"><vh>Public methods</vh>
<v t="michael.20060619145551.136"><vh>to_string</vh></v>
<v t="michael.20060619145551.137"><vh>indent_name</vh></v>
<v t="michael.20060619145551.138"><vh>costs</vh></v>
<v t="michael.20060619145551.139"><vh>sum</vh></v>
<v t="michael.20060619145551.140"><vh>min</vh></v>
<v t="michael.20060619145551.141"><vh>max</vh></v>
<v t="michael.20060619145551.144"><vh>all_resources</vh></v>
<v t="michael.20060619145551.148"><vh>get_task</vh></v>
<v t="michael.20060619145551.150"><vh>snapshot</vh></v>
<v t="michael.20060619145551.142"><vh>is_inherited</vh></v>
<v t="michael.20060619145551.143"><vh>formatter</vh></v>
</v>
<v t="michael.20060623154957.1"><vh>Resource allocation Methods</vh>
<v t="michael.20060619145551.146"><vh>_all_resources_as_dict</vh></v>
<v t="michael.20060619145551.151"><vh>_test_allocation</vh></v>
<v t="michael.20060619145551.152"><vh>_allocate</vh></v>
<v t="michael.20060619145551.187"><vh>_convert_performed</vh></v>
<v t="michael.20060619145551.188"><vh>_allocate_performed</vh></v>
<v t="michael.20060619145551.147"><vh>_iter_booked_resources</vh></v>
</v>
<v t="michael.20060623154957.2"><vh>Compile Methods</vh>
<v t="michael.20060619145551.153"><vh>_generate</vh></v>
<v t="michael.20060619145551.154"><vh>_recalc_properties</vh></v>
<v t="michael.20060619145551.155"><vh>_compile</vh>
<v t="michael.20060713212925"><vh>&lt;&lt; raise child recursion error &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.156"><vh>__compile_function</vh>
<v t="michael.20061027120904" a="M"><vh>&lt;&lt; set function global values &gt;&gt;</vh></v>
<v t="michael.20061027120904.2"><vh>&lt;&lt; set me in global functions &gt;&gt;</vh></v>
<v t="michael.20061027120904.3" a="M"><vh>&lt;&lt; eval function &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060623154040"><vh>Setting methods</vh>
<v t="michael.20060619145551.159" a="M"><vh>_set_attrib</vh>
<v t="michael.20061109182534"><vh>&lt;&lt; add child task &gt;&gt;</vh></v>
<v t="michael.20061109182534.1"><vh>&lt;&lt; set standard attribute &gt;&gt;</vh></v>
<v t="michael.20061109182534.2"><vh>&lt;&lt; set userdefined attribute &gt;&gt;</vh></v>
</v>
<v t="michael.20061121143813"><vh>read only attributes</vh>
<v t="michael.20060619145551.160"><vh>_set_name</vh></v>
<v t="michael.20061121143813.1"><vh>_set_done</vh></v>
<v t="michael.20061121143813.2"><vh>_set_performed_work_time</vh></v>
<v t="michael.20061121143813.3"><vh>_set_booked_resource</vh></v>
<v t="michael.20061121143813.4"><vh>_set_performed_effort</vh></v>
<v t="michael.20061121143813.5"><vh>_set_children</vh></v>
<v t="michael.20061121143813.6"><vh>_set_depth</vh></v>
<v t="michael.20061121143813.7"><vh>_set_index</vh></v>
<v t="michael.20061121143813.8"><vh>_set_scenario</vh></v>
<v t="michael.20061121143813.9"><vh>_set_buffer</vh></v>
</v>
<v t="michael.20060619145551.161"><vh>_set_start</vh></v>
<v t="michael.20060619145551.162"><vh>_set_end</vh></v>
<v t="michael.20060619145551.163"><vh>_set_max_load</vh></v>
<v t="michael.20060619145551.164"><vh>_set_load</vh></v>
<v t="michael.20060619145551.165"><vh>_set_length</vh></v>
<v t="michael.20060619145551.166"><vh>_set_effort</vh></v>
<v t="michael.20060619145551.167"><vh>_set_duration</vh></v>
<v t="michael.20060619145551.168"><vh>_set_complete</vh></v>
<v t="michael.20060619145551.169"><vh>_set_done</vh></v>
<v t="michael.20060619145551.170"><vh>_set_todo</vh></v>
<v t="michael.20060619145551.171"><vh>_set_milestone</vh></v>
<v t="michael.20060619145551.172"><vh>_set_resource</vh></v>
<v t="michael.20060619145551.173"><vh>_set_copy_src</vh></v>
<v t="michael.20060619145551.191" a="M"><vh>__set_sources</vh>
<v t="michael.20061109182534.3" a="M"><vh>&lt;&lt; find references &gt;&gt;</vh></v>
</v>
<v t="michael.20060724150058"><vh>Calendar Setters</vh>
<v t="michael.20060724135631"><vh>_set_calendar</vh></v>
<v t="michael.20060619145551.200"><vh>__renew_dates</vh></v>
<v t="michael.20060724164954"><vh>__make_calendar</vh></v>
<v t="michael.20060619145551.204"><vh>_set_vacation</vh></v>
<v t="michael.20060619145551.205"><vh>_set_extra_work</vh></v>
<v t="michael.20060619145551.206" a="M"><vh>_set_working_days</vh></v>
<v t="michael.20060619145551.208"><vh>_set_minimum_time_unit</vh></v>
<v t="michael.20060619145551.209"><vh>_get_minimum_time_unit</vh></v>
<v t="michael.20060619145551.210"><vh>_set_working_days_per_week</vh></v>
<v t="michael.20060619145551.211"><vh>_get_working_days_per_week</vh></v>
<v t="michael.20060619145551.212"><vh>_set_working_days_per_month</vh></v>
<v t="michael.20060619145551.213"><vh>_get_working_days_per_month</vh></v>
<v t="michael.20060619145551.214"><vh>_set_working_days_per_year</vh></v>
<v t="michael.20060619145551.215"><vh>_get_working_days_per_year</vh></v>
<v t="michael.20060619145551.216"><vh>_set_working_hours_per_day</vh></v>
<v t="michael.20060619145551.217"><vh>_get_working_hours_per_day</vh></v>
<v t="michael.20060619145551.207"><vh>_set_now</vh></v>
</v>
</v>
<v t="michael.20060623154957.3"><vh>Freezer Methods</vh>
<v t="michael.20060619145551.145"><vh>_unfreeze</vh></v>
<v t="michael.20060619145551.174"><vh>_wrap_attrib</vh></v>
<v t="michael.20060619145551.175"><vh>_find_frozen</vh></v>
</v>
<v t="michael.20060623154040.1"><vh>Calculation Methods</vh>
<v t="michael.20061230152555"><vh>__calc_performed_effort</vh></v>
<v t="michael.20061201004146"><vh>__calc_estimated_effort</vh></v>
<v t="michael.20060619145551.177"><vh>__calc_start</vh>
<v t="michael.20060713212925"><vh>&lt;&lt; raise child recursion error &gt;&gt;</vh></v>
<v t="michael.20060623154040.2"><vh>&lt;&lt; raise recursion error &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.178"><vh>__calc_end</vh>
<v t="michael.20060713212925"><vh>&lt;&lt; raise child recursion error &gt;&gt;</vh></v>
<v t="michael.20060623154040.2"><vh>&lt;&lt; raise recursion error &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.179"><vh>__calc_load</vh></v>
<v t="michael.20060619145551.180"><vh>__calc_length</vh></v>
<v t="michael.20060619145551.181"><vh>__calc_duration</vh></v>
<v t="michael.20060619145551.182"><vh>__calc_effort</vh></v>
<v t="michael.20060619145551.183"><vh>__calc_done</vh></v>
<v t="michael.20060619145551.184"><vh>__calc_buffer</vh>
<v t="michael.20060619153005"><vh>&lt;&lt; find all tasks, that depend on my end &gt;&gt;</vh></v>
<v t="michael.20060619153005.1"><vh>&lt;&lt; define unfreeze_parents &gt;&gt;</vh></v>
<v t="michael.20060619153005.2"><vh>&lt;&lt; calculate buffer to descendant 'd' &gt;&gt;</vh></v>
</v>
<v t="michael.20060619145551.185"><vh>__calc_complete</vh></v>
<v t="michael.20060619145551.186"><vh>__calc_todo</vh></v>
</v>
<v t="michael.20060623154957.4"><vh>Check Methods</vh>
<v t="michael.20060619145551.157"><vh>__check_task</vh></v>
<v t="michael.20060619145551.158"><vh>__check_milestone</vh></v>
<v t="michael.20060619145551.189"><vh>_check_completion</vh></v>
<v t="michael.20060619145551.149"><vh>check</vh></v>
</v>
<v t="michael.20060623154957.5"><vh>Error Methods</vh>
<v t="michael.20060619145551.190"><vh>__assert</vh></v>
<v t="michael.20060619145551.192"><vh>_warn</vh></v>
<v t="michael.20060619145551.193"><vh>_raise</vh></v>
</v>
</v>
</v>
<v t="michael.20060619150055"><vh>Projects</vh>
<v t="michael.20060619145551.195"><vh>class _ProjectBase</vh>
<v t="michael.20060619145551.196"><vh>&lt;&lt; class _ProjectBase declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.197"><vh>__init__</vh></v>
<v t="michael.20060619145551.198"><vh>_idendity_</vh></v>
<v t="michael.20060621123928" a="M"><vh>_restore_globals</vh></v>
<v t="michael.20060619145551.201"><vh>free</vh></v>
<v t="michael.20060619145551.202"><vh>_get_balancing_list</vh></v>
<v t="michael.20060619145551.218"><vh>snapshot</vh></v>
</v>
<v t="michael.20060619145551.219"><vh>class Project</vh>
<v t="michael.20060619145551.220"><vh>&lt;&lt; class Project declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.221"><vh>__init__</vh></v>
</v>
<v t="michael.20060619145551.222"><vh>class _AllocationPoject</vh>
<v t="michael.20060619145551.223"><vh>unfreeze_parents</vh></v>
</v>
<v t="michael.20060619145551.224"><vh>class BalancedProject</vh>
<v t="michael.20060619145551.225"><vh>&lt;&lt; class BalancedProject declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.226"><vh>__init__</vh></v>
<v t="michael.20060619145551.227"><vh>allocate_snapshot</vh></v>
<v t="michael.20060619145551.228"><vh>allocate</vh></v>
<v t="michael.20060619145551.229" a="M"><vh>_distribute_performed</vh>
<v t="michael.20061129124501"><vh>&lt;&lt; extract task in activity path &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060619145551.230"><vh>class AdjustedProject</vh>
<v t="michael.20060619145551.231"><vh>&lt;&lt; class AdjustedProject declarations &gt;&gt;</vh></v>
<v t="michael.20060619145551.232"><vh>__init__</vh></v>
<v t="michael.20060619145551.233" a="M"><vh>allocate</vh>
<v t="michael.20060619151509"><vh>&lt;&lt; free the resources, we have to rebook &gt;&gt;</vh></v>
<v t="michael.20060619151509.1"><vh>&lt;&lt; copy the attribs of complete tasks &gt;&gt;</vh></v>
<v t="michael.20060619151509.2"><vh>&lt;&lt; allocate performed data &gt;&gt;</vh></v>
<v t="michael.20060619151509.3" a="M"><vh>&lt;&lt; allocate tasks, that have not begun yet &gt;&gt;</vh></v>
<v t="michael.20060619151846"><vh>&lt;&lt; allocate tasks, that are allready at work &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="michael.20060619191608" tnodeList="michael.20060619191608,mr7771.20060609151433,michael.20060619191608.1,michael.20060619191608.2,michael.20060619191608.3,michael.20060619191608.4,michael.20060619191608.5,michael.20060619191608.6,michael.20060619191608.7,michael.20060619191608.8,michael.20060619191608.9,michael.20060619191608.10,michael.20060619191608.11,michael.20070117163707,michael.20060619191608.12,michael.20060619191608.13,michael.20060619191608.14,michael.20060619191608.15,michael.20060619191608.16,michael.20060619191608.17,michael.20060619191608.18,michael.20060619191608.19,michael.20060619191608.20,michael.20060619191608.21,michael.20060619191608.22,michael.20060619191608.23,michael.20060619191608.24,michael.20060619191608.25,michael.20060619191608.26,michael.20060619191608.27,michael.20060619191608.28,michael.20060619191608.32,michael.20060619191608.33,michael.20060619191608.34,michael.20060619191608.35,michael.20060619191608.29,michael.20070115204909,michael.20060619191608.30,michael.20060619191608.31,michael.20060619191608.36,michael.20060619191608.37,michael.20060619191608.38,michael.20060619191608.39,michael.20060619191608.40,michael.20060619191608.41,michael.20060619191608.42,michael.20060619191608.43,michael.20060619191608.44,michael.20060619191608.45"><vh>@file report.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060619191608.1"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619191608.2"><vh>Private</vh>
<v t="michael.20060619191608.3"><vh>_val</vh></v>
<v t="michael.20060619191608.4"><vh>_has_ref</vh></v>
<v t="michael.20060619191608.5"><vh>class _ReportValueWrapper</vh>
<v t="michael.20060619191608.6"><vh>__init__</vh></v>
<v t="michael.20060619191608.7"><vh>_vw</vh></v>
<v t="michael.20060619191608.8"><vh>_cmp</vh></v>
<v t="michael.20060619191608.9"><vh>__call__</vh></v>
<v t="michael.20060619191608.10"><vh>__repr__</vh></v>
<v t="michael.20060619191608.11"><vh>type</vh></v>
<v t="michael.20070117163707" a="M"><vh>unicode</vh></v>
</v>
<v t="michael.20060619191608.12"><vh>class _TaskWrapper</vh>
<v t="michael.20060619191608.13"><vh>__init__</vh></v>
<v t="michael.20060619191608.14"><vh>__getattr__</vh></v>
<v t="michael.20060619191608.15"><vh>__iter__</vh></v>
<v t="michael.20060619191608.16"><vh>__str__</vh></v>
</v>
<v t="michael.20060619191608.17"><vh>class _ToStringWrapper</vh>
<v t="michael.20060619191608.18"><vh>__init__</vh></v>
<v t="michael.20060619191608.19"><vh>__getattr__</vh></v>
<v t="michael.20060619191608.20"><vh>__getitem__</vh></v>
</v>
<v t="michael.20060619191608.21"><vh>class _ReportIter</vh>
<v t="michael.20060619191608.22"><vh>__init__</vh></v>
<v t="michael.20060619191608.23"><vh>__iter__</vh></v>
<v t="michael.20060619191608.24"><vh>next</vh></v>
</v>
</v>
<v t="michael.20060619191608.25"><vh>Public</vh>
<v t="michael.20060619191608.26" a="M"><vh>class Cell</vh>
<v t="michael.20060619191608.27"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619191608.28"><vh>__init__</vh></v>
<v t="michael.20060619191608.32"><vh>__str__</vh></v>
<v t="michael.20060619191608.33"><vh>__unicode__</vh></v>
<v t="michael.20060619191608.34"><vh>__nonzero__</vh></v>
<v t="michael.20060619191608.35"><vh>__cmp__</vh></v>
<v t="michael.20060619191608.29"><vh>get_label</vh></v>
<v t="michael.20070115204909"><vh>unicode</vh></v>
<v t="michael.20060619191608.30"><vh>get_type</vh></v>
<v t="michael.20060619191608.31"><vh>get_ref</vh></v>
<v t="michael.20060619191608.36"><vh>native</vh></v>
</v>
<v t="michael.20060619191608.37"><vh>class Report</vh>
<v t="michael.20060619191608.38"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619191608.39"><vh>__init__</vh></v>
<v t="michael.20060619191608.40"><vh>_raise</vh></v>
<v t="michael.20060619191608.41"><vh>make_report</vh></v>
<v t="michael.20060619191608.42"><vh>prepare_data</vh></v>
<v t="michael.20060619191608.43"><vh>instrument_data</vh></v>
<v t="michael.20060619191608.44"><vh>modify_row</vh></v>
<v t="michael.20060619191608.45"><vh>__iter__</vh></v>
</v>
</v>
</v>
<v t="michael.20060622082846" tnodeList="michael.20060622082846,mr7771.20060609151433,michael.20060622082846.1,michael.20060622082846.2,michael.20060622082846.3,michael.20060822214147"><vh>@file observer.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060622082846.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060622082846.2"><vh>class Observer</vh>
<v t="michael.20060622082846.3"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060822214147"><vh>register_editors</vh></v>
</v>
</v>
<v t="michael.20060626133545" tnodeList="michael.20060626133545,mr7771.20060609151433,michael.20060626133545.1,michael.20060626133545.2,michael.20060626133545.3,michael.20060626133545.4,michael.20060626133545.5,michael.20060626133545.6,michael.20060626133545.7,michael.20080106130453,michael.20060718000534,michael.20060718001417,michael.20060718001417.1,michael.20060718001417.2,michael.20060718005323,michael.20060718005402,michael.20060626133545.8,michael.20060626133545.9,michael.20060626133545.10,michael.20060626133545.11,michael.20060626133545.12,michael.20060626133545.13,michael.20060626133545.14,michael.20060626133545.15,michael.20060626133545.16,michael.20060626133545.17,michael.20060626133839,michael.20060626133545.18,michael.20060626133545.19,michael.20060626133545.20,michael.20060626133545.21,michael.20060626133545.22,michael.20060626133545.23,michael.20060626133545.24,michael.20060626133545.25,michael.20060626133545.26,michael.20060626133545.27,michael.20060626133545.28,michael.20060626133545.29,michael.20060626133545.30,michael.20060626133545.31,michael.20060626133545.32,michael.20060724142145,michael.20060724153604,michael.20060626133545.33,michael.20060626133545.34,michael.20060626133545.35,michael.20060626133545.37,michael.20060626133545.38,michael.20060626133545.39,michael.20060626133545.40,michael.20060626133545.41,michael.20060626133545.36,michael.20060626133545.42,michael.20060626133545.43"><vh>@file pcalendar.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060626133545.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060626133545.2"><vh>to_time_range</vh></v>
<v t="michael.20060626133545.3"><vh>to_datetime</vh></v>
<v t="michael.20060626133545.4"><vh>_to_days</vh></v>
<v t="michael.20060626133545.5"><vh>_add_to_time_spans</vh></v>
<v t="michael.20060626133545.6"><vh>to_timedelta</vh></v>
<v t="michael.20060626133545.7"><vh>timedelta_to_str</vh></v>
<v t="michael.20080106130453" a="M"><vh>strftime</vh></v>
<v t="michael.20060718000534" a="E"><vh>union</vh>
<v t="michael.20060718001417"><vh>&lt;&lt; check arguments &gt;&gt;</vh></v>
<v t="michael.20060718001417.1"><vh>&lt;&lt; intersect vacations &gt;&gt;</vh></v>
<v t="michael.20060718001417.2"><vh>&lt;&lt; unify extra worktime &gt;&gt;</vh></v>
<v t="michael.20060718005323"><vh>&lt;&lt; unify working times &gt;&gt;</vh></v>
<v t="michael.20060718005402"><vh>&lt;&lt; create result calendar &gt;&gt;</vh></v>
</v>
<v t="michael.20060626133545.8" a="E"><vh>class _CalendarItem</vh>
<v t="michael.20060626133545.9"><vh>&lt;&lt; class _CalendarItem declarations &gt;&gt;</vh></v>
<v t="michael.20060626133545.10"><vh>__new__</vh></v>
<v t="michael.20060626133545.11"><vh>round</vh></v>
</v>
<v t="michael.20060626133545.12"><vh>class _Minutes</vh>
<v t="michael.20060626133545.13"><vh>&lt;&lt; class _Minutes declarations &gt;&gt;</vh></v>
<v t="michael.20060626133545.14"><vh>__new__</vh></v>
<v t="michael.20060626133545.15"><vh>__cmp__</vh></v>
<v t="michael.20060626133545.16"><vh>__add__</vh></v>
<v t="michael.20060626133545.17"><vh>__sub__</vh></v>
<v t="michael.20060626133839"><vh>to_timedelta</vh></v>
<v t="michael.20060626133545.18"><vh>strftime</vh></v>
</v>
<v t="michael.20060626133545.19"><vh>class _WorkingDateBase</vh>
<v t="michael.20060626133545.20"><vh>&lt;&lt; class _WorkingDateBase declarations &gt;&gt;</vh></v>
<v t="michael.20060626133545.21"><vh>__new__</vh></v>
<v t="michael.20060626133545.22"><vh>__repr__</vh></v>
<v t="michael.20060626133545.23"><vh>to_datetime</vh></v>
<v t="michael.20060626133545.24"><vh>to_starttime</vh></v>
<v t="michael.20060626133545.25"><vh>to_endtime</vh></v>
<v t="michael.20060626133545.26"><vh>__cmp__</vh></v>
<v t="michael.20060626133545.27"><vh>__add__</vh></v>
<v t="michael.20060626133545.28"><vh>__sub__</vh></v>
<v t="michael.20060626133545.29"><vh>strftime</vh></v>
</v>
<v t="michael.20060626133545.30"><vh>class Calendar</vh>
<v t="michael.20060626133545.31"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060626133545.32"><vh>__init__</vh></v>
<v t="michael.20060724142145"><vh>__or__</vh></v>
<v t="michael.20060724153604"><vh>clone</vh></v>
<v t="michael.20060626133545.33"><vh>set_working_days</vh></v>
<v t="michael.20060626133545.34"><vh>set_vacation</vh></v>
<v t="michael.20060626133545.35"><vh>set_extra_work</vh></v>
<v t="michael.20060626133545.37"><vh>from_datetime</vh></v>
<v t="michael.20060626133545.38"><vh>split_time</vh></v>
<v t="michael.20060626133545.39"><vh>to_starttime</vh></v>
<v t="michael.20060626133545.40"><vh>to_endtime</vh></v>
<v t="michael.20060626133545.41"><vh>get_working_times</vh></v>
<v t="michael.20060626133545.36"><vh>_build_mapping</vh></v>
<v t="michael.20060626133545.42"><vh>_recalc_working_time</vh></v>
<v t="michael.20060626133545.43"><vh>_make_classes</vh></v>
</v>
</v>
<v t="michael.20061026133329" tnodeList="michael.20061026133329,mr7771.20060609151433,michael.20061026133329.1,michael.20061026133329.2,michael.20061026133329.3,michael.20061026133329.4,michael.20061026133329.5,michael.20061026133329.6,michael.20061026133329.7,michael.20061026133329.8,michael.20061026133329.9,michael.20061026133329.10,michael.20061026133329.11,michael.20061026133329.12,michael.20061026133329.13,michael.20061026133329.14,michael.20061026133329.15,michael.20061026133329.16,michael.20061026133329.17,michael.20061026133329.18,michael.20061026133329.19,michael.20061026133329.20,michael.20061026133329.21,michael.20061026133329.22,michael.20061026133329.23,michael.20070710231245,michael.20061026133329.24,michael.20061026133329.25,michael.20061026133329.26,michael.20061026133329.27,michael.20061026133329.28,michael.20061026133329.29,michael.20061026133329.30,michael.20061026133329.31,michael.20061026133329.32,michael.20061026133329.33,michael.20061026133329.34,michael.20061026133329.35,michael.20061026133329.36,michael.20061026133329.37,michael.20061026133329.38,michael.20061026133329.39,michael.20061026133329.40,michael.20061026133329.41,michael.20061026133329.42,michael.20061026133329.43,michael.20061026133329.44,michael.20061026133329.45,michael.20061026133329.46,michael.20061026133329.47,michael.20061026133329.48,michael.20061026133329.49,michael.20061026133329.50,michael.20061026133329.51,michael.20061026133329.52,michael.20061026133329.53,michael.20061026133329.54,michael.20061026133329.55,michael.20061026133329.56,michael.20061026133329.57,michael.20061026133329.58,michael.20061026133329.59,michael.20061026133329.60,michael.20061026133329.61,michael.20061026133329.62,michael.20061026133329.63,michael.20061026133329.64,michael.20061026133329.65,michael.20061026133329.66,michael.20061026133329.67,michael.20061026133329.68,michael.20061026133329.69,michael.20061026133329.70,michael.20061026133329.71,michael.20061026133329.72,michael.20061026133329.73,michael.20061026133329.74,michael.20061026133329.75,michael.20061026133329.76"><vh>@file resource.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20061026133329.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20061026133329.2"><vh>_isattrib</vh></v>
<v t="michael.20061026133329.3"><vh>class ResourceCalendar</vh>
<v t="michael.20061026133329.4"><vh>__init__</vh></v>
<v t="michael.20061026133329.5"><vh>__str__</vh></v>
<v t="michael.20061026133329.6"><vh>__repr__</vh></v>
<v t="michael.20061026133329.7"><vh>add_load</vh></v>
<v t="michael.20061026133329.8"><vh>end_of_booking_interval</vh></v>
<v t="michael.20061026133329.9" a="M"><vh>find_free_time</vh></v>
<v t="michael.20061026133329.10"><vh>get_bookings</vh></v>
<v t="michael.20061026133329.11"><vh>get_load</vh></v>
</v>
<v t="michael.20061026133329.12"><vh>class _ResourceBase</vh></v>
<v t="michael.20061026133329.13"><vh>class _MetaResource</vh>
<v t="michael.20061026133329.14"><vh>__init__</vh></v>
<v t="michael.20061026133329.15"><vh>__or__</vh></v>
<v t="michael.20061026133329.16"><vh>__and__</vh></v>
<v t="michael.20061026133329.17"><vh>__cmp__</vh></v>
<v t="michael.20061026133329.18"><vh>__repr__</vh></v>
<v t="michael.20061026133329.19"><vh>__str__</vh></v>
<v t="michael.20061026133329.20"><vh>__set_vacation</vh></v>
<v t="michael.20061026133329.21"><vh>__add_resource</vh></v>
<v t="michael.20061026133329.22"><vh>get_members</vh></v>
<v t="michael.20061026133329.23"><vh>add_vacation</vh></v>
<v t="michael.20070710231245"><vh>calendar</vh></v>
</v>
<v t="michael.20061026133329.24"><vh>make_team</vh></v>
<v t="michael.20061026133329.25"><vh>class Booking</vh>
<v t="michael.20061026133329.26"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20061026133329.27"><vh>__init__</vh></v>
<v t="michael.20061026133329.28"><vh>__cmp__</vh></v>
<v t="michael.20061026133329.29"><vh>path</vh></v>
<v t="michael.20061026133329.30"><vh>_idendity_</vh></v>
<v t="michael.20061026133329.31"><vh>__getattr__</vh></v>
</v>
<v t="michael.20061026133329.32"><vh>class ResourceList</vh>
<v t="michael.20061026133329.33"><vh>__init__</vh></v>
</v>
<v t="michael.20061026133329.34"><vh>class Resource</vh>
<v t="michael.20061026133329.35"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20061026133329.36"><vh>__init__</vh></v>
<v t="michael.20061026133329.37"><vh>_idendity_</vh></v>
<v t="michael.20061026133329.38"><vh>__repr__</vh></v>
<v t="michael.20061026133329.39"><vh>__str__</vh></v>
<v t="michael.20061026133329.40"><vh>__call__</vh></v>
<v t="michael.20061026133329.41"><vh>__hash__</vh></v>
<v t="michael.20061026133329.42"><vh>__cmp__</vh></v>
<v t="michael.20061026133329.43"><vh>__or__</vh></v>
<v t="michael.20061026133329.44"><vh>__and__</vh></v>
<v t="michael.20061026133329.45"><vh>_permutation_count</vh></v>
<v t="michael.20061026133329.46"><vh>_get_resources</vh></v>
<v t="michael.20061026133329.47"><vh>all_members</vh></v>
<v t="michael.20061026133329.48"><vh>unbook_tasks_of_project</vh></v>
<v t="michael.20061026133329.49"><vh>unbook_task</vh></v>
<v t="michael.20061026133329.50"><vh>correct_bookings</vh></v>
<v t="michael.20061026133329.51"><vh>book_task</vh></v>
<v t="michael.20061026133329.52"><vh>length_of</vh></v>
<v t="michael.20061026133329.53"><vh>done_of</vh></v>
<v t="michael.20061026133329.54"><vh>todo_of</vh></v>
<v t="michael.20061026133329.55"><vh>get_bookings</vh></v>
<v t="michael.20061026133329.56"><vh>get_bookings_at</vh></v>
<v t="michael.20061026133329.57"><vh>find_free_time</vh></v>
<v t="michael.20061026133329.58"><vh>get_load</vh></v>
<v t="michael.20061026133329.59"><vh>end_of_booking_interval</vh></v>
<v t="michael.20061026133329.60"><vh>snapshot</vh></v>
</v>
<v t="michael.20061026133329.61"><vh>class _ResourceGroup</vh>
<v t="michael.20061026133329.62"><vh>__init__</vh></v>
<v t="michael.20061026133329.63"><vh>all_members</vh></v>
<v t="michael.20061026133329.64"><vh>_permutation_count</vh></v>
<v t="michael.20061026133329.65"><vh>_refactor</vh></v>
<v t="michael.20061026133329.66"><vh>__append</vh></v>
<v t="michael.20061026133329.67"><vh>__str__</vh></v>
</v>
<v t="michael.20061026133329.68"><vh>class _OrResourceGroup</vh>
<v t="michael.20061026133329.69"><vh>_get_resources</vh></v>
<v t="michael.20061026133329.70"><vh>_permutation_count</vh></v>
</v>
<v t="michael.20061026133329.71"><vh>class _AndResourceGroup</vh>
<v t="michael.20061026133329.72"><vh>__init__</vh></v>
<v t="michael.20061026133329.73"><vh>_refactor</vh></v>
<v t="michael.20061026133329.74"><vh>_permutation_count</vh></v>
<v t="michael.20061026133329.75"><vh>_get_resources</vh></v>
<v t="michael.20061026133329.76"><vh>_has_duplicates</vh></v>
</v>
</v>
</v>
<v t="mr7771.20060608164004.452"><vh>Library</vh>
<v t="michael.20060621125711" tnodeList="michael.20060621125711,mr7771.20060609151433"><vh>@file lib/__init__.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
</v>
<v t="michael.20060619193106" a="M" tnodeList="michael.20060619193106,mr7771.20060609151433,michael.20060619193106.1,michael.20060619193106.2,michael.20060828215008,michael.20060619193106.4,michael.20060619193106.5,michael.20060619193106.6,michael.20060619193106.7,michael.20060619193106.8,michael.20060619193106.9,michael.20060619193106.10,michael.20060901185516,michael.20060619193106.11,michael.20060619193106.12,michael.20060619193106.13,michael.20060619193106.14,michael.20060619200744,michael.20060619193106.15,michael.20060619193106.16,michael.20060619193106.17,michael.20060619193106.18,michael.20060619194944,michael.20060619194944.1,michael.20060619200005,michael.20060619200005.1,michael.20060619200005.2,michael.20060619193106.21,michael.20060619193106.22,michael.20060619193106.23,michael.20060619193106.24"><vh>@file lib/report.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060619193106.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="michael.20060619193106.2"><vh>class Standard</vh>
<v t="michael.20060828215008"><vh>register_editors</vh></v>
<v t="michael.20060619193106.4"><vh>make_report</vh></v>
</v>
<v t="michael.20060619193106.5"><vh>class Titles</vh>
<v t="michael.20060619193106.6"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619193106.7"><vh>modify_row</vh></v>
</v>
<v t="michael.20060619193106.8"><vh>class Critical</vh>
<v t="michael.20060619193106.9"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619193106.10"><vh>__init__</vh></v>
<v t="michael.20060901185516"><vh>register_editors</vh></v>
<v t="michael.20060619193106.11"><vh>modify_row</vh></v>
</v>
<v t="michael.20060619193106.12"><vh>class Calendar</vh>
<v t="michael.20060619193106.13"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619193106.14"><vh>instrument_data</vh>
<v t="michael.20060619200744"><vh>&lt;&lt; define insert_task &gt;&gt;</vh></v>
</v>
<v t="michael.20060619193106.15"><vh>get_dates</vh></v>
<v t="michael.20060619193106.16"><vh>make_cell</vh></v>
<v t="michael.20060619193106.17"><vh>modify_cell</vh></v>
<v t="michael.20060619193106.18" a="M"><vh>make_report</vh>
<v t="michael.20060619194944"><vh>&lt;&lt; define add_row &gt;&gt;</vh></v>
<v t="michael.20060619194944.1" a="M"><vh>&lt;&lt; define add_date &gt;&gt;</vh></v>
<v t="michael.20060619200005"><vh>&lt;&lt; create day header cells &gt;&gt;</vh></v>
<v t="michael.20060619200005.1"><vh>&lt;&lt; create day data cells &gt;&gt;</vh></v>
<v t="michael.20060619200005.2"><vh>&lt;&lt; adjust borders &gt;&gt;</vh></v>
</v>
<v t="michael.20060619193106.21" a="M"><vh>get_start_text</vh></v>
<v t="michael.20060619193106.22" a="M"><vh>get_end_text</vh></v>
<v t="michael.20060619193106.23"><vh>_create_columns</vh></v>
<v t="michael.20060619193106.24"><vh>_create_headers</vh></v>
</v>
</v>
<v t="michael.20060619225419" tnodeList="michael.20060619225419,mr7771.20060609151433,michael.20060619225419.1,michael.20060619225419.2,michael.20060619225419.3,michael.20060619225419.4,michael.20060804153528,michael.20060619225419.5,michael.20060619225419.6,michael.20060619225419.8,michael.20060619225419.9,michael.20060619225419.11,michael.20060619225419.12,michael.20060804154418,michael.20060619225419.7,michael.20060619225419.10,michael.20060619225419.13,michael.20060619225419.14,michael.20060619225419.15,michael.20060619225419.16,michael.20060804154418.1,michael.20060619225419.17,michael.20060619225419.18,michael.20060619225419.19,michael.20060619225419.20,michael.20060619225419.21,michael.20060619230125,michael.20060804154418.2,michael.20060804154609,michael.20060619225419.22,michael.20060619225419.23,michael.20060804163807,michael.20060619225419.24,michael.20060619225419.25,michael.20060619225419.26,michael.20060619225419.27,michael.20060804154017,michael.20060619225419.28"><vh>@file lib/gantt.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060619225419.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060619225419.2"><vh>&lt;&lt; Declarations &gt;&gt;</vh></v>
<v t="michael.20060619225419.3"><vh>class Gantt</vh>
<v t="michael.20060619225419.4"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619230125"><vh>&lt;&lt; set __all__ attribute &gt;&gt;</vh></v>
<v t="michael.20060804153528" a="M"><vh>register_editors</vh></v>
<v t="michael.20060619225419.5"><vh>create_all_widgets</vh></v>
<v t="michael.20060619225419.6"><vh>create_objects</vh></v>
<v t="michael.20060619225419.8"><vh>get_property_group</vh></v>
<v t="michael.20060619225419.9"><vh>calc_title</vh></v>
<v t="michael.20060619225419.11"><vh>create_widget</vh></v>
<v t="michael.20060619225419.12"><vh>modify_widget</vh></v>
<v t="michael.20060804154418"><vh>Shape Methods</vh>
<v t="michael.20060619225419.7"><vh>get_shape_name</vh></v>
<v t="michael.20060619225419.10"><vh>make_shape</vh></v>
<v t="michael.20060619225419.13"><vh>make_combined_shape</vh></v>
<v t="michael.20060619225419.14"><vh>make_symbol_shape</vh></v>
<v t="michael.20060619225419.15"><vh>make_bar_shape</vh></v>
<v t="michael.20060619225419.16"><vh>make_brace_shape</vh></v>
</v>
<v t="michael.20060804154418.1"><vh>Connector Methods</vh>
<v t="michael.20060619225419.17"><vh>find_path</vh></v>
<v t="michael.20060619225419.18"><vh>create_connectors</vh></v>
<v t="michael.20060619225419.19"><vh>modify_connector</vh></v>
</v>
<v t="michael.20060619225419.20"><vh>get_tip</vh></v>
<v t="michael.20060619225419.21"><vh>get_task_tip</vh></v>
</v>
<v t="michael.20060804154418.2"><vh>class Standard</vh>
<v t="michael.20060804154609"><vh>register_editors</vh></v>
</v>
<v t="michael.20060619225419.22"><vh>class Critical</vh>
<v t="michael.20060619225419.23"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060804163807"><vh>register_editors</vh></v>
<v t="michael.20060619225419.24"><vh>__init__</vh></v>
<v t="michael.20060619225419.25"><vh>modify_widget</vh></v>
</v>
<v t="michael.20060619225419.26"><vh>class Compare</vh>
<v t="michael.20060619225419.27"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060804154017"><vh>register_editors</vh></v>
<v t="michael.20060619225419.28"><vh>create_objects</vh></v>
</v>
</v>
<v t="michael.20061002003849" tnodeList="michael.20061002003849,mr7771.20060609151433,michael.20061002003849.1,michael.20061002003849.2,michael.20061002003849.3,michael.20061002004356,michael.20061002003849.4,michael.20061002003849.5,michael.20061002003849.6,michael.20061002003849.7,michael.20061002003849.8,michael.20061002003849.9,michael.20061002003849.10,michael.20061002003849.11,michael.20061002003849.12,michael.20061002003849.13,michael.20061002003849.14"><vh>@file lib/resource.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20061002003849.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20061002003849.2"><vh>class Standard</vh>
<v t="michael.20061002003849.3"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20061002004356" a="M"><vh>register_editors</vh></v>
<v t="michael.20061002003849.4"><vh>__init__</vh></v>
<v t="michael.20061002003849.5"><vh>create_all_widgets</vh></v>
<v t="michael.20061002003849.6"><vh>create_row</vh></v>
<v t="michael.20061002003849.7"><vh>modify_row</vh></v>
<v t="michael.20061002003849.8"><vh>add_load_line</vh></v>
<v t="michael.20061002003849.9"><vh>load_offset</vh></v>
<v t="michael.20061002003849.10"><vh>create_bar</vh></v>
<v t="michael.20061002003849.11"><vh>modify_bar</vh></v>
<v t="michael.20061002003849.12"><vh>get_color</vh></v>
<v t="michael.20061002003849.13"><vh>create_bars</vh></v>
<v t="michael.20061002003849.14"><vh>get_tip</vh></v>
</v>
</v>
</v>
<v t="mr7771.20060608164004.453"><vh>Charting</vh>
<v t="michael.20070716145002" tnodeList="michael.20070716145002,mr7771.20060609151433"><vh>@file charting/__init__.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
</v>
<v t="michael.20060619222451" tnodeList="michael.20060619222451,mr7771.20060609151433,michael.20060619222451.1,michael.20060619223120,michael.20060619222451.8,michael.20060619222451.9,michael.20060619222451.10,michael.20060804121345,michael.20060619222451.11,michael.20060619222451.12,michael.20060619222451.13,michael.20060619222451.14,michael.20060619222451.15,michael.20060619222451.16,michael.20060619222451.17,michael.20060619222451.18,michael.20060619222451.19,michael.20060804132135,michael.20060619222451.20,michael.20060619222451.21,michael.20060619222451.22,michael.20060619222451.23,michael.20060619222451.24,michael.20060619222451.25,michael.20060619222451.26,michael.20060619222451.27,michael.20060619222451.28,michael.20060619222451.29,michael.20060619222451.30,michael.20060619222451.31,michael.20060619222451.32,michael.20060619222451.33,michael.20060619222451.34,michael.20060619222451.35,michael.20060619222451.36,michael.20060619222451.37,michael.20060619222451.38,michael.20060619222451.39,michael.20060619222451.40,michael.20060619222451.41,michael.20060619222451.42,michael.20060619222451.43,michael.20060804133122,michael.20060619222451.44,michael.20060619222451.45,michael.20060619222451.46,michael.20060619222451.47,michael.20060619222451.48,michael.20060619222451.49,michael.20060619222451.50,michael.20060619222451.51,michael.20060619222451.52,michael.20060619222451.53,michael.20060619222451.54,michael.20060619222451.55,michael.20060619222451.56,michael.20060804152844,michael.20060619222451.57,michael.20060619222451.58,michael.20060619222451.59,michael.20060619222451.60,michael.20060619222451.61,michael.20060619222451.62,michael.20060619222451.63,michael.20060619222451.64,michael.20060619222451.65,michael.20060619222451.66,michael.20060619222451.67,michael.20060619222451.68,michael.20060619222451.69,michael.20060619222451.70,michael.20060619222451.71,michael.20060619222451.72,michael.20060619222451.73,michael.20060619222451.74,michael.20060619222451.75,michael.20060619222451.76,michael.20060619222451.77,michael.20060619222451.78,michael.20060619222451.79,michael.20060619222451.80,michael.20060619222451.81,michael.20060619222451.82,michael.20060619222451.83,michael.20060619222451.84,michael.20060619222451.85,michael.20060619222451.86,michael.20060619222451.87,michael.20060619222451.88,michael.20060619222451.89"><vh>@file charting/charts.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060619222451.1" a="M"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060619223120"><vh>Matplotlib Redirections</vh></v>
<v t="michael.20060619222451.8"><vh>class MatplotChart</vh>
<v t="michael.20060619222451.9"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.10"><vh>printer</vh></v>
<v t="michael.20060804121345" a="M"><vh>register_editors</vh></v>
<v t="michael.20060619222451.11"><vh>__init__</vh></v>
<v t="michael.20060619222451.12"><vh>_add_decorations</vh></v>
<v t="michael.20060619222451.13"><vh>add_decorations</vh></v>
<v t="michael.20060619222451.14"><vh>create_axes</vh></v>
<v t="michael.20060619222451.15"><vh>create</vh></v>
<v t="michael.20060619222451.16"><vh>get_tip</vh></v>
<v t="michael.20060619222451.17"><vh>setup_axes_interface</vh></v>
</v>
<v t="michael.20060619222451.18"><vh>class TimeWidgetChart</vh>
<v t="michael.20060619222451.19"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060804132135"><vh>register_editors</vh></v>
<v t="michael.20060619222451.20"><vh>__init__</vh></v>
<v t="michael.20060619222451.21"><vh>to_date</vh></v>
<v t="michael.20060619222451.22"><vh>create_axes</vh></v>
<v t="michael.20060619222451.23"><vh>create</vh></v>
<v t="michael.20060619222451.24"><vh>create_all_widgets</vh></v>
<v t="michael.20060619222451.25"><vh>_finalize_row_widgets</vh></v>
</v>
<v t="michael.20060619222451.26"><vh>class TimePlotChart</vh>
<v t="michael.20060619222451.27"><vh>&lt;&lt; class TimePlotChart declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.28"><vh>__init__</vh></v>
<v t="michael.20060619222451.29"><vh>create_axes</vh></v>
<v t="michael.20060619222451.30"><vh>create</vh></v>
<v t="michael.20060619222451.31"><vh>create_plot</vh></v>
</v>
<v t="michael.20060619222451.32"><vh>class TimeMultiChart</vh>
<v t="michael.20060619222451.33"><vh>&lt;&lt; class TimeMultiChart declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.34"><vh>__init__</vh></v>
<v t="michael.20060619222451.35"><vh>create_axes</vh></v>
<v t="michael.20060619222451.36"><vh>create</vh></v>
<v t="michael.20060619222451.37"><vh>add_TimeWidgetAxes</vh></v>
<v t="michael.20060619222451.38"><vh>add_TimePlotAxes</vh></v>
<v t="michael.20060619222451.39"><vh>add_chart</vh></v>
<v t="michael.20060619222451.40"><vh>get_tip</vh></v>
<v t="michael.20060619222451.41"><vh>create_chart</vh></v>
</v>
<v t="michael.20060619222451.42"><vh>class TimeAxisChart</vh>
<v t="michael.20060619222451.43"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060804133122" a="M"><vh>register_editors</vh></v>
<v t="michael.20060619222451.44"><vh>create</vh></v>
<v t="michael.20060619222451.45"><vh>set_time_axis</vh></v>
</v>
<v t="michael.20060619222451.46"><vh>class TimeAxisWidgetChart</vh>
<v t="michael.20060619222451.47"><vh>&lt;&lt; class TimeAxisWidgetChart declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.48"><vh>printer</vh></v>
</v>
<v t="michael.20060619222451.49"><vh>class TimeAxisPlotChart</vh>
<v t="michael.20060619222451.50"><vh>&lt;&lt; class TimeAxisPlotChart declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.51"><vh>printer</vh></v>
</v>
<v t="michael.20060619222451.52"><vh>class TimeAxisMultiChart</vh>
<v t="michael.20060619222451.53"><vh>&lt;&lt; class TimeAxisMultiChart declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.54"><vh>printer</vh></v>
</v>
<v t="michael.20060619222451.55"><vh>class TableChart</vh>
<v t="michael.20060619222451.56"><vh>&lt;&lt; class TableChart declarations &gt;&gt;</vh></v>
<v t="michael.20060804152844"><vh>register_editors</vh></v>
<v t="michael.20060619222451.57"><vh>printer</vh></v>
<v t="michael.20060619222451.58"><vh>__init__</vh></v>
<v t="michael.20060619222451.59"><vh>create_axes</vh></v>
<v t="michael.20060619222451.60"><vh>create</vh></v>
<v t="michael.20060619222451.61"><vh>get_col</vh></v>
<v t="michael.20060619222451.62"><vh>get_row</vh></v>
<v t="michael.20060619222451.63"><vh>add_cell</vh></v>
<v t="michael.20060619222451.64"><vh>create_all_widgets</vh></v>
<v t="michael.20060619222451.65"><vh>_finalize_row_widgets</vh></v>
<v t="michael.20060619222451.66"><vh>_finalize_col_widgets</vh></v>
</v>
<v t="michael.20060619222451.67"><vh>class _DescriptionTable</vh>
<v t="michael.20060619222451.68"><vh>&lt;&lt; class _DescriptionTable declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.69"><vh>__init__</vh></v>
<v t="michael.20060619222451.70"><vh>get_col</vh></v>
<v t="michael.20060619222451.71"><vh>create_all_widgets</vh></v>
<v t="michael.20060619222451.72"><vh>create_header</vh></v>
<v t="michael.20060619222451.73"><vh>_finalize_row_widgets</vh></v>
<v t="michael.20060619222451.74"><vh>modify_header_widget</vh></v>
<v t="michael.20060619222451.75"><vh>modify_widget</vh></v>
</v>
<v t="michael.20060619222451.76"><vh>class TimeTabledChart</vh>
<v t="michael.20060619222451.77"><vh>&lt;&lt; class TimeTabledChart declarations &gt;&gt;</vh></v>
<v t="michael.20060619222451.78"><vh>printer</vh></v>
<v t="michael.20060619222451.79"><vh>__init__</vh></v>
<v t="michael.20060619222451.80"><vh>setup_axes_interface</vh></v>
<v t="michael.20060619222451.81"><vh>_check_limits</vh></v>
<v t="michael.20060619222451.82"><vh>_widget_at</vh></v>
<v t="michael.20060619222451.83"><vh>_mark_widget</vh></v>
<v t="michael.20060619222451.84"><vh>create_axes</vh></v>
<v t="michael.20060619222451.85"><vh>create</vh></v>
<v t="michael.20060619222451.86"><vh>get_tip</vh></v>
<v t="michael.20060619222451.87"><vh>create_chart</vh></v>
</v>
<v t="michael.20060619222451.88"><vh>class TimeAxisTabledChart</vh>
<v t="michael.20060619222451.89"><vh>&lt;&lt; class TimeAxisTabledChart declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060619230818" tnodeList="michael.20060619230818,mr7771.20060609151433,michael.20060619230818.1,michael.20060619230818.2,michael.20060619230818.3,michael.20060619230818.4,michael.20060619230818.5,michael.20060619230818.6,michael.20060619230818.7,michael.20060619230818.8,michael.20060619230818.9,michael.20060619230818.10,michael.20060619230818.11,michael.20060619230818.12,michael.20060619230818.13,michael.20060619230818.14,michael.20060619230818.15,michael.20060619230818.16,michael.20060619230818.17,michael.20060619230818.18,michael.20060619230818.19,michael.20060619230818.20,michael.20060619230818.21,michael.20060619230818.22,michael.20060619230818.23,michael.20060619230818.24,michael.20060619230818.25,michael.20060619230818.26,michael.20060619230818.27,michael.20060619230818.28,michael.20060619230818.29,michael.20060619230818.30,michael.20060619230818.31,michael.20060619230818.32,michael.20060619230818.33,michael.20060619230818.34,michael.20060619230818.35,michael.20060619230818.36,michael.20060619230818.37,michael.20060619230818.38,michael.20060619230818.39,michael.20060619230818.40,michael.20060619230818.41,michael.20060619230818.42,michael.20060619230818.43,michael.20060619230818.44,michael.20060619230818.45,michael.20060619230818.46,michael.20060619230818.47,michael.20060619230818.48,michael.20060619230818.49,michael.20060619230818.50,michael.20060619230818.51,michael.20060619230818.52,michael.20060619230818.53,michael.20060619230818.54,michael.20060619230818.55,michael.20060619230818.56,michael.20060619230818.57,michael.20060619230818.58,michael.20060619230818.59,michael.20060619230818.60,michael.20060619230818.61,michael.20060619230818.62,michael.20060619230818.63,michael.20060619230818.64,michael.20060619230818.65,michael.20060619230818.66,michael.20060619230818.67,michael.20060619230818.68,michael.20061028181551,michael.20061028181551.1,michael.20061028181551.2,michael.20061028181551.4,michael.20061028181551.3,michael.20061114193915,michael.20061113154308.1,michael.20061113154308.2,michael.20061028181551.5,michael.20061028181551.6,michael.20061114193915.1,michael.20060619230818.69,michael.20060619230818.70,michael.20061028181843,michael.20060619230818.71,michael.20060619230818.72,michael.20061028124110,michael.20061028124110.1,michael.20060619230818.73,michael.20061114194524,michael.20060619230818.74,michael.20060619230818.75,michael.20060619230818.76,michael.20060619230818.77,michael.20060619230818.78,michael.20060619230818.79,michael.20060619230818.80,michael.20060619230818.81,michael.20060703181442,michael.20060619230818.82,michael.20060619230818.83,michael.20060619230818.84,michael.20060619230818.85,michael.20060619230818.86,michael.20060619230818.87,michael.20060619230818.88,michael.20060619230818.89,michael.20060619230818.90,michael.20060619230818.91,michael.20060619230818.92"><vh>@file charting/widgets.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060619230818.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060619230818.2"><vh>class LazyText</vh>
<v t="michael.20060619230818.3"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.4"><vh>__init__</vh></v>
<v t="michael.20060619230818.5"><vh>get_prop_tup</vh></v>
<v t="michael.20060619230818.6"><vh>draw</vh></v>
<v t="michael.20060619230818.7" a="M"><vh>get_bottom_top</vh></v>
<v t="michael.20060619230818.8"><vh>get_window_extent</vh></v>
</v>
<v t="michael.20060619230818.9"><vh>class _PropertyType</vh>
<v t="michael.20060619230818.10"><vh>__init__</vh></v>
</v>
<v t="michael.20060619230818.11" a="M"><vh>check_property</vh></v>
<v t="michael.20060619230818.12"><vh>class _PropertyAware</vh>
<v t="michael.20060619230818.13"><vh>&lt;&lt; class _PropertyAware declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.14"><vh>__init__</vh></v>
<v t="michael.20060619230818.15"><vh>set_property</vh></v>
<v t="michael.20060619230818.16"><vh>remove_property</vh></v>
<v t="michael.20060619230818.17"><vh>_find_property_in_chain</vh></v>
<v t="michael.20060619230818.18"><vh>_find_property</vh></v>
<v t="michael.20060619230818.19"><vh>get_font</vh></v>
<v t="michael.20060619230818.20"><vh>get_property</vh></v>
<v t="michael.20060619230818.21"><vh>set_gc</vh></v>
<v t="michael.20060619230818.22"><vh>get_patch</vh></v>
</v>
<v t="michael.20060619230818.23"><vh>class Widget</vh>
<v t="michael.20060619230818.24"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.25"><vh>__init__</vh></v>
<v t="michael.20060619230818.26"><vh>_extend_text_properties</vh></v>
<v t="michael.20060619230818.27"><vh>clear</vh></v>
<v t="michael.20060619230818.28"><vh>text</vh></v>
<v t="michael.20060619230818.29"><vh>set_figure</vh></v>
<v t="michael.20060619230818.30"><vh>set_transform</vh></v>
<v t="michael.20060619230818.31"><vh>set_clip_box</vh></v>
<v t="michael.20060619230818.32"><vh>all_artists</vh></v>
<v t="michael.20060619230818.33"><vh>add_artist</vh></v>
<v t="michael.20060619230818.34"><vh>set_font_factor</vh></v>
<v t="michael.20060619230818.35"><vh>prepare_draw</vh></v>
<v t="michael.20060619230818.36"><vh>overlaps</vh></v>
<v t="michael.20060619230818.37"><vh>contains</vh></v>
<v t="michael.20060619230818.38"><vh>get_bounds</vh></v>
</v>
<v t="michael.20060619230818.39"><vh>class Row</vh>
<v t="michael.20060619230818.40"><vh>&lt;&lt; class Row declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.41"><vh>__init__</vh></v>
<v t="michael.20060619230818.42"><vh>update_height</vh></v>
<v t="michael.20060619230818.43"><vh>draw</vh></v>
<v t="michael.20060619230818.44"><vh>set_y</vh></v>
<v t="michael.20060619230818.45"><vh>full_height</vh></v>
<v t="michael.20060619230818.46"><vh>next_y</vh></v>
<v t="michael.20060619230818.47"><vh>reset_height</vh></v>
<v t="michael.20060619230818.48"><vh>contains</vh></v>
<v t="michael.20060619230818.49"><vh>prepare_draw</vh></v>
<v t="michael.20060619230818.50"><vh>get_bounds</vh></v>
</v>
<v t="michael.20060619230818.51"><vh>class Column</vh>
<v t="michael.20060619230818.52"><vh>&lt;&lt; class Column declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.53"><vh>__init__</vh></v>
<v t="michael.20060619230818.54"><vh>update_width</vh></v>
<v t="michael.20060619230818.55"><vh>draw</vh></v>
<v t="michael.20060619230818.56"><vh>set_x</vh></v>
<v t="michael.20060619230818.57"><vh>full_width</vh></v>
<v t="michael.20060619230818.58"><vh>next_x</vh></v>
<v t="michael.20060619230818.59"><vh>reset_width</vh></v>
<v t="michael.20060619230818.60"><vh>contains</vh></v>
<v t="michael.20060619230818.61"><vh>prepare_draw</vh></v>
<v t="michael.20060619230818.62"><vh>get_bounds</vh></v>
</v>
<v t="michael.20060619230818.63"><vh>class CellWidget</vh>
<v t="michael.20060619230818.64"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.65"><vh>__init__</vh></v>
<v t="michael.20060619230818.66"><vh>get_bounds</vh></v>
<v t="michael.20060619230818.67"><vh>prepare_draw</vh></v>
<v t="michael.20060619230818.68"><vh>draw</vh></v>
</v>
<v t="michael.20061028181551" a="M"><vh>class BoxedTextWidget</vh>
<v t="michael.20061028181551.1"><vh>__init__</vh></v>
<v t="michael.20061028181551.2"><vh>get_bounds</vh></v>
<v t="michael.20061028181551.4"><vh>prepare_draw (stage2)</vh></v>
<v t="michael.20061028181551.3" a="M"><vh>prepare_draw (stage1)</vh></v>
<v t="michael.20061114193915" a="M"><vh>calc_bounding_box</vh>
<v t="michael.20061113154308.1"><vh>&lt;&lt; calculate bbox based on self.text &gt;&gt;</vh></v>
<v t="michael.20061113154308.2"><vh>&lt;&lt; calculate bbox with all artists &gt;&gt;</vh></v>
</v>
<v t="michael.20061028181551.5"><vh>set_pos</vh></v>
<v t="michael.20061028181551.6"><vh>draw</vh></v>
<v t="michael.20061114193915.1" a="M"><vh>check_font_factor</vh></v>
</v>
<v t="michael.20060619230818.69"><vh>class TableWidget</vh>
<v t="michael.20060619230818.70"><vh>__init__</vh></v>
<v t="michael.20061028181843"><vh>set_cell</vh></v>
<v t="michael.20060619230818.71"><vh>get_bounds</vh></v>
<v t="michael.20060619230818.72"><vh>prepare_draw (stage1)</vh></v>
<v t="michael.20061028124110"><vh>prepare_draw (stage2)</vh></v>
<v t="michael.20061028124110.1"><vh>set_pos</vh></v>
<v t="michael.20060619230818.73"><vh>draw</vh></v>
<v t="michael.20061114194524"><vh>check_font_factor</vh></v>
</v>
<v t="michael.20060619230818.74"><vh>class TimeWidget</vh>
<v t="michael.20060619230818.75"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.76"><vh>__init__</vh></v>
<v t="michael.20060619230818.77"><vh>set_shape</vh></v>
<v t="michael.20060619230818.78"><vh>all_artists</vh></v>
<v t="michael.20060619230818.79"><vh>finalized_row</vh></v>
<v t="michael.20060619230818.80"><vh>inside_text</vh></v>
<v t="michael.20060619230818.81"><vh>get_bounds</vh>
<v t="michael.20060703181442"><vh>&lt;&lt; check if inside text fits into the shape &gt;&gt;</vh></v>
</v>
<v t="michael.20060619230818.82"><vh>overlaps</vh></v>
<v t="michael.20060619230818.83"><vh>prepare_draw</vh></v>
<v t="michael.20060619230818.84"><vh>draw</vh></v>
<v t="michael.20060619230818.85"><vh>prepare_inside_text</vh></v>
</v>
<v t="michael.20060619230818.86"><vh>class GanttWidget</vh></v>
<v t="michael.20060619230818.87"><vh>class ResourceBarWidget</vh>
<v t="michael.20060619230818.88"><vh>&lt;&lt; class ResourceBarWidget declarations &gt;&gt;</vh></v>
<v t="michael.20060619230818.89"><vh>__init__</vh></v>
<v t="michael.20060619230818.90"><vh>prepare_draw</vh></v>
<v t="michael.20060619230818.91"><vh>prepare_inside_text</vh></v>
<v t="michael.20060619230818.92"><vh>get_bounds</vh></v>
</v>
</v>
<v t="michael.20060621125853" tnodeList="michael.20060621125853,mr7771.20060609151433,michael.20060621125853.1,michael.20060621125853.2,michael.20061028160826,michael.20061028180706,michael.20061028180706.1,michael.20061028145753,michael.20061026224624,michael.20060621125853.3,michael.20060621125853.4,michael.20060621125853.5,michael.20060621125853.6,michael.20060621125853.7,michael.20060621125853.8,michael.20060621125853.9,michael.20060621125853.10,michael.20060621125853.11,michael.20060621125853.12,michael.20060621125853.13,michael.20060621125853.14,michael.20060621125853.15,michael.20060621125853.16,michael.20060621125853.17,michael.20060621125853.18,michael.20060621125853.19,michael.20060621125853.20,michael.20060621125853.21,michael.20060621125853.22,michael.20060621125853.23,michael.20060621125853.24,michael.20060621125853.25,michael.20060621125853.26,michael.20060621125853.27,michael.20060621125853.28,michael.20060621125853.29,michael.20060621125853.30,michael.20060621125853.31,michael.20060621125853.32,michael.20060621125853.33,michael.20060621125853.34,michael.20060621125853.35,michael.20060621125853.36,michael.20060621125853.37,michael.20060621125853.38,michael.20061028151207,michael.20061028151207.1,michael.20061028151207.2,michael.20061028151207.3,michael.20061028151207.4,michael.20061028151207.5,michael.20061028180926,michael.20061028180926.1,michael.20061028151207.6,michael.20061028180926.2"><vh>@file charting/connector.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060621125853.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060621125853.2"><vh>get_arrow</vh></v>
<v t="michael.20061028160826" a="M"><vh>intersect</vh>
<v t="michael.20061028180706"><vh>&lt;&lt; extract coordinates &gt;&gt;</vh></v>
<v t="michael.20061028180706.1" a="M"><vh>&lt;&lt; define calc &gt;&gt;</vh></v>
</v>
<v t="michael.20061028145753"><vh>GanttConnector</vh>
<v t="michael.20061026224624"><vh>Classes for calculating a line path</vh>
<v t="michael.20060621125853.3" a="M"><vh>class ConnectorPath</vh>
<v t="michael.20060621125853.4"><vh>calc_start_end</vh></v>
<v t="michael.20060621125853.5"><vh>get_lines</vh></v>
<v t="michael.20060621125853.6" a="M"><vh>point_near</vh></v>
<v t="michael.20060621125853.7"><vh>find_y_pos</vh></v>
<v t="michael.20060621125853.8"><vh>get_edges</vh></v>
</v>
<v t="michael.20060621125853.9" a="M"><vh>class StartEndPath</vh>
<v t="michael.20060621125853.10"><vh>calc_x_ends</vh></v>
<v t="michael.20060621125853.11" a="M"><vh>get_edges</vh></v>
</v>
<v t="michael.20060621125853.12"><vh>class StartStartPath</vh>
<v t="michael.20060621125853.13"><vh>calc_x_ends</vh></v>
<v t="michael.20060621125853.14" a="M"><vh>get_edges</vh></v>
</v>
<v t="michael.20060621125853.15"><vh>class EndStartPath</vh>
<v t="michael.20060621125853.16"><vh>calc_x_ends</vh></v>
<v t="michael.20060621125853.17"><vh>get_edges</vh></v>
</v>
<v t="michael.20060621125853.18"><vh>class EndEndPath</vh>
<v t="michael.20060621125853.19"><vh>calc_x_ends</vh></v>
<v t="michael.20060621125853.20" a="M"><vh>get_edges</vh></v>
</v>
<v t="michael.20060621125853.21" a="M"><vh>class ShortestPath</vh>
<v t="michael.20060621125853.22"><vh>calc_x_ends</vh></v>
</v>
</v>
<v t="michael.20060621125853.23"><vh>class GanttConnector</vh>
<v t="michael.20060621125853.24"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060621125853.25"><vh>__init__</vh></v>
<v t="michael.20060621125853.26"><vh>set_path</vh></v>
<v t="michael.20060621125853.27"><vh>set_property</vh></v>
<v t="michael.20060621125853.28"><vh>get_bounds</vh></v>
<v t="michael.20060621125853.29"><vh>contains</vh></v>
<v t="michael.20060621125853.30"><vh>prepare_draw</vh></v>
<v t="michael.20060621125853.31"><vh>draw</vh></v>
</v>
</v>
<v t="michael.20060621125853.32"><vh>class WBKConnector</vh>
<v t="michael.20060621125853.33"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060621125853.34"><vh>__init__</vh></v>
<v t="michael.20060621125853.35"><vh>get_bounds</vh></v>
<v t="michael.20060621125853.36"><vh>contains</vh></v>
<v t="michael.20060621125853.37"><vh>prepare_draw</vh></v>
<v t="michael.20060621125853.38"><vh>draw</vh></v>
</v>
<v t="michael.20061028151207"><vh>class ShortConnector</vh>
<v t="michael.20061028151207.1"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20061028151207.2"><vh>__init__</vh></v>
<v t="michael.20061028151207.3"><vh>get_bounds</vh></v>
<v t="michael.20061028151207.4"><vh>contains</vh></v>
<v t="michael.20061028151207.5" a="M"><vh>prepare_draw</vh>
<v t="michael.20061028180926"><vh>&lt;&lt; calc arrow position &gt;&gt;</vh>
<v t="michael.20061028180926.1"><vh>&lt;&lt; calc line equations &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20061028151207.6" a="M"><vh>draw</vh>
<v t="michael.20061028180926.2"><vh>&lt;&lt; draw arrow &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="michael.20060621130232" tnodeList="michael.20060621130232,mr7771.20060609151433,michael.20060621130232.1,michael.20060621130232.2,michael.20060621130232.3,michael.20060621130232.4,michael.20060621130232.5,michael.20060621130232.6,michael.20060621130232.7,michael.20060621130232.8"><vh>@file charting/shapes.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060621130232.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060621130232.2"><vh>bar</vh></v>
<v t="michael.20060621130232.3"><vh>brace</vh></v>
<v t="michael.20060621130232.4"><vh>combibar</vh></v>
<v t="michael.20060621130232.5"><vh>diamond</vh></v>
<v t="michael.20060621130232.6"><vh>circle</vh></v>
<v t="michael.20060621130232.7"><vh>wedge</vh></v>
<v t="michael.20060621130232.8"><vh>house</vh></v>
</v>
<v t="michael.20060703173916" tnodeList="michael.20060703173916,mr7771.20060609151433,michael.20060703173916.1,michael.20060703173916.3,michael.20060703173916.4,michael.20060703173916.5,michael.20060703173916.6,michael.20060703173916.7,michael.20060703173916.8,michael.20060703173916.9,michael.20060703173916.10,michael.20060703173916.11,michael.20060703173916.12,michael.20060703173916.13,michael.20060703173916.14,michael.20060703173916.15,michael.20060703173916.16,michael.20060703173916.17,michael.20060703173916.18,michael.20060703173916.19,michael.20060703173916.20,michael.20060703173916.21,michael.20060703173916.22,michael.20060703173916.23,michael.20060703173916.24,michael.20060703173916.25,michael.20060703173916.26,michael.20060703173916.27,michael.20060703173916.28,michael.20060703173916.29,michael.20060703173916.30,michael.20060703173916.31,michael.20060703173916.32,michael.20060703173916.33,michael.20060703173916.34,michael.20060703173916.35,michael.20060703173916.36,michael.20060703173916.37,michael.20060703173916.38,michael.20060703173916.39,michael.20060703173916.40,michael.20060703173916.41,michael.20060703173916.42,michael.20060703173916.43,michael.20060703173916.44,michael.20060703173916.45,michael.20060703173916.46,michael.20060703173916.47,michael.20060703173916.48,michael.20060703173916.49,michael.20060703173916.50,michael.20060703173916.51,michael.20060703173916.52,michael.20060703173916.53,michael.20060703173916.54,michael.20060703173916.55,michael.20060703173916.56,michael.20060703173916.57,michael.20060703173916.58,michael.20060703173916.59,michael.20060703173916.60,michael.20060703173916.61,michael.20060703173916.62,michael.20060703173916.63,michael.20060703173916.64"><vh>@file charting/faxes.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060703173916.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060703173916.3"><vh>_cint</vh></v>
<v t="michael.20060703173916.4"><vh>cut_canvas</vh></v>
<v t="michael.20060703173916.5"><vh>class _WidgetCollection</vh>
<v t="michael.20060703173916.6"><vh>&lt;&lt; class _WidgetCollection declarations &gt;&gt;</vh></v>
<v t="michael.20060703173916.7"><vh>__init__</vh></v>
<v t="michael.20060703173916.8"><vh>draw</vh></v>
</v>
<v t="michael.20060703173916.9"><vh>_get_margin</vh></v>
<v t="michael.20060703173916.10"><vh>class MarginAxes</vh>
<v t="michael.20060703173916.11"><vh>__init__</vh></v>
<v t="michael.20060703173916.12"><vh>build_margin_transform</vh></v>
<v t="michael.20060703173916.13"><vh>_set_lim_and_transforms</vh></v>
<v t="michael.20060703173916.14"><vh>in_axes</vh></v>
<v t="michael.20060703173916.15"><vh>cla</vh></v>
<v t="michael.20060703173916.16"><vh>draw</vh></v>
</v>
<v t="michael.20060703173916.17"><vh>class WidgetAxes</vh>
<v t="michael.20060703173916.18"><vh>__init__</vh></v>
<v t="michael.20060703173916.19"><vh>cla</vh></v>
<v t="michael.20060703173916.20"><vh>check_limits</vh></v>
<v t="michael.20060703173916.21"><vh>reset_limits</vh></v>
<v t="michael.20060703173916.22"><vh>_get_renderer</vh></v>
<v t="michael.20060703173916.23"><vh>add_widget</vh></v>
<v t="michael.20060703173916.24"><vh>mark_widget</vh></v>
<v t="michael.20060703173916.25"><vh>find_widget</vh></v>
<v t="michael.20060703173916.26"><vh>widget_at</vh></v>
<v t="michael.20060703173916.27"><vh>set_focused_on</vh></v>
<v t="michael.20060703173916.28"><vh>set_focused_off</vh></v>
<v t="michael.20060703173916.29"><vh>set_marker</vh></v>
<v t="michael.20060703173916.30"><vh>widget_x_visible</vh></v>
<v t="michael.20060703173916.31"><vh>widget_y_visible</vh></v>
<v t="michael.20060703173916.32"><vh>zoomx</vh></v>
<v t="michael.20060703173916.33"><vh>zoomy</vh></v>
<v t="michael.20060703173916.34"><vh>_calc_hsep</vh></v>
<v t="michael.20060703173916.35"><vh>_draw_widgets</vh></v>
<v t="michael.20060703173916.36"><vh>clear_speed_cache</vh></v>
<v t="michael.20060703173916.37"><vh>speed_up</vh></v>
<v t="michael.20060703173916.38"><vh>draw</vh></v>
<v t="michael.20060703173916.39"><vh>_set_lim_and_transforms</vh></v>
</v>
<v t="michael.20060703173916.40"><vh>class PointAxes</vh>
<v t="michael.20060703173916.41"><vh>__init__</vh></v>
<v t="michael.20060703173916.42"><vh>cla</vh></v>
<v t="michael.20060703173916.43"><vh>check_limits</vh></v>
<v t="michael.20060703173916.44"><vh>autoscale_view</vh></v>
</v>
<v t="michael.20060703173916.45"><vh>class TimeAxes</vh>
<v t="michael.20060703173916.46"><vh>&lt;&lt; class TimeAxes declarations &gt;&gt;</vh></v>
<v t="michael.20060703173916.47"><vh>set_time_axis</vh></v>
<v t="michael.20060703173916.48"><vh>xaxis_timescale</vh></v>
<v t="michael.20060703173916.49"><vh>set_time_lim</vh></v>
<v t="michael.20060703173916.50"><vh>get_time_lim</vh></v>
<v t="michael.20060703173916.51"><vh>format_coord</vh></v>
<v t="michael.20060703173916.52"><vh>update_time_axis</vh></v>
<v t="michael.20060703173916.53"><vh>unshare</vh></v>
</v>
<v t="michael.20060703173916.54"><vh>class TimePlotAxes</vh>
<v t="michael.20060703173916.55"><vh>&lt;&lt; class TimePlotAxes declarations &gt;&gt;</vh></v>
<v t="michael.20060703173916.56"><vh>__init__</vh></v>
<v t="michael.20060703173916.57"><vh>draw</vh></v>
</v>
<v t="michael.20060703173916.58"><vh>class TimeWidgetAxes</vh>
<v t="michael.20060703173916.59"><vh>&lt;&lt; class TimeWidgetAxes declarations &gt;&gt;</vh></v>
<v t="michael.20060703173916.60"><vh>__init__</vh></v>
<v t="michael.20060703173916.61"><vh>set_auto_scale_y</vh></v>
<v t="michael.20060703173916.62"><vh>check_limits</vh></v>
<v t="michael.20060703173916.63"><vh>autoscale_view</vh></v>
<v t="michael.20060703173916.64"><vh>widget_at</vh></v>
</v>
</v>
<v t="michael.20060910114955" a="E" tnodeList="michael.20060910114955,mr7771.20060609151433,michael.20060910114955.1,michael.20060910115214,michael.20060910114955.2,michael.20060910114955.3,michael.20060910114955.4,michael.20060910114955.5,michael.20071111221700,michael.20060910114955.6,michael.20060910114955.7,michael.20060910114955.8,michael.20060910114955.9,michael.20060910114955.10,michael.20060910114955.11,michael.20060910114955.12,michael.20060910114955.13,michael.20060910114955.14,michael.20060910114955.15,michael.20060910114955.16,michael.20060910114955.17,michael.20060910114955.18,michael.20060910114955.19,michael.20060910114955.20,michael.20060910114955.21,michael.20060910114955.22,michael.20060910114955.23,michael.20060910114955.24,michael.20060910114955.25,michael.20060910114955.26,michael.20060910114955.27,michael.20060910114955.28,michael.20060910114955.29,michael.20060910114955.30,michael.20060910114955.31,michael.20060910114955.32,michael.20060910114955.33,michael.20060910114955.34,michael.20060910114955.35,michael.20060910114955.36,michael.20060910114955.37,michael.20060910114955.38,michael.20060910114955.39,michael.20060910114955.40,michael.20060910114955.41,michael.20060910114955.42,michael.20060910114955.43,michael.20060910114955.44,michael.20060910114955.45,michael.20060910114955.46,michael.20060910114955.47,michael.20060910114955.48,michael.20060910114955.49,michael.20060910114955.50,michael.20060910114955.51,michael.20060910114955.52,michael.20060910114955.53,michael.20060910114955.54,michael.20060910114955.55,michael.20060910114955.56"><vh>@file charting/taxis.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060910114955.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060910115214" a="E"><vh>Locators</vh>
<v t="michael.20060910114955.2"><vh>class Locator</vh>
<v t="michael.20060910114955.3"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060910114955.4"><vh>__init__</vh></v>
<v t="michael.20060910114955.5"><vh>get_marks</vh></v>
<v t="michael.20071111221700"><vh>build_mark</vh></v>
<v t="michael.20060910114955.6"><vh>fits</vh></v>
<v t="michael.20060910114955.7"><vh>prepare</vh></v>
<v t="michael.20060910114955.8"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.9"><vh>_delta</vh></v>
<v t="michael.20060910114955.10"><vh>_get_format</vh></v>
<v t="michael.20060910114955.11" a="M"><vh>_calc_markers</vh></v>
<v t="michael.20060910114955.12"><vh>is_free</vh></v>
</v>
<v t="michael.20060910114955.13"><vh>class DecadeLocator</vh>
<v t="michael.20060910114955.14"><vh>_delta</vh></v>
<v t="michael.20060910114955.15"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.16"><vh>__call__</vh></v>
</v>
<v t="michael.20060910114955.17"><vh>class YearLocator</vh>
<v t="michael.20060910114955.18"><vh>_delta</vh></v>
<v t="michael.20060910114955.19" a="M"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.20"><vh>__call__</vh></v>
</v>
<v t="michael.20060910114955.21"><vh>class QuaterLocator</vh>
<v t="michael.20060910114955.22"><vh>_delta</vh></v>
<v t="michael.20060910114955.23" a="M"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.24"><vh>__call__</vh></v>
</v>
<v t="michael.20060910114955.25"><vh>class MonthLocator</vh>
<v t="michael.20060910114955.26"><vh>_delta</vh></v>
<v t="michael.20060910114955.27" a="M"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.28"><vh>__call__</vh></v>
</v>
<v t="michael.20060910114955.29" a="E"><vh>class WeekLocator</vh>
<v t="michael.20060910114955.30"><vh>_delta</vh></v>
<v t="michael.20060910114955.31" a="M"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.32" a="M"><vh>__call__</vh></v>
</v>
<v t="michael.20060910114955.33"><vh>class DayLocator</vh>
<v t="michael.20060910114955.34"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060910114955.35"><vh>_delta</vh></v>
<v t="michael.20060910114955.36"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.37"><vh>__call__</vh></v>
<v t="michael.20060910114955.38"><vh>is_free</vh></v>
</v>
<v t="michael.20060910114955.39"><vh>class SlotLocator</vh>
<v t="michael.20060910114955.40"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060910114955.41"><vh>_delta</vh></v>
<v t="michael.20060910114955.42"><vh>__call__</vh></v>
<v t="michael.20060910114955.43"><vh>_calc_sizes</vh></v>
<v t="michael.20060910114955.44"><vh>get_marks</vh></v>
<v t="michael.20060910114955.45"><vh>is_free</vh></v>
</v>
</v>
<v t="michael.20060910114955.46"><vh>_zigzag_lines</vh></v>
<v t="michael.20060910114955.47"><vh>class TimeAxis</vh>
<v t="michael.20060910114955.48"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060910114955.49"><vh>__init__</vh></v>
<v t="michael.20060910114955.50"><vh>calc_height</vh></v>
<v t="michael.20060910114955.51"><vh>set_transform</vh></v>
<v t="michael.20060910114955.52"><vh>draw</vh></v>
<v t="michael.20060910114955.53"><vh>find_ticker</vh></v>
<v t="michael.20060910114955.54"><vh>draw_scale</vh></v>
<v t="michael.20060910114955.55"><vh>draw_grid</vh></v>
<v t="michael.20060910114955.56"><vh>draw_text</vh></v>
</v>
</v>
</v>
<v t="mr7771.20060608164004.454" a="E"><vh>Gui</vh>
<v t="michael.20070115170252" tnodeList="michael.20070115170252,mr7771.20060609151433,michael.20070115170327,michael.20060623001958.2,michael.20060623001958.3,michael.20060623001958.4"><vh>@file gui/patches.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20070115170327"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060623001958.2"><vh>class PatchedDialog</vh>
<v t="michael.20060623001958.3"><vh>&lt;&lt; gtk patched dialog &gt;&gt;</vh></v>
<v t="michael.20060623001958.4"><vh>&lt;&lt; original dialog &gt;&gt;</vh></v>
</v>
</v>
<v t="mr7771.20060608165446" a="E"><vh>Editor</vh>
<v t="mr7771.20060609151433.1" a="E" tnodeList="mr7771.20060609151433.1,mr7771.20060609151433,mr7771.20060609151433.2,mr7771.20060609151433.3,michael.20060704235642,michael.20060705002353,michael.20060705013905,michael.20060705002353.1,mr7771.20060609151433.4,mr7771.20060609151433.5,michael.20060923141119,michael.20060901185155,mr7771.20060609151433.7,michael.20060705164052,michael.20060705164052.1,mr7771.20060609151433.8,mr7771.20060609151433.9,mr7771.20060609151433.10"><vh>@file gui/editor/__init__.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="mr7771.20060609151433.2"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="mr7771.20060609151433.3"><vh>is_bool_option</vh></v>
<v t="michael.20060704235642" a="M"><vh>class PlanEditorProxy</vh>
<v t="michael.20060705002353" a="M"><vh>__init__</vh>
<v t="michael.20060705013905"><vh>&lt;&lt; redirect methods &gt;&gt;</vh></v>
</v>
<v t="michael.20060705002353.1"><vh>Destroy</vh></v>
</v>
<v t="mr7771.20060609151433.4" a="M"><vh>class PlanEditor</vh>
<v t="mr7771.20060609151433.5"><vh>__init__</vh>
<v t="michael.20060923141119"><vh>&lt;&lt; redirect methods &gt;&gt;</vh></v>
</v>
<v t="michael.20060901185155"><vh>_on_shash_pos_change</vh></v>
<v t="mr7771.20060609151433.7"><vh>_on_unsplit</vh></v>
<v t="michael.20060705164052"><vh>show</vh></v>
<v t="michael.20060705164052.1"><vh>hide</vh></v>
<v t="mr7771.20060609151433.8"><vh>toggle_browser</vh></v>
<v t="mr7771.20060609151433.9"><vh>goto_line</vh></v>
<v t="mr7771.20060609151433.10"><vh>find_in_source</vh></v>
</v>
</v>
<v t="michael.20060623001958" tnodeList="michael.20060623001958,mr7771.20060609151433,michael.20060623001958.1,michael.20060623002701,michael.20060623152229,michael.20060623152229.1,michael.20060623152229.2,michael.20060628145509,michael.20060623152229.3,michael.20060628145509.1"><vh>@file gui/editor/editorlib.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060623001958.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060623002701" a="M"><vh>class MainView</vh>
<v t="michael.20060623152229"><vh>__init__</vh></v>
<v t="michael.20060623152229.1" a="M"><vh>button_cancel</vh></v>
<v t="michael.20060623152229.2"><vh>button_ok</vh></v>
<v t="michael.20060628145509"><vh>button_refresh</vh></v>
<v t="michael.20060623152229.3"><vh>layout</vh></v>
<v t="michael.20060628145509.1" a="M"><vh>get_stock_control</vh></v>
</v>
</v>
<v t="mr7771.20060614140603" tnodeList="mr7771.20060614140603,mr7771.20060609151433,mr7771.20060614140603.1,mr7771.20060614140603.2,mr7771.20060614141538,mr7771.20060614142353,mr7771.20060614141538.1"><vh>@file gui/editor/classifiers.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="mr7771.20060614140603.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="mr7771.20060614140603.2"><vh>is_task</vh></v>
<v t="mr7771.20060614141538"><vh>is_resource</vh></v>
<v t="mr7771.20060614142353"><vh>is_observer</vh></v>
<v t="mr7771.20060614141538.1"><vh>lightweight classifiers</vh></v>
</v>
<v t="mr7771.20060609231152" a="E" tnodeList="mr7771.20060609231152,mr7771.20060609151433,mr7771.20060609231152.1,michael.20060616213907,michael.20060703235820,michael.20060915183222,mr7771.20060609231152.2,mr7771.20060609231152.3,michael.20060621180747,michael.20060621183054,michael.20060621183003,michael.20060621203738,michael.20070116120608,michael.20060707121238,michael.20060707181914,michael.20060707125319,michael.20060707130205,mr7771.20060609231152.4,michael.20060703235036,mr7771.20060609231152.5,mr7771.20060609231152.7,mr7771.20060609232136.1,mr7771.20060609232136,mr7771.20060609231152.9,mr7771.20060609235111,mr7771.20060609231152.10,mr7771.20060609231152.11,michael.20060703170652,michael.20060703235036.2,michael.20060703235036.3,mr7771.20060609231152.13,mr7771.20060609231152.14,mr7771.20060609231152.15,mr7771.20060609231152.16,mr7771.20060609231152.17,mr7771.20060609231152.18,mr7771.20060609231152.19,michael.20060616153549,michael.20060919150828,michael.20060919150828.1,michael.20060919150620,michael.20070926130714,michael.20060919150620.1,michael.20061110182612,michael.20060919150620.2,michael.20060919150620.3,michael.20060919150620.4,michael.20060919153708,michael.20060919150620.6,michael.20060919150620.5,michael.20061002030802,mr7771.20060609231152.20,mr7771.20060609231152.22,mr7771.20060609231152.23,mr7771.20060609231152.24,mr7771.20060609231152.25,mr7771.20060609231152.26,mr7771.20060609231152.27,mr7771.20060609231152.28,mr7771.20060609231152.29,mr7771.20060609231152.30,mr7771.20060609231152.31,mr7771.20060609231152.32,mr7771.20060609231152.33,mr7771.20060609231152.49,mr7771.20060609231152.39,mr7771.20060613224409,michael.20060619163321,michael.20060903115207,michael.20060619164749,michael.20060619163321.1,mr7771.20060616091420,michael.20060616170952,mr7771.20060609231152.45,mr7771.20060614120349,mr7771.20060616091420.1,mr7771.20060609231152.43,michael.20060724204442,mr7771.20060609231152.44,mr7771.20060609231152.46,mr7771.20060614114501,michael.20060616162635,mr7771.20060614121509,michael.20060616151822,mr7771.20060614121949,mr7771.20060609231152.42,michael.20060616171654,mr7771.20060613102529,michael.20060704001500,michael.20060704001244,michael.20060704001124,michael.20060703235912,mr7771.20060609231152.37,michael.20060704001124.4,michael.20060704001124.1,michael.20060704001124.2,michael.20060704001124.3,michael.20060704001124.4,michael.20060704001124.6,michael.20060703235853,michael.20060913121250,michael.20060913121250.1,michael.20060913121250.2,mr7771.20060614141538.2,mr7771.20060614090309,michael.20060616185633,michael.20060616185633.1,michael.20060708104315,michael.20060616185633.2,michael.20060616185633.3,mr7771.20060609231152.36,michael.20060621182829,michael.20061110184924,michael.20061110184924.1,michael.20061110184924.2,michael.20060622092032,michael.20060923124429,michael.20060923124429.1,michael.20060929232917,michael.20060915105317,michael.20061031174101.1,michael.20060923154026,michael.20060923154026.1,michael.20061031174101,michael.20060826120325,michael.20060826121701,michael.20060704020852,michael.20060622092054,michael.20060622105356,michael.20060622105356.1,michael.20060622103212,michael.20070116154322,michael.20060622112139,michael.20060622112139.1,michael.20060622105715,michael.20060628231054,michael.20060929220600,michael.20060831002737,michael.20060929220600.2"><vh>@file gui/editor/editor.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="mr7771.20060609231152.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060616213907"><vh>&lt;&lt; Editor Completions &gt;&gt;</vh></v>
<v t="michael.20060703235820"><vh>project_names</vh></v>
<v t="michael.20060915183222"><vh>Task CodeItem Functions</vh></v>
<v t="mr7771.20060609231152.2"><vh>class SearchTool</vh>
<v t="mr7771.20060609231152.3"><vh>__init__</vh></v>
</v>
<v t="michael.20060621180747"><vh>class ContextButton</vh>
<v t="michael.20060621183054"><vh>__init__</vh></v>
<v t="michael.20060621183003"><vh>set_bitmap</vh></v>
<v t="michael.20060621203738"><vh>hide</vh></v>
<v t="michael.20070116120608"><vh>move</vh></v>
</v>
<v t="michael.20060707121238"><vh>class ShadowStyler</vh>
<v t="michael.20060707181914"><vh>__init__</vh></v>
<v t="michael.20060707125319"><vh>StyleSetSpec</vh></v>
<v t="michael.20060707130205"><vh>highlite</vh></v>
</v>
<v t="mr7771.20060609231152.4"><vh>class Editor</vh>
<v t="michael.20060703235036"><vh>&lt;&lt; _parse_evaluation &gt;&gt;</vh></v>
<v t="mr7771.20060609231152.5"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="mr7771.20060609231152.7"><vh>__init__</vh>
<v t="mr7771.20060609232136.1"><vh>&lt;&lt; Editor Adjustments &gt;&gt;</vh></v>
<v t="mr7771.20060609232136"><vh>&lt;&lt; Bind Events &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609231152.9"><vh>wxPython Methods</vh>
<v t="mr7771.20060609235111"><vh>_on_pos_changed</vh></v>
<v t="mr7771.20060609231152.10"><vh>_on_get_focus</vh></v>
<v t="mr7771.20060609231152.11"><vh>_on_change</vh>
<v t="michael.20060703170652"><vh>&lt;&lt; make backup if necessary &gt;&gt;</vh></v>
<v t="michael.20060703235036.2"><vh>&lt;&lt; change the context button if neccessary &gt;&gt;</vh></v>
<v t="michael.20060703235036.3"><vh>&lt;&lt; renew the context &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609231152.13"><vh>_on_find_close</vh></v>
<v t="mr7771.20060609231152.14"><vh>_on_find</vh></v>
<v t="mr7771.20060609231152.15"><vh>_on_right_down</vh></v>
<v t="mr7771.20060609231152.16"><vh>_on_new_char</vh></v>
<v t="mr7771.20060609231152.17"><vh>_on_macro_notify</vh></v>
<v t="mr7771.20060609231152.18"><vh>_on_insert_completion</vh></v>
</v>
<v t="mr7771.20060609231152.19"><vh>Menu Methods</vh>
<v t="michael.20060616153549"><vh>set_menus</vh>
<v t="michael.20060919150828"><vh>&lt;&lt; create help menu &gt;&gt;</vh></v>
<v t="michael.20060919150828.1"><vh>&lt;&lt; create snapshot menu &gt;&gt;</vh></v>
<v t="michael.20060919150620"><vh>&lt;&lt; create basic edit menus &gt;&gt;</vh>
<v t="michael.20070926130714"><vh>&lt;&lt; copy &amp; cut patch &gt;&gt;</vh></v>
</v>
<v t="michael.20060919150620.1"><vh>&lt;&lt; create comment menus &gt;&gt;</vh></v>
<v t="michael.20061110182612"><vh>&lt;&lt; create bookmark menus &gt;&gt;</vh></v>
<v t="michael.20060919150620.2"><vh>&lt;&lt; create find menus &gt;&gt;</vh></v>
<v t="michael.20060919150620.3"><vh>&lt;&lt; create macro menus &gt;&gt;</vh></v>
<v t="michael.20060919150620.4"><vh>&lt;&lt; create context menu &gt;&gt;</vh></v>
<v t="michael.20060919153708"><vh>&lt;&lt; create correct code menu &gt;&gt;</vh></v>
<v t="michael.20060919150620.5"><vh>&lt;&lt; create fold menus &gt;&gt;</vh></v>
<v t="michael.20061002030802"><vh>&lt;&lt; create Generate HTML menu &gt;&gt;</vh></v>
<v t="michael.20060919150620.6"><vh>&lt;&lt; create menu separators &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609231152.20"><vh>menu_snapshot</vh></v>
<v t="mr7771.20060609231152.22"><vh>menu_insert_date</vh></v>
<v t="mr7771.20060609231152.23"><vh>menu_uncomment_selection</vh></v>
<v t="mr7771.20060609231152.24"><vh>menu_comment_selection</vh></v>
<v t="mr7771.20060609231152.25"><vh>menu_find_forward</vh></v>
<v t="mr7771.20060609231152.26"><vh>menu_find_backward</vh></v>
<v t="mr7771.20060609231152.27"><vh>menu_replace</vh></v>
<v t="mr7771.20060609231152.28"><vh>menu_goto_line</vh></v>
</v>
<v t="mr7771.20060609231152.29"><vh>Macro Methods</vh>
<v t="mr7771.20060609231152.30"><vh>no_record_call</vh></v>
<v t="mr7771.20060609231152.31"><vh>start_macro</vh></v>
<v t="mr7771.20060609231152.32"><vh>stop_macro</vh></v>
<v t="mr7771.20060609231152.33"><vh>execute_macro</vh></v>
<v t="mr7771.20060609231152.49"><vh>smart_replace_selection</vh></v>
<v t="mr7771.20060609231152.39"><vh>inspect_indent_char</vh></v>
</v>
<v t="mr7771.20060613224409"><vh>Completion and Calltip Methods</vh>
<v t="michael.20060619163321"><vh>guess_object</vh>
<v t="michael.20060903115207"><vh>&lt;&lt; calculate search end &gt;&gt;</vh></v>
<v t="michael.20060619164749"><vh>&lt;&lt; find context start line &gt;&gt;</vh></v>
<v t="michael.20060619163321.1"><vh>&lt;&lt; define find_last &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060616091420"><vh>make_attrib_list</vh></v>
<v t="michael.20060616170952"><vh>get_dot_object</vh></v>
<v t="mr7771.20060609231152.45"><vh>get_doc_object</vh></v>
<v t="mr7771.20060614120349"><vh>get_word_at</vh></v>
<v t="mr7771.20060616091420.1"><vh>get_session_completions</vh></v>
<v t="mr7771.20060609231152.43"><vh>get_resource_completions</vh></v>
<v t="michael.20060724204442"><vh>get_calendar_completions</vh></v>
<v t="mr7771.20060609231152.44"><vh>get_evaluation_completions</vh></v>
<v t="mr7771.20060609231152.46"><vh>show_completion</vh>
<v t="mr7771.20060614114501"><vh>&lt;&lt; check style &gt;&gt;</vh></v>
<v t="michael.20060616162635"><vh>&lt;&lt; try to create dot completion list &gt;&gt;</vh></v>
<v t="mr7771.20060614121509"><vh>&lt;&lt; create non dot completion list &gt;&gt;</vh></v>
<v t="michael.20060616151822"><vh>&lt;&lt; find an alternative completion list &gt;&gt;</vh></v>
<v t="mr7771.20060614121949"><vh>&lt;&lt; show list &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609231152.42"><vh>show_call_tip</vh>
<v t="michael.20060616171654"><vh>&lt;&lt; calculate obj and attrib &gt;&gt;</vh></v>
</v>
</v>
<v t="mr7771.20060613102529"><vh>Misc Methods</vh>
<v t="michael.20060704001500"><vh>show_task</vh></v>
<v t="michael.20060704001244"><vh>show_object</vh></v>
<v t="michael.20060704001124"><vh>check_modified</vh></v>
<v t="michael.20060703235912"><vh>sync_text</vh></v>
<v t="mr7771.20060609231152.37"><vh>refresh</vh>
<v t="michael.20060704001124.1"><vh>&lt;&lt; save current position &gt;&gt;</vh></v>
<v t="michael.20060704001124.2"><vh>&lt;&lt; create new document &gt;&gt;</vh></v>
<v t="michael.20060704001124.3"><vh>&lt;&lt; misc document settings &gt;&gt;</vh></v>
<v t="michael.20060704001124.4"><vh>&lt;&lt; module settings &gt;&gt;</vh></v>
<v t="michael.20060704001124.6"><vh>&lt;&lt; restore position &gt;&gt;</vh></v>
</v>
<v t="michael.20060703235853"><vh>update_code_info</vh>
<v t="michael.20060913121250"><vh>&lt;&lt; assign tasks to code_items &gt;&gt;</vh></v>
<v t="michael.20060913121250.1"><vh>&lt;&lt; assign observers and resources to code_items &gt;&gt;</vh></v>
<v t="michael.20060913121250.2"><vh>&lt;&lt; assign evaluations to code_items &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060614141538.2"><vh>get_module</vh></v>
<v t="mr7771.20060614090309"><vh>check_context</vh>
<v t="michael.20060616185633"><vh>&lt;&lt; find and activate the current context &gt;&gt;</vh></v>
<v t="michael.20060616185633.1"><vh>&lt;&lt; update browser and refresh &gt;&gt;</vh></v>
<v t="michael.20060616185633.2"><vh>&lt;&lt; calculate attribute name &gt;&gt;</vh></v>
<v t="michael.20060616185633.3"><vh>&lt;&lt; update my siblings &gt;&gt;</vh></v>
<v t="michael.20060708104315"><vh>&lt;&lt; highlite context &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609231152.36"><vh>__find</vh></v>
<v t="michael.20060621182829"><vh>move_context_button</vh></v>
<v t="michael.20061110184924"><vh>toggle_bookmark</vh></v>
<v t="michael.20061110184924.1"><vh>goto_next_bookmark</vh></v>
<v t="michael.20061110184924.2"><vh>goto_prev_bookmark</vh></v>
</v>
<v t="michael.20060622092032"><vh>Methods for external editing</vh>
<v t="michael.20060923124429"><vh>find_resource_references</vh></v>
<v t="michael.20060923124429.1"><vh>find_task_references</vh></v>
<v t="michael.20060929232917"><vh>find_evaluation_references</vh></v>
<v t="michael.20060915105317"><vh>correct_code</vh></v>
<v t="michael.20061031174101.1"><vh>correct_task_code</vh>
<v t="michael.20060923154026"><vh>&lt;&lt; change all relative paths of my sources &gt;&gt;</vh></v>
<v t="michael.20060923154026.1"><vh>&lt;&lt; change the path in all tasks that depend on me &gt;&gt;</vh></v>
</v>
<v t="michael.20061031174101"><vh>correct_resource_code</vh></v>
<v t="michael.20060826120325"><vh>get_attribs</vh>
<v t="michael.20060826121701"><vh>&lt;&lt; filter out child code &gt;&gt;</vh></v>
</v>
<v t="michael.20060704020852"><vh>eval_expression</vh></v>
<v t="michael.20060622092054"><vh>get_expression_range</vh>
<v t="michael.20060622105356"><vh>&lt;&lt; find start of expression &gt;&gt;</vh></v>
<v t="michael.20060622105356.1"><vh>&lt;&lt; find end of expression &gt;&gt;</vh></v>
</v>
<v t="michael.20060622103212"><vh>find_parent_line</vh>
<v t="michael.20060622112139"><vh>&lt;&lt; check if pos is not in a string or comment &gt;&gt;</vh></v>
<v t="michael.20060622112139.1"><vh>&lt;&lt; check if pos is at the end of an expression &gt;&gt;</vh></v>
<v t="michael.20070116154322"><vh>&lt;&lt; check if pos ident is smaller &gt;&gt;</vh></v>
</v>
<v t="michael.20060622105715"><vh>get_expression</vh></v>
<v t="michael.20060628231054"><vh>replace_expression</vh>
<v t="michael.20060929220600"><vh>&lt;&lt; auto indent text &gt;&gt;</vh></v>
</v>
<v t="michael.20060831002737"><vh>insert_expression</vh>
<v t="michael.20060929220600.2"><vh>&lt;&lt; auto indent text &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="mr7771.20060608165446.4" tnodeList="mr7771.20060608165446.4,mr7771.20060609151433,mr7771.20060609222452,michael.20060619184051,michael.20060729171506,michael.20060801124835,michael.20060801124835.1,michael.20060801124835.2,michael.20060913150931,michael.20060622093608,michael.20060616193412,michael.20060616193412.1,michael.20060616193412.2,michael.20060616193412.3,michael.20060619235739,michael.20060619234514,mr7771.20060609225045,michael.20061026113601,michael.20060616141344,michael.20060918130215,michael.20060914094858,michael.20060914113429,michael.20060828221603,mr7771.20060614203356,michael.20060616143205,michael.20060616143938,michael.20060616163019,michael.20060621173535,michael.20060616143205.1,michael.20060919173141,michael.20060616141400.1,michael.20060919173141.1,michael.20060919173151,michael.20060919173151.1,michael.20060919173151.2,michael.20060919173151.3,mr7771.20060614124044,mr7771.20060614124044.1,michael.20061026113601.1,michael.20060616163651,michael.20060616163651.1,mr7771.20060614124118,michael.20060907105636,mr7771.20060614124301,mr7771.20060614124952,michael.20061114113543,mr7771.20060614124751,mr7771.20060614124751.1,mr7771.20060614124301.1,mr7771.20060609224238.3,michael.20060828221821,michael.20060918132012,michael.20060828221821.1,michael.20060616144838,mr7771.20060610004423.1,mr7771.20060614134507,mr7771.20060614134507.1,mr7771.20060609223152,michael.20060616204036,michael.20060828221643,michael.20061109163439,michael.20061109173515,michael.20060616204036.1,michael.20060616144838.1,mr7771.20060610005033.6,mr7771.20060614124751.2,michael.20060619232254,mr7771.20060609223152.1,michael.20060901114003,michael.20060918131942,michael.20060901114003.1,michael.20060616144838.2,mr7771.20060610005713.1,mr7771.20060609224238.5,michael.20060828221856,michael.20060918130628,michael.20060828221856.1,michael.20060616144838.3,mr7771.20060614203713.1,mr7771.20060614203713,michael.20060822215648,mr7771.20060614203713.2,michael.20060616175302,michael.20060619164503,michael.20060901205413,michael.20060901205826,michael.20060619164503.2,michael.20060619192815,michael.20060619193517,michael.20060616175302.1,michael.20060616175302.2,mr7771.20060609223152.2,michael.20060619183441,michael.20060918132238,michael.20060828221931,michael.20060619183441.1,michael.20060616144322,mr7771.20060609224238.1,mr7771.20060609224238.2,mr7771.20060610005033,mr7771.20060610005033.1,michael.20060616212150,mr7771.20060613111615,michael.20060616203047,michael.20060616203047.1,michael.20060616144322.1,mr7771.20060613111615.2,mr7771.20060613174236,michael.20060616144322.2,mr7771.20060613174515.1,mr7771.20060609224238.4,michael.20060918131528,michael.20061028120746,michael.20060918131528.1,michael.20060918131528.2,michael.20060616175116,michael.20060616181548,michael.20060616181548.1,michael.20060616182813,michael.20060616175207,michael.20060616175207.1,michael.20060616192508,michael.20060616202740,michael.20060616202740.1,michael.20060616192508.1,michael.20060616192508.2"><vh>@file gui/editor/context.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="mr7771.20060609222452"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060619184051" a="M"><vh>get_observer_pseudo</vh></v>
<v t="michael.20060729171506"><vh>create_editor_menu</vh>
<v t="michael.20060801124835" a="M"><vh>&lt;&lt; define improve_duplicate_names &gt;&gt;</vh></v>
<v t="michael.20060801124835.1" a="M"><vh>&lt;&lt; define make_groups &gt;&gt;</vh></v>
<v t="michael.20060801124835.2"><vh>&lt;&lt; define create_menu &gt;&gt;</vh>
<v t="michael.20060913150931"><vh>&lt;&lt; extract menu position from title &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060622093608"><vh>class ItemEditor</vh></v>
<v t="michael.20060616193412"><vh>class PTask</vh>
<v t="michael.20060616193412.1" a="M"><vh>__init__</vh></v>
<v t="michael.20060616193412.2"><vh>root</vh></v>
<v t="michael.20060616193412.3" a="M"><vh>up</vh></v>
<v t="michael.20060619235739"><vh>__getattr__</vh></v>
<v t="michael.20060619234514" a="M"><vh>_get__all__</vh></v>
</v>
<v t="mr7771.20060609225045" a="M"><vh>class Context</vh>
<v t="michael.20061026113601"><vh>Methods</vh>
<v t="michael.20060616141344"><vh>Interface</vh>
<v t="michael.20060918130215"><vh>get_last_code_item</vh></v>
<v t="michael.20060914094858" a="M"><vh>append_item</vh></v>
<v t="michael.20060914113429"><vh>insert_item</vh></v>
<v t="michael.20060828221603"><vh>make_browser_menu</vh></v>
<v t="mr7771.20060614203356"><vh>activate</vh></v>
<v t="michael.20060616143205"><vh>get_main_completion_list</vh></v>
<v t="michael.20060616143938"><vh>get_sub_completion_list</vh></v>
<v t="michael.20060616163019"><vh>find_object</vh></v>
<v t="michael.20060621173535" a="M"><vh>make_button</vh></v>
</v>
<v t="michael.20060616143205.1"><vh>Methods to Overwrite</vh>
<v t="michael.20060919173141"><vh>get_editors</vh></v>
<v t="michael.20060616141400.1"><vh>can_activate</vh></v>
</v>
<v t="michael.20060919173141.1"><vh>Tool Methods</vh>
<v t="michael.20060919173151"><vh>amend_browser_menu</vh>
<v t="michael.20060919173151.1"><vh>&lt;&lt; insert "Add Attributes" menu &gt;&gt;</vh></v>
<v t="michael.20060919173151.2"><vh>&lt;&lt; insert "Edit Attributes" menu &gt;&gt;</vh></v>
<v t="michael.20060919173151.3" a="M"><vh>&lt;&lt; insert "Remove Attributes" menu &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="mr7771.20060614124044"><vh>Subclasses</vh>
<v t="mr7771.20060614124044.1"><vh>class CStructureContext</vh>
<v t="michael.20061026113601.1"><vh>Methods</vh>
<v t="michael.20060616163651"><vh>Tool Methods</vh>
<v t="michael.20060616163651.1"><vh>get_object</vh></v>
</v>
<v t="mr7771.20060614124118"><vh>Context Interface</vh>
<v t="michael.20060907105636" a="M"><vh>activate</vh></v>
<v t="mr7771.20060614124301" a="M"><vh>get_main_completion_list</vh></v>
<v t="mr7771.20060614124952"><vh>get_sub_completion_list</vh></v>
<v t="michael.20061114113543"><vh>find_object</vh></v>
</v>
<v t="mr7771.20060614124751"><vh>Methods to Overwrite</vh>
<v t="mr7771.20060614124751.1"><vh>get_default_pseudo</vh></v>
</v>
</v>
<v t="mr7771.20060614124301.1"><vh>Subclasses</vh>
<v t="mr7771.20060609224238.3" a="M"><vh>class CResource</vh>
<v t="michael.20060828221821"><vh>Context Interface</vh>
<v t="michael.20060918132012"><vh>get_last_code_item</vh></v>
<v t="michael.20060828221821.1" a="M"><vh>make_browser_menu</vh></v>
</v>
<v t="michael.20060616144838"><vh>Overwrites (Context)</vh>
<v t="mr7771.20060610004423.1"><vh>can_activate</vh></v>
</v>
<v t="mr7771.20060614134507"><vh>Overwrites (CStructureContext)</vh>
<v t="mr7771.20060614134507.1"><vh>get_default_pseudo</vh></v>
</v>
</v>
<v t="mr7771.20060609223152"><vh>class CTask</vh>
<v t="michael.20060616204036"><vh>Context Interface</vh>
<v t="michael.20060828221643"><vh>make_browser_menu</vh></v>
<v t="michael.20061109163439"><vh>get_main_completion_list</vh>
<v t="michael.20061109173515"><vh>&lt;&lt; add user defined task completions &gt;&gt;</vh></v>
</v>
<v t="michael.20060616204036.1"><vh>get_sub_completion_list</vh></v>
</v>
<v t="michael.20060616144838.1"><vh>Overwrites (Context)</vh>
<v t="mr7771.20060610005033.6"><vh>can_activate</vh></v>
</v>
<v t="mr7771.20060614124751.2"><vh>Overwrites (CStructureContext)</vh>
<v t="michael.20060619232254"><vh>get_object</vh></v>
</v>
</v>
<v t="mr7771.20060609223152.1"><vh>class CProjectDeclaration</vh>
<v t="michael.20060901114003"><vh>Context Interface</vh>
<v t="michael.20060918131942"><vh>get_last_code_item</vh></v>
<v t="michael.20060901114003.1" a="M"><vh>make_browser_menu</vh></v>
</v>
<v t="michael.20060616144838.2"><vh>Overwrites (Context)</vh>
<v t="mr7771.20060610005713.1" a="M"><vh>can_activate</vh></v>
</v>
</v>
<v t="mr7771.20060609224238.5" a="M"><vh>class CObserver</vh>
<v t="michael.20060828221856"><vh>Context Interface</vh>
<v t="michael.20060918130628"><vh>get_last_code_item</vh></v>
<v t="michael.20060828221856.1"><vh>make_browser_menu</vh></v>
</v>
<v t="michael.20060616144838.3"><vh>Overwrites (Context)</vh>
<v t="mr7771.20060614203713.1"><vh>can_activate</vh></v>
</v>
<v t="mr7771.20060614203713"><vh>Overwrites (CStructureContext)</vh>
<v t="michael.20060822215648"><vh>get_editors</vh></v>
<v t="mr7771.20060614203713.2"><vh>get_default_pseudo</vh></v>
</v>
</v>
</v>
</v>
<v t="michael.20060616175302" a="M"><vh>class CObserverFunc</vh>
<v t="michael.20060619164503"><vh>Context Interface</vh>
<v t="michael.20060901205413" a="M"><vh>make_button</vh>
<v t="michael.20060901205826" a="M"><vh>&lt;&lt; get editors &gt;&gt;</vh></v>
</v>
<v t="michael.20060619164503.2" a="M"><vh>find_object</vh>
<v t="michael.20060619192815"><vh>&lt;&lt; define get_observer &gt;&gt;</vh></v>
<v t="michael.20060619193517"><vh>&lt;&lt; get argument description &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060616175302.1"><vh>Overwrites (Context)</vh>
<v t="michael.20060616175302.2"><vh>can_activate</vh></v>
</v>
</v>
<v t="mr7771.20060609223152.2" a="M"><vh>class CImport</vh>
<v t="michael.20060619183441"><vh>Interface</vh>
<v t="michael.20060918132238"><vh>get_last_code_item</vh></v>
<v t="michael.20060828221931"><vh>make_browser_menu</vh></v>
<v t="michael.20060619183441.1"><vh>get_main_completion_list</vh></v>
</v>
<v t="michael.20060616144322"><vh>Overwrites (Context)</vh>
<v t="mr7771.20060609224238.1"><vh>can_activate</vh></v>
</v>
</v>
<v t="mr7771.20060609224238.2"><vh>class CMisc</vh>
<v t="mr7771.20060610005033"><vh>Context Interface</vh>
<v t="mr7771.20060610005033.1"><vh>activate</vh></v>
<v t="michael.20060616212150"><vh>get_main_completion_list</vh></v>
</v>
</v>
<v t="mr7771.20060613111615" a="M"><vh>class CResourceOrTask</vh>
<v t="michael.20060616203047"><vh>Context Interface</vh>
<v t="michael.20060616203047.1" a="M"><vh>get_main_completion_list</vh></v>
</v>
<v t="michael.20060616144322.1"><vh>Overwrites (Context)</vh>
<v t="mr7771.20060613111615.2"><vh>can_activate</vh></v>
</v>
</v>
<v t="mr7771.20060613174236" a="M"><vh>class CTaskOrEvaluation</vh>
<v t="michael.20060616144322.2"><vh>Overwrites (Context)</vh>
<v t="mr7771.20060613174515.1"><vh>can_activate</vh></v>
</v>
</v>
<v t="mr7771.20060609224238.4"><vh>class CEvaluation</vh>
<v t="michael.20060918131528"><vh>Interface</vh>
<v t="michael.20061028120746"><vh>activate</vh></v>
<v t="michael.20060918131528.1"><vh>get_last_code_item</vh></v>
<v t="michael.20060918131528.2"><vh>make_browser_menu</vh></v>
</v>
</v>
<v t="michael.20060616175116"><vh>class CBetweenObservers</vh>
<v t="michael.20060616181548"><vh>Context Interface</vh>
<v t="michael.20060616181548.1" a="M"><vh>get_main_completion_list</vh>
<v t="michael.20060616182813" a="M"><vh>&lt;&lt; get_observers &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060616175207"><vh>Overwrites (Context)</vh>
<v t="michael.20060616175207.1"><vh>can_activate</vh></v>
</v>
</v>
<v t="michael.20060616192508" a="M"><vh>class CBetweenResource</vh>
<v t="michael.20060616202740"><vh>Context Interface</vh>
<v t="michael.20060616202740.1" a="M"><vh>get_main_completion_list</vh></v>
</v>
<v t="michael.20060616192508.1"><vh>Overwrites (Context)</vh>
<v t="michael.20060616192508.2"><vh>can_activate</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="mr7771.20060609154937" tnodeList="mr7771.20060609154937,mr7771.20060609151433,mr7771.20060609154937.1,mr7771.20060609154937.2,mr7771.20060609154937.3,mr7771.20060609154937.4,mr7771.20060609155425,mr7771.20060609165227.2,michael.20060927165817,michael.20060927165817.1,michael.20061119042333,michael.20061018160639,michael.20061018160639.1,michael.20061018160639.2,michael.20061018160639.3,michael.20061018160639.4,mr7771.20060609175617,mr7771.20060609154937.17,mr7771.20060609154937.18,mr7771.20060609154937.19,mr7771.20060609154937.22,michael.20060930032329,michael.20061018180317,michael.20061018180317.1,michael.20061018180317.2,michael.20061018180317.3,mr7771.20060609155616,mr7771.20060609154937.14,mr7771.20060609223152.3,mr7771.20060609223152.4,mr7771.20060609223152.5,mr7771.20060609223152.6,michael.20060919151956,michael.20060921000959,michael.20060921135700,mr7771.20060609154937.5,mr7771.20060609154937.7,mr7771.20060609154937.8,mr7771.20060609154937.11,mr7771.20060609154937.15,mr7771.20060609154937.10,mr7771.20060614145216,mr7771.20060614145216.1,mr7771.20060614150422,mr7771.20060609154937.20,mr7771.20060609154937.23,mr7771.20060609160624,michael.20060927171146,michael.20060919202707,michael.20060912164103,mr7771.20060609154937.12,mr7771.20060609222057,mr7771.20060609222057.1,mr7771.20060609222057.2,mr7771.20060609154937.21"><vh>@file gui/editor/browser.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="mr7771.20060609154937.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="mr7771.20060609154937.2"><vh>class Browser</vh>
<v t="mr7771.20060609154937.3"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="mr7771.20060609154937.4" a="M"><vh>__init__</vh></v>
<v t="mr7771.20060609155425"><vh>wxPython Methods</vh>
<v t="mr7771.20060609165227.2"><vh>get_prev_visible</vh></v>
<v t="michael.20060927165817"><vh>_on_change</vh>
<v t="michael.20060927165817.1" a="M"><vh>&lt;&lt; define internal insert function &gt;&gt;</vh></v>
<v t="michael.20061018160639"><vh>&lt;&lt; remove item &gt;&gt;</vh>
<v t="michael.20061018160639.1"><vh>&lt;&lt; reinsert still existing children under new parent &gt;&gt;</vh></v>
</v>
<v t="michael.20061018160639.2"><vh>&lt;&lt; insert item &gt;&gt;</vh>
<v t="michael.20061018160639.3" a="M"><vh>&lt;&lt; insert children and modify their old parent &gt;&gt;</vh></v>
</v>
<v t="michael.20061018160639.4" a="M"><vh>&lt;&lt; change item &gt;&gt;</vh></v>
<v t="michael.20061119042333"><vh>&lt;&lt; split and sort changed items list &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609175617"><vh>_on_idle</vh></v>
<v t="mr7771.20060609154937.17"><vh>_on_size</vh></v>
<v t="mr7771.20060609154937.18"><vh>_on_refresh</vh></v>
<v t="mr7771.20060609154937.19"><vh>_on_sel_changed</vh></v>
<v t="mr7771.20060609154937.22"><vh>_on_right_click</vh></v>
<v t="michael.20060930032329"><vh>_on_begin_drag</vh>
<v t="michael.20061018180317"><vh>&lt;&lt; define temporary event handlers &gt;&gt;</vh></v>
<v t="michael.20061018180317.1" a="M"><vh>&lt;&lt; check if drag_item is moved to a valid position &gt;&gt;</vh></v>
<v t="michael.20061018180317.2"><vh>&lt;&lt; move drag_item &gt;&gt;</vh></v>
<v t="michael.20061018180317.3" a="M"><vh>&lt;&lt; copy extended CodeItem attributes to new items &gt;&gt;</vh></v>
</v>
</v>
<v t="mr7771.20060609155616"><vh>Internal Tool Methods</vh>
<v t="mr7771.20060609154937.14"><vh>init_tree</vh>
<v t="mr7771.20060609223152.3"><vh>&lt;&lt; Create Columns &gt;&gt;</vh></v>
<v t="mr7771.20060609223152.4"><vh>&lt;&lt; Insert Header Nodes &gt;&gt;</vh></v>
<v t="mr7771.20060609223152.5"><vh>&lt;&lt; Set Header Node Fonts &gt;&gt;</vh></v>
<v t="mr7771.20060609223152.6"><vh>&lt;&lt; Set Header Node Titles &gt;&gt;</vh></v>
</v>
<v t="michael.20060919151956"><vh>create_context_menu</vh></v>
<v t="michael.20060921000959"><vh>append_display_eval_data_menu</vh></v>
<v t="michael.20060921135700" a="M"><vh>get_display_eval_data</vh></v>
<v t="mr7771.20060609154937.5"><vh>get_image_index</vh></v>
<v t="mr7771.20060609154937.7"><vh>set_image</vh></v>
<v t="mr7771.20060609154937.8"><vh>get_item_font</vh></v>
<v t="mr7771.20060609154937.11"><vh>get_section</vh></v>
<v t="mr7771.20060609154937.15"><vh>calc_column_widths</vh></v>
<v t="mr7771.20060609154937.10"><vh>modify_item</vh>
<v t="mr7771.20060614145216"><vh>&lt;&lt; make task &gt;&gt;</vh></v>
<v t="mr7771.20060614145216.1"><vh>&lt;&lt; make resource &gt;&gt;</vh></v>
<v t="mr7771.20060614150422"><vh>&lt;&lt; make observer &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609154937.20"><vh>select_item</vh></v>
<v t="mr7771.20060609154937.23"><vh>move_caret_to_end</vh></v>
</v>
<v t="mr7771.20060609160624"><vh>Public Methods</vh>
<v t="michael.20060927171146"><vh>bind_events</vh></v>
<v t="michael.20060919202707"><vh>on_make_menu</vh></v>
<v t="michael.20060912164103" a="M"><vh>update_menus</vh></v>
<v t="mr7771.20060609154937.12" a="M"><vh>refresh</vh>
<v t="mr7771.20060609222057"><vh>&lt;&lt; Delete children &gt;&gt;</vh></v>
<v t="mr7771.20060609222057.1"><vh>&lt;&lt; Declarations &gt;&gt;</vh></v>
<v t="mr7771.20060609222057.2" a="M"><vh>&lt;&lt; Insert Nodes &gt;&gt;</vh></v>
</v>
<v t="mr7771.20060609154937.21"><vh>update_selection</vh></v>
</v>
</v>
</v>
<v t="michael.20060621134201" tnodeList="michael.20060621134201,mr7771.20060609151433,michael.20060621134201.1,michael.20060621134201.2,michael.20060621134201.3,michael.20060621134201.4,michael.20060621134201.5,michael.20060621134201.6,michael.20060621134201.7,michael.20060621134201.8,michael.20060621134201.9,michael.20060621134201.10,michael.20060621134201.11,michael.20060621134201.12,michael.20060621134220,michael.20060621134201.13,michael.20060621134201.14,michael.20060621134201.15,michael.20060621134201.16,michael.20060621134201.17,michael.20060910154312,michael.20060910154430,michael.20060910160841,michael.20060621134201.18,michael.20060621134201.19,michael.20060621134201.20"><vh>@file gui/editor/docparser.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060621134201.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060621134201.2"><vh>_get_indentdation</vh></v>
<v t="michael.20060621134201.3"><vh>unescape</vh></v>
<v t="michael.20060621134201.4"><vh>class DocParser</vh>
<v t="michael.20060621134201.5"><vh>__init__</vh></v>
<v t="michael.20060621134201.6"><vh>clear</vh></v>
<v t="michael.20060621134201.7"><vh>parse_fields</vh></v>
<v t="michael.20060621134201.8"><vh>parse_methods</vh></v>
<v t="michael.20060621134201.9"><vh>parse_description</vh></v>
</v>
<v t="michael.20060621134201.10"><vh>class DocBase</vh>
<v t="michael.20060621134201.11"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060621134201.12"><vh>argspec</vh></v>
<v t="michael.20060621134220"><vh>get_doc</vh></v>
</v>
<v t="michael.20060621134201.13"><vh>class ClassDoc</vh>
<v t="michael.20060621134201.14"><vh>__init__</vh></v>
<v t="michael.20060621134201.15"><vh>get_doc</vh></v>
<v t="michael.20060621134201.16"><vh>constructor</vh></v>
<v t="michael.20060621134201.17"><vh>parse_methods</vh></v>
</v>
<v t="michael.20060910154312"><vh>class ModuleDoc</vh>
<v t="michael.20060910154430"><vh>__init__</vh></v>
<v t="michael.20060910160841"><vh>constructor</vh></v>
</v>
<v t="michael.20060621134201.18"><vh>class FunctionDoc</vh>
<v t="michael.20060621134201.19"><vh>__init__</vh></v>
<v t="michael.20060621134201.20"><vh>constructor</vh></v>
</v>
</v>
<v t="michael.20060910151243"><vh>Attribute Editing</vh>
<v t="michael.20060726163212" tnodeList="michael.20060726163212,mr7771.20060609151433,michael.20060726163212.1,michael.20060727171134,michael.20060727171740,michael.20060727171307.1,michael.20060728153537,michael.20060728153537.1,michael.20060804141028,michael.20060804165131,michael.20060804180304,michael.20060804180304.1,michael.20060804180304.2,michael.20060726163359,michael.20060727172857,michael.20060727172857.1,michael.20060727172857.2,michael.20060727174639,michael.20060727172857.6,michael.20060727172857.7,michael.20060727172857.8,michael.20060727172857.10,michael.20060727172857.12,michael.20060727172857.13,michael.20060727180105.1,michael.20060726163359.1,michael.20060726163359.2,michael.20060726163359.3,michael.20060726163359.4,michael.20060726163359.5,michael.20060726163359.6,michael.20060726163359.7,michael.20060726163359.8,michael.20060726163359.9,michael.20060726163359.10,michael.20060726164252,michael.20060726164252,michael.20060726163359.11,michael.20060726163359.12,michael.20060727180230,michael.20060727180230.1,michael.20060727180230.2,michael.20060727180230.3,michael.20060727180230.4,michael.20060728142041,michael.20060728142041.1,michael.20060728142041.2,michael.20060728142041.3,michael.20060728142041.4,michael.20060727180601,michael.20060727180601.1,michael.20060727180601.2,michael.20060727180601.3,michael.20060727180601.4,michael.20060726163359.13,michael.20060726163359.14,michael.20060726163359.15,michael.20060726163359.16,michael.20060726163359.17,michael.20060804165454,michael.20060804171822,michael.20060726163359.33,michael.20060726163359.34,michael.20060726163359.35,michael.20060726163359.36,michael.20060726163359.37,michael.20060726163359.38,michael.20060726163359.39,michael.20060726163359.40,michael.20060726163359.41,michael.20060726163359.42,michael.20060726163359.43,michael.20060726163359.44,michael.20060726163359.45,michael.20060726163359.46,michael.20060726163359.47,michael.20060726163359.48,michael.20060726163359.49,michael.20060727133714,michael.20060728153749,michael.20060728153749.1,michael.20060728153749.2,michael.20060728153749.3,michael.20060728153749.4,michael.20060728153749.5,michael.20060728153909,michael.20060804143857,michael.20060804143857.1,michael.20060804160034,michael.20060804160034.1,michael.20060804160034.2,michael.20060804143857.2,michael.20060804143857.3,michael.20060804155401,michael.20060804161145,michael.20060804161145.1,michael.20060804161145.2,michael.20060804161145.3,michael.20061002010322,michael.20061002010322.1,michael.20061002010322.2,michael.20061002010322.3,michael.20061002010322.4,michael.20060804162848,michael.20060804162848.1,michael.20060804162848.2,michael.20060804162848.3,michael.20060804162848.4,michael.20060727171038,michael.20060921012719,michael.20060921013326,michael.20060921012812,michael.20060921012921,michael.20060921013128,michael.20060921013326.1,michael.20060921144959,michael.20060921013326.2,michael.20060921013326.3,michael.20060921013128.1,michael.20061002011136,michael.20060921011201,michael.20060929233107,michael.20060929233300,michael.20060929233300.1,michael.20060929233300.2,michael.20060929233300.3,michael.20060929234312,michael.20060929234312.1,michael.20060929234312.2,michael.20060929234312.3,michael.20060927211426,michael.20060929093536,michael.20060929093536.1,michael.20060929093536.2,michael.20061028111855,michael.20060927211706,michael.20060929085858,michael.20060929093303,michael.20060927190516,michael.20061028114303,michael.20060927192936,michael.20060927192936.1,michael.20060927193132,michael.20060927193132.1,michael.20060927193132.2,michael.20060927193132.3,michael.20060927193132.5,michael.20060927193132.6,michael.20060929093150,michael.20060927205317,michael.20060927190516.1,michael.20060927203751,michael.20060927203751.1,michael.20060927185257,michael.20060927203751.2,michael.20060927203751.3,michael.20060927212238,michael.20060927204924,michael.20060927204614,michael.20060927211820,michael.20060929085928,michael.20060927211820.1,michael.20060927204614.1,michael.20060929224036,michael.20061028114303,michael.20060929225058,michael.20060929225128,michael.20060929231203,michael.20060929225233,michael.20060929231103,michael.20060929231329,michael.20061028111855,michael.20060929231415,michael.20060929231534,michael.20060929093303,michael.20060929230703,michael.20060929230703.1,michael.20060929230703.2,michael.20060929230703.3,michael.20060930115815,michael.20060930115917,michael.20060930115917.1,michael.20060930115917.2,michael.20060930115917.3,michael.20060930120528,michael.20060930120528.1,michael.20060930120528.2,michael.20060930120528.3,michael.20060930120528.4,michael.20060921225322,michael.20060921225442,michael.20060921225442.1,michael.20060921225442.2,michael.20060921225442.3,michael.20060921225442.4,michael.20060921225700,michael.20060921230629,michael.20060921230629.1,michael.20060921230629.2,michael.20060921230629.3,michael.20061031175127,michael.20060727171438,michael.20060727171438.1,michael.20060727171438.2,michael.20060907133950,michael.20060727171438.3,michael.20060927174723"><vh>@file gui/editor/attribedit.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060726163212.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060727171134"><vh>Token definitions</vh></v>
<v t="michael.20060727171740" a="M"><vh>get_code_root</vh></v>
<v t="michael.20060727171307.1" a="M"><vh>class Evaluator</vh></v>
<v t="michael.20060728153537"><vh>Types</vh>
<v t="michael.20060728153537.1"><vh>class ResourceNames</vh></v>
<v t="michael.20060804141028"><vh>class EvaluationNames</vh></v>
</v>
<v t="michael.20060804165131"><vh>Widgets</vh>
<v t="michael.20060804180304"><vh>class SymbolCombo</vh></v>
<v t="michael.20060804180304.1"><vh>class ShapeCombo</vh></v>
<v t="michael.20060804180304.2"><vh>class BoolEnum</vh></v>
</v>
<v t="michael.20060726163359"><vh>Models and Views</vh>
<v t="michael.20060727172857"><vh>SimpleContainer</vh>
<v t="michael.20060727172857.1"><vh>class SimpleContainer</vh>
<v t="michael.20060727172857.2"><vh>__init__</vh>
<v t="michael.20060727174639" a="M"><vh>&lt;&lt; calculate attribute value &gt;&gt;</vh></v>
</v>
<v t="michael.20060727172857.6" a="M"><vh>show</vh></v>
<v t="michael.20060727172857.7"><vh>code</vh></v>
<v t="michael.20060727172857.8"><vh>realize</vh></v>
</v>
<v t="michael.20060727172857.10" a="M"><vh>class SimpleView</vh>
<v t="michael.20060727172857.12"><vh>prepare</vh></v>
<v t="michael.20060727172857.13"><vh>constitute</vh></v>
</v>
</v>
<v t="michael.20060727180105.1"><vh>Values</vh>
<v t="michael.20060726163359.1"><vh>Delta</vh>
<v t="michael.20060726163359.2" a="M"><vh>class Delta</vh>
<v t="michael.20060726163359.3" a="M"><vh>__init__</vh>
<v t="michael.20060726163359.4"><vh>&lt;&lt; find best value &gt;&gt;</vh></v>
</v>
<v t="michael.20060726163359.5"><vh>__str__</vh></v>
</v>
<v t="michael.20060726163359.6"><vh>class Duration</vh></v>
<v t="michael.20060726163359.7" a="M"><vh>class DeltaView</vh></v>
</v>
<v t="michael.20060726163359.8"><vh>Date</vh>
<v t="michael.20060726163359.9" a="M"><vh>class Date</vh>
<v t="michael.20060726163359.10" a="M"><vh>__init__</vh>
<v t="michael.20060726164252"><vh>&lt;&lt; try alternatives &gt;&gt;</vh></v>
</v>
<v t="michael.20060726163359.11" a="M"><vh>__str__</vh></v>
</v>
<v t="michael.20060726163359.12"><vh>class DateView</vh></v>
</v>
<v t="michael.20060727180230"><vh>Float</vh>
<v t="michael.20060727180230.1" a="M"><vh>class Float</vh>
<v t="michael.20060727180230.2"><vh>__init__</vh></v>
<v t="michael.20060727180230.3" a="M"><vh>__str__</vh></v>
</v>
<v t="michael.20060727180230.4"><vh>class FloatView</vh></v>
</v>
<v t="michael.20060728142041"><vh>Int</vh>
<v t="michael.20060728142041.1" a="M"><vh>class Int</vh>
<v t="michael.20060728142041.2"><vh>__init__</vh></v>
<v t="michael.20060728142041.3" a="M"><vh>__str__</vh></v>
</v>
<v t="michael.20060728142041.4"><vh>class IntView</vh></v>
</v>
<v t="michael.20060727180601"><vh>Boolean</vh>
<v t="michael.20060727180601.1" a="M"><vh>class Boolean</vh>
<v t="michael.20060727180601.2"><vh>__init__</vh></v>
<v t="michael.20060727180601.3" a="M"><vh>__str__</vh></v>
</v>
<v t="michael.20060727180601.4" a="M"><vh>class BooleanView</vh></v>
</v>
<v t="michael.20060726163359.13"><vh>String</vh>
<v t="michael.20060726163359.14" a="M"><vh>class String</vh>
<v t="michael.20060726163359.15"><vh>__init__</vh></v>
<v t="michael.20060726163359.16" a="M"><vh>__str__</vh></v>
</v>
<v t="michael.20060726163359.17"><vh>class StringView</vh></v>
</v>
<v t="michael.20060804165454"><vh>Symbol</vh></v>
<v t="michael.20060804171822"><vh>Shape</vh></v>
<v t="michael.20060726163359.33"><vh>MultiText</vh>
<v t="michael.20060726163359.34" a="M"><vh>class MultiText</vh>
<v t="michael.20060726163359.35"><vh>__init__</vh></v>
<v t="michael.20060726163359.36"><vh>__str__</vh></v>
</v>
<v t="michael.20060726163359.37" a="M"><vh>class MultiTextView</vh>
<v t="michael.20060726163359.38"><vh>prepare</vh></v>
</v>
</v>
<v t="michael.20060726163359.39"><vh>DateTimeRanges</vh>
<v t="michael.20060726163359.40"><vh>class DateTimeRange</vh>
<v t="michael.20060726163359.41"><vh>__init__</vh></v>
<v t="michael.20060726163359.42"><vh>_set_start</vh></v>
<v t="michael.20060726163359.43"><vh>__str__</vh></v>
</v>
<v t="michael.20060726163359.44" a="M"><vh>class DateTimeRanges</vh>
<v t="michael.20060726163359.45"><vh>__init__</vh></v>
<v t="michael.20060726163359.46"><vh>__str__</vh></v>
</v>
<v t="michael.20060726163359.47" a="M"><vh>class TimeRangesView</vh>
<v t="michael.20060726163359.48"><vh>create_controls</vh></v>
<v t="michael.20060726163359.49"><vh>prepare</vh></v>
</v>
</v>
<v t="michael.20060727133714"><vh>WorkingTimes</vh>
<v t="michael.20060728153749" a="M"><vh>WorkingTime</vh></v>
<v t="michael.20060728153749.1" a="M"><vh>WorkingTimes</vh>
<v t="michael.20060728153749.2" a="M"><vh>__init__</vh></v>
<v t="michael.20060728153749.3"><vh>__str__</vh></v>
</v>
<v t="michael.20060728153749.4" a="M"><vh>WorkingTimesView</vh></v>
<v t="michael.20060728153749.5"><vh>WorkingTimeGrid</vh></v>
</v>
<v t="michael.20060728153909"><vh>Resources</vh>
<v t="michael.20060804143857" a="M"><vh>class Resource</vh></v>
<v t="michael.20060804143857.1" a="M"><vh>class ResourceSet</vh>
<v t="michael.20060804160034" a="M"><vh>__init__</vh></v>
<v t="michael.20060804160034.1"><vh>__str__</vh></v>
<v t="michael.20060804160034.2" a="M"><vh>check_constraints</vh></v>
</v>
<v t="michael.20060804143857.2" a="M"><vh>class ResourceSetView</vh></v>
<v t="michael.20060804143857.3"><vh>class ResourceGrid</vh></v>
</v>
<v t="michael.20060804155401"><vh>ColorSet</vh>
<v t="michael.20060804161145"><vh>class Color</vh></v>
<v t="michael.20060804161145.1"><vh>class ColorGrid</vh></v>
<v t="michael.20060804161145.2"><vh>class ColorSet</vh></v>
<v t="michael.20060804161145.3" a="M"><vh>class ColorSetView</vh></v>
</v>
<v t="michael.20061002010322"><vh>TwoColorSet</vh>
<v t="michael.20061002010322.1"><vh>class TwoColor</vh></v>
<v t="michael.20061002010322.2"><vh>class TwoColorGrid</vh></v>
<v t="michael.20061002010322.3"><vh>class TwoColorSet</vh></v>
<v t="michael.20061002010322.4" a="M"><vh>class ColorSetView</vh></v>
</v>
<v t="michael.20060804162848"><vh>ColorMap</vh>
<v t="michael.20060804162848.1"><vh>class ColorLimit</vh></v>
<v t="michael.20060804162848.2"><vh>class ColorLimitGrid</vh></v>
<v t="michael.20060804162848.3"><vh>class ColorMap</vh></v>
<v t="michael.20060804162848.4" a="M"><vh>class ColorMapView</vh></v>
</v>
</v>
</v>
<v t="michael.20060727171038"><vh>Editors</vh>
<v t="michael.20060921012719" a="M"><vh>SingletonEditor</vh>
<v t="michael.20060921013326"><vh>Editor Interface</vh>
<v t="michael.20060921012812"><vh>apply</vh></v>
<v t="michael.20060921012921"><vh>apply_browser_menu</vh></v>
<v t="michael.20060921013128" a="M"><vh>activate</vh></v>
</v>
<v t="michael.20060921013326.1"><vh>Internals</vh>
<v t="michael.20060921144959"><vh>realize</vh></v>
<v t="michael.20060921013326.2"><vh>cancel</vh></v>
</v>
<v t="michael.20060921013326.3"><vh>Overwrites</vh>
<v t="michael.20060921013128.1"><vh>init_attributes</vh></v>
<v t="michael.20061002011136"><vh>realize_code</vh></v>
</v>
</v>
<v t="michael.20060921011201"><vh>Evaluation Editors</vh>
<v t="michael.20060929233107" a="M"><vh>print_evaluation_references</vh></v>
<v t="michael.20060929233300"><vh>class EvaluationReferencePrinter</vh>
<v t="michael.20060929233300.1"><vh>apply</vh></v>
<v t="michael.20060929233300.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060929233300.3"><vh>activate</vh></v>
</v>
<v t="michael.20060929234312" a="M"><vh>class EvaluationRemover</vh>
<v t="michael.20060929234312.1"><vh>apply</vh></v>
<v t="michael.20060929234312.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060929234312.3" a="M"><vh>activate</vh></v>
</v>
<v t="michael.20060927211426"><vh>class ProjectEditorMixin</vh>
<v t="michael.20060929093536"><vh>Attribute Manipulation</vh>
<v t="michael.20060929093536.1"><vh>_set_project</vh></v>
<v t="michael.20060929093536.2"><vh>_set_scenario</vh></v>
</v>
<v t="michael.20061028111855"><vh>apply</vh></v>
<v t="michael.20060927211706"><vh>apply_browser_menu</vh></v>
<v t="michael.20060929085858"><vh>init_attributes</vh></v>
<v t="michael.20060929093303"><vh>realize_code</vh></v>
</v>
<v t="michael.20060927190516"><vh>class ProjectCreator</vh>
<v t="michael.20061028114303"><vh>apply</vh></v>
<v t="michael.20060927192936"><vh>apply_browser_menu</vh></v>
<v t="michael.20060927192936.1"><vh>init_attributes</vh></v>
<v t="michael.20060927193132"><vh>Attribute Manipulation</vh>
<v t="michael.20060927193132.1"><vh>_construct_name</vh></v>
<v t="michael.20060927193132.2"><vh>_set_project</vh></v>
<v t="michael.20060927193132.3" a="M"><vh>_set_scenario</vh></v>
</v>
<v t="michael.20060927193132.5"><vh>check_constraints</vh></v>
<v t="michael.20060927193132.6"><vh>realize_code</vh></v>
<v t="michael.20060929093150"><vh>__str__</vh></v>
</v>
<v t="michael.20060927205317" a="M"><vh>class ProjectEditor</vh></v>
<v t="michael.20060927190516.1" a="M"><vh>class ProjectView</vh>
<v t="michael.20060927203751"><vh>prepare</vh></v>
<v t="michael.20060927203751.1" a="M"><vh>constitute</vh>
<v t="michael.20060927185257" a="M"><vh>&lt;&lt; fill project combo &gt;&gt;</vh></v>
</v>
<v t="michael.20060927203751.2"><vh>state_changed</vh></v>
</v>
<v t="michael.20060927203751.3" a="M"><vh>class BalancedProjectCreator</vh>
<v t="michael.20060927212238"><vh>init_attributes</vh></v>
<v t="michael.20060927204924"><vh>__str__</vh></v>
<v t="michael.20060927204614" a="M"><vh>check_constraints</vh></v>
</v>
<v t="michael.20060927211820"><vh>class BalancedProjectEditor</vh>
<v t="michael.20060929085928"><vh>apply_browser_menu</vh></v>
<v t="michael.20060927211820.1"><vh>init_attributes</vh></v>
</v>
<v t="michael.20060927204614.1"><vh>class BalancedProjectView</vh></v>
<v t="michael.20060929224036"><vh>class AdjustedProjectCreator</vh>
<v t="michael.20061028114303"><vh>apply</vh></v>
<v t="michael.20060929225058"><vh>apply_browser_menu</vh></v>
<v t="michael.20060929225128"><vh>init_attributes</vh></v>
<v t="michael.20060929231203"><vh>check_constraints</vh></v>
<v t="michael.20060929225233"><vh>realize_code</vh></v>
<v t="michael.20060929231103"><vh>__str__</vh></v>
</v>
<v t="michael.20060929231329"><vh>class AdjustedProjectEditor</vh>
<v t="michael.20061028111855"><vh>apply</vh></v>
<v t="michael.20060929231415"><vh>apply_browser_menu</vh></v>
<v t="michael.20060929231534"><vh>init_attributes</vh></v>
<v t="michael.20060929093303"><vh>realize_code</vh></v>
</v>
<v t="michael.20060929230703" a="M"><vh>class AdjustedProjectView</vh>
<v t="michael.20060929230703.1"><vh>prepare</vh></v>
<v t="michael.20060929230703.2"><vh>constitute</vh>
<v t="michael.20060929230703.3" a="M"><vh>&lt;&lt; fill base combo &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="michael.20060930115815"><vh>Import Editors</vh>
<v t="michael.20060930115917"><vh>class ImportRemover</vh>
<v t="michael.20060930115917.1"><vh>apply</vh></v>
<v t="michael.20060930115917.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060930115917.3" a="M"><vh>activate</vh></v>
</v>
<v t="michael.20060930120528"><vh>class ImportCreator</vh>
<v t="michael.20060930120528.1"><vh>__init__</vh></v>
<v t="michael.20060930120528.2"><vh>apply</vh></v>
<v t="michael.20060930120528.3"><vh>apply_browser_menu</vh></v>
<v t="michael.20060930120528.4"><vh>activate</vh></v>
</v>
</v>
<v t="michael.20060921225322"><vh>NameEditor</vh>
<v t="michael.20060921225442"><vh>class NameEditor</vh>
<v t="michael.20060921225442.1"><vh>apply_browser_menu</vh></v>
<v t="michael.20060921225442.2"><vh>init_attributes</vh></v>
<v t="michael.20060921225442.3"><vh>check_constraints</vh></v>
<v t="michael.20060921225442.4"><vh>realize_code</vh></v>
</v>
<v t="michael.20060921225700" a="M"><vh>class NameEditorView</vh></v>
</v>
<v t="michael.20060921230629"><vh>class RenameEditor</vh>
<v t="michael.20060921230629.1"><vh>apply_browser_menu</vh></v>
<v t="michael.20060921230629.2"><vh>init_attributes</vh></v>
<v t="michael.20060921230629.3"><vh>realize_code</vh></v>
<v t="michael.20061031175127"><vh>correct_code</vh></v>
</v>
<v t="michael.20060727171438" a="M"><vh>class AttributeEditor</vh>
<v t="michael.20060727171438.1"><vh>__init__</vh></v>
<v t="michael.20060727171438.2"><vh>apply</vh></v>
<v t="michael.20060907133950" a="M"><vh>apply_browser_menu</vh></v>
<v t="michael.20060727171438.3" a="M"><vh>activate</vh></v>
</v>
</v>
<v t="michael.20060927174723"><vh>Assign Editors</vh></v>
</v>
<v t="michael.20060622093346" tnodeList="michael.20060622093346,mr7771.20060609151433,michael.20060622093402,michael.20060623163022,michael.20060626130414,michael.20060627153216,michael.20060626130823,michael.20060626130019,michael.20060627153941,michael.20060627153941.1,michael.20060622234836,michael.20060727171523,michael.20060727171523.1,michael.20060727171523.2,michael.20060727174639,michael.20060727171523.5,michael.20060817140817,michael.20060727171523.6,michael.20060727171523.7,michael.20060727171523.8,michael.20060727171523.10,michael.20060727171523.11,michael.20060817145008,michael.20060817142344,michael.20060727171523.12,michael.20060727171523.13,michael.20060817144005,michael.20060817115302,michael.20060817145008.1,michael.20060817145008.2,michael.20060817145008.3,michael.20060817145030,michael.20060817115302.1,michael.20060817115418,michael.20060727171523.14,michael.20060901190834,michael.20060901190851,michael.20060901190952,michael.20060627100623,michael.20060627124836,michael.20060627125439,michael.20060915191847,michael.20060627172634,michael.20060627172805,michael.20060627172805.1,michael.20060628221722,michael.20060627125048,michael.20060627150618,michael.20060627150618.1,michael.20060627150618.2,michael.20060627124836.1,michael.20060628221746,michael.20060628221243,michael.20060627125048.1,michael.20060623001958.7,michael.20060727171038.1,michael.20060727171038.4,michael.20060923161713,michael.20060923162103,michael.20060923162103.1,michael.20060923162103.2,michael.20060923162103.3,michael.20060923140956,michael.20060923140956.1,michael.20060923140956.2,michael.20060923140956.3,michael.20060918124853,michael.20060918124853.1,michael.20060918124853.2,michael.20060918124853.3,michael.20060915234005,michael.20060915234005.1,michael.20060915234005.2,michael.20060915234005.3,michael.20060921012719.1,michael.20060913132734,michael.20060921230035,michael.20060914103351,michael.20060914103204.1,michael.20060913152318.2,michael.20060914103204.2,michael.20060914103403,michael.20060914104037,michael.20060914104037.1,michael.20061026114634,michael.20061026124000,michael.20061026114839,michael.20061026125228,michael.20060929093303,michael.20061026130909,michael.20060622093827,michael.20060727174303,michael.20060622095823"><vh>@file gui/editor/task.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060622093402"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060623163022"><vh>ExpressionEvaluator</vh>
<v t="michael.20060626130414"><vh>class PathWrapper</vh></v>
<v t="michael.20060627153216" a="M"><vh>class AttributeWrapper</vh></v>
<v t="michael.20060626130823"><vh>class ValueWrapper</vh></v>
<v t="michael.20060626130019"><vh>class TaskEvaluator</vh>
<v t="michael.20060627153941"><vh>&lt;&lt; define path variables &gt;&gt;</vh></v>
<v t="michael.20060627153941.1" a="M"><vh>&lt;&lt; define wmax and wmin &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060622234836"><vh>Models and Views</vh>
<v t="michael.20060727171523"><vh>ScenarioContainer</vh>
<v t="michael.20060727171523.1"><vh>class ScenarioContainer</vh>
<v t="michael.20060727171523.2"><vh>__init__</vh>
<v t="michael.20060727174639" a="M"><vh>&lt;&lt; calculate attribute value &gt;&gt;</vh></v>
</v>
<v t="michael.20060727171523.5" a="M"><vh>remove_scenario</vh></v>
<v t="michael.20060817140817"><vh>add_scenario</vh></v>
<v t="michael.20060727171523.6" a="M"><vh>show</vh></v>
<v t="michael.20060727171523.7" a="M"><vh>code</vh></v>
<v t="michael.20060727171523.8"><vh>realize</vh></v>
</v>
<v t="michael.20060727171523.10" a="M"><vh>class ScenarioView</vh>
<v t="michael.20060727171523.11" a="M"><vh>create_controls</vh></v>
<v t="michael.20060817145008"><vh>remove_scenario</vh></v>
<v t="michael.20060817142344"><vh>add_scenario</vh></v>
<v t="michael.20060727171523.12" a="M"><vh>prepare</vh></v>
<v t="michael.20060727171523.13"><vh>constitute</vh></v>
<v t="michael.20060817144005" a="M"><vh>modify_subview</vh></v>
</v>
<v t="michael.20060817115302" a="M"><vh>class NewScenario</vh>
<v t="michael.20060817145008.1"><vh>__init__</vh></v>
<v t="michael.20060817145008.2" a="M"><vh>get_scenarios</vh></v>
<v t="michael.20060817145008.3"><vh>show</vh></v>
<v t="michael.20060817145030"><vh>realize</vh></v>
</v>
<v t="michael.20060817115302.1" a="M"><vh>class NewScenarioView</vh>
<v t="michael.20060817115418"><vh>constitute</vh></v>
<v t="michael.20060727171523.14"><vh>update_scenarios</vh></v>
</v>
</v>
<v t="michael.20060901190834"><vh>Balance</vh>
<v t="michael.20060901190851"><vh>__init__</vh></v>
<v t="michael.20060901190952" a="M"><vh>__str__</vh></v>
</v>
<v t="michael.20060627100623"><vh>RefDate</vh>
<v t="michael.20060627124836" a="M"><vh>class RefDate</vh>
<v t="michael.20060627125439"><vh>__init__</vh>
<v t="michael.20060915191847" a="M"><vh>&lt;&lt; define path_argument &gt;&gt;</vh></v>
<v t="michael.20060627172634" a="M"><vh>&lt;&lt; add predecessor with lag &gt;&gt;</vh></v>
<v t="michael.20060627172805"><vh>&lt;&lt; add predecessor without lag &gt;&gt;</vh></v>
<v t="michael.20060627172805.1"><vh>&lt;&lt; set fixed date &gt;&gt;</vh></v>
</v>
<v t="michael.20060628221722" a="M"><vh>__str__</vh></v>
</v>
<v t="michael.20060627125048" a="M"><vh>class RefDateView</vh>
<v t="michael.20060627150618"><vh>create_controls</vh></v>
<v t="michael.20060627150618.1"><vh>prepare</vh></v>
<v t="michael.20060627150618.2"><vh>constitute</vh></v>
</v>
<v t="michael.20060627124836.1" a="M"><vh>class Predecessor</vh>
<v t="michael.20060628221746" a="M"><vh>to_string</vh></v>
<v t="michael.20060628221243" a="M"><vh>check_constraints</vh></v>
</v>
<v t="michael.20060627125048.1"><vh>class PredecessorGrid</vh></v>
</v>
</v>
<v t="michael.20060623001958.7"><vh>Editors</vh>
<v t="michael.20060727171038.1"><vh>class ScenarioAttributeEditor</vh>
<v t="michael.20060727171038.4"><vh>activate</vh></v>
</v>
<v t="michael.20060923161713" a="M"><vh>print_task_references</vh></v>
<v t="michael.20060923162103"><vh>class TaskRemover</vh>
<v t="michael.20060923162103.1"><vh>apply</vh></v>
<v t="michael.20060923162103.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060923162103.3" a="M"><vh>activate</vh></v>
</v>
<v t="michael.20060923140956"><vh>class TaskReferencePrinter</vh>
<v t="michael.20060923140956.1"><vh>apply</vh></v>
<v t="michael.20060923140956.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060923140956.3"><vh>activate</vh></v>
</v>
<v t="michael.20060918124853"><vh>class TaskIndenter</vh>
<v t="michael.20060918124853.1"><vh>apply</vh></v>
<v t="michael.20060918124853.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060918124853.3" a="M"><vh>activate</vh></v>
</v>
<v t="michael.20060915234005"><vh>class TaskUnindenter</vh>
<v t="michael.20060915234005.1"><vh>apply</vh></v>
<v t="michael.20060915234005.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060915234005.3" a="M"><vh>activate</vh></v>
</v>
<v t="michael.20060921012719.1" a="M"><vh>class TaskRenamer</vh></v>
<v t="michael.20060913132734"><vh>class TaskCreator</vh>
<v t="michael.20060921230035"><vh>apply_browser_menu</vh></v>
<v t="michael.20060914103351"><vh>realize_code</vh></v>
</v>
<v t="michael.20060914103204.1"><vh>class SubTaskCreator</vh>
<v t="michael.20060913152318.2"><vh>insert_code</vh></v>
</v>
<v t="michael.20060914103204.2"><vh>class TaskSiblingCreator</vh>
<v t="michael.20060914103403"><vh>insert_code</vh></v>
</v>
<v t="michael.20060914104037"><vh>class TaskSiblingBeforeCreator</vh>
<v t="michael.20060914104037.1"><vh>insert_code</vh></v>
</v>
<v t="michael.20061026114634" a="M"><vh>class ProjectTaskCreator</vh>
<v t="michael.20061026124000"><vh>realize_code</vh></v>
<v t="michael.20061026114839"><vh>apply_browser_menu</vh></v>
</v>
<v t="michael.20061026125228"><vh>class ProjectTaskRenamer</vh>
<v t="michael.20060929093303"><vh>realize_code</vh></v>
<v t="michael.20061026130909"><vh>__str__</vh></v>
</v>
<v t="michael.20060622093827"><vh>class ScenarioAttributeEditor</vh></v>
<v t="michael.20060727174303"><vh>class AttributeEditor</vh></v>
</v>
<v t="michael.20060622095823"><vh>Assign Editors</vh></v>
</v>
<v t="michael.20060804041654" tnodeList="michael.20060804041654,mr7771.20060609151433,michael.20060804041905,michael.20060918134452,michael.20060923160547,michael.20060923160547.1,michael.20060923160547.2,michael.20060923160547.3,michael.20060923160547.4,michael.20060923134450,michael.20060923134450.1,michael.20060923134450.2,michael.20060923134450.3,michael.20060918135024,michael.20060918135024.5,michael.20060921144552.1,michael.20060804041820"><vh>@file gui/editor/resource.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060804041905"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060918134452"><vh>Editors</vh>
<v t="michael.20060923160547" a="M"><vh>print_resource_references</vh></v>
<v t="michael.20060923160547.1"><vh>class ResourceRemover</vh>
<v t="michael.20060923160547.2"><vh>apply</vh></v>
<v t="michael.20060923160547.3"><vh>apply_browser_menu</vh></v>
<v t="michael.20060923160547.4" a="M"><vh>activate</vh></v>
</v>
<v t="michael.20060923134450" a="M"><vh>class ReferencePrinter</vh>
<v t="michael.20060923134450.1"><vh>apply</vh></v>
<v t="michael.20060923134450.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20060923134450.3"><vh>activate</vh></v>
</v>
<v t="michael.20060918135024"><vh>class ResourceCreator</vh>
<v t="michael.20060918135024.5"><vh>realize_code</vh></v>
</v>
<v t="michael.20060921144552.1"><vh>class ResourceRenamer</vh></v>
</v>
<v t="michael.20060804041820"><vh>Assign Editors</vh></v>
</v>
<v t="michael.20060804044438" tnodeList="michael.20060804044438,michael.20060804044438.1,michael.20060804044438.2,michael.20060804151253,michael.20060804140428,michael.20060804180304.3,michael.20060804183602,michael.20060804183602.1,michael.20060804183602.2,michael.20060804183602.3,michael.20060804183602.4,michael.20060804183602.5,michael.20060804183602.6,michael.20060804183602.7,michael.20060804183602.8,michael.20060804183602.9,michael.20060821122847,michael.20060909120029,michael.20060909120029.1,michael.20060804145158,michael.20060804140428.12,michael.20060804145710,michael.20060804140428.13,michael.20060804145403,michael.20060804140428.15,michael.20060804140428.1,michael.20060804140428.2,michael.20060804140428.3,michael.20060804140428.7,michael.20061002015044,michael.20060804140428.8,michael.20060804140428.9,michael.20060804140428.10,michael.20060902013502,michael.20060906020656,michael.20060906020656.1,michael.20060906020656.2,michael.20060906020907,michael.20060906005234,michael.20060906020338,michael.20060906020338.1,michael.20060906020338.2,michael.20060906182627,michael.20060910220708,michael.20060906020656.3,michael.20060906020656.4,michael.20060804044506,michael.20060804044506.1,michael.20060901201827,michael.20060804172453,michael.20060821191020,michael.20060804172453.3,michael.20060901200906,michael.20060901202023,michael.20060901201020,michael.20060901201924,michael.20060907134327,michael.20060921230339,michael.20061002022123,michael.20061002022123.1,michael.20061002022123.2,michael.20061002022123.3,michael.20061002020357,michael.20060930134539,michael.20061002020357.1,michael.20061002020357.2,michael.20061002020357.3,michael.20061002020357.4,michael.20061002020357.5,michael.20061002020357.6,michael.20061002020357.7,michael.20061002020357.8,michael.20061002020357.9,michael.20061002020357.10,michael.20061002020357.11,michael.20061002020357.12,michael.20061002020357.13,michael.20061002020357.14,michael.20061002020357.15,michael.20061002020357.16,michael.20061002020357.17,michael.20060804120410,michael.20060921225151,michael.20060821115933"><vh>@file gui/editor/observer.py</vh>
<v t="michael.20060804044438.1"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060804044438.2"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060804151253"><vh>class ObserverEvaluator</vh></v>
<v t="michael.20060804140428"><vh>Models and Views</vh>
<v t="michael.20060804180304.3"><vh>Property</vh>
<v t="michael.20060804183602"><vh>Widgets</vh>
<v t="michael.20060804183602.1"><vh>class BoolEnum</vh></v>
<v t="michael.20060804183602.2"><vh>class FamilyCombo</vh></v>
<v t="michael.20060804183602.3"><vh>class WeightCombo</vh></v>
<v t="michael.20060804183602.4"><vh>class SizeCombo</vh></v>
<v t="michael.20060804183602.5"><vh>class VariantEnum</vh></v>
<v t="michael.20060804183602.6"><vh>class LinestyleEnum</vh></v>
<v t="michael.20060804183602.7"><vh>class JoinstyleEnum</vh></v>
<v t="michael.20060804183602.8"><vh>class StyleEnum</vh></v>
</v>
<v t="michael.20060804183602.9"><vh>class Property</vh></v>
<v t="michael.20060821122847"><vh>class PropertySet</vh></v>
<v t="michael.20060909120029"><vh>class PropertySetView</vh></v>
<v t="michael.20060909120029.1"><vh>class PropertyGrid</vh></v>
</v>
<v t="michael.20060804145158"><vh>Evaluation</vh>
<v t="michael.20060804140428.12"><vh>class Evaluation</vh>
<v t="michael.20060804145710"><vh>__init__</vh></v>
<v t="michael.20060804140428.13"><vh>__str__</vh></v>
</v>
<v t="michael.20060804145403"><vh>class EvaluationView</vh></v>
<v t="michael.20060804140428.15"><vh>class EvaluationGrid</vh></v>
</v>
<v t="michael.20060804140428.1"><vh>MultiEvaluation</vh>
<v t="michael.20060804140428.2"><vh>class MultiEvaluation</vh>
<v t="michael.20060804140428.3"><vh>__init__</vh></v>
<v t="michael.20060804140428.7"><vh>__str__</vh></v>
<v t="michael.20061002015044"><vh>check_constraints</vh></v>
</v>
<v t="michael.20060804140428.8"><vh>class MultiEvaluationView</vh>
<v t="michael.20060804140428.9"><vh>create_controls</vh></v>
<v t="michael.20060804140428.10"><vh>prepare</vh></v>
</v>
</v>
<v t="michael.20060902013502"><vh>Column</vh>
<v t="michael.20060906020656"><vh>class Column</vh></v>
<v t="michael.20060906020656.1"><vh>class ColumnSet</vh>
<v t="michael.20060906020656.2"><vh>__init__</vh>
<v t="michael.20060906020907"><vh>&lt;&lt; get the data attribute value &gt;&gt;</vh></v>
<v t="michael.20060906005234"><vh>&lt;&lt; create the choice list for column values &gt;&gt;</vh></v>
<v t="michael.20060906020338"><vh>&lt;&lt; get the code_item, that creates the columns &gt;&gt;</vh></v>
<v t="michael.20060906020338.1"><vh>&lt;&lt; get column values &gt;&gt;</vh></v>
<v t="michael.20060906020338.2"><vh>&lt;&lt; get column headers &gt;&gt;</vh></v>
</v>
<v t="michael.20060906182627"><vh>realize</vh></v>
<v t="michael.20060910220708"><vh>get_object_attribs</vh></v>
</v>
<v t="michael.20060906020656.3"><vh>class ColumnSetView</vh></v>
<v t="michael.20060906020656.4"><vh>class ColumnGrid</vh></v>
</v>
</v>
<v t="michael.20060804044506"><vh>Editors</vh>
<v t="michael.20060804044506.1"><vh>class AttributeEditor</vh>
<v t="michael.20060901201827"><vh>apply</vh></v>
</v>
<v t="michael.20060804172453"><vh>class PropertyEditor</vh>
<v t="michael.20060821191020"><vh>__init__</vh></v>
<v t="michael.20060804172453.3"><vh>activate</vh></v>
</v>
<v t="michael.20060901200906"><vh>class ColumnEditor</vh>
<v t="michael.20060901202023"><vh>__init__</vh></v>
<v t="michael.20060901201020"><vh>apply</vh></v>
<v t="michael.20060901201924"><vh>activate</vh></v>
<v t="michael.20060907134327"><vh>apply_browser_menu</vh></v>
</v>
<v t="michael.20060921230339"><vh>class ObserverRenamer</vh></v>
<v t="michael.20061002022123"><vh>class ObserverRemover</vh>
<v t="michael.20061002022123.1"><vh>apply</vh></v>
<v t="michael.20061002022123.2"><vh>apply_browser_menu</vh></v>
<v t="michael.20061002022123.3"><vh>activate</vh></v>
</v>
<v t="michael.20061002020357"><vh>ObserverCreator</vh>
<v t="michael.20060930134539"><vh>class ObserverCreator</vh>
<v t="michael.20061002020357.1"><vh>apply_browser_menu</vh></v>
<v t="michael.20061002020357.2"><vh>init_attributes</vh></v>
<v t="michael.20061002020357.3"><vh>realize_code</vh></v>
<v t="michael.20061002020357.4"><vh>check_constraints</vh></v>
<v t="michael.20061002020357.5"><vh>set_observer</vh></v>
</v>
<v t="michael.20061002020357.6"><vh>class ObserverCreatorView</vh>
<v t="michael.20061002020357.7"><vh>create_controls</vh></v>
<v t="michael.20061002020357.8"><vh>prepare</vh></v>
<v t="michael.20061002020357.9"><vh>constitute</vh>
<v t="michael.20061002020357.10"><vh>&lt;&lt; fill observer list &gt;&gt;</vh>
<v t="michael.20061002020357.11"><vh>&lt;&lt; find observers &gt;&gt;</vh>
<v t="michael.20061002020357.12"><vh>&lt;&lt; filter out non valid modules &gt;&gt;</vh></v>
<v t="michael.20061002020357.13"><vh>&lt;&lt; get public attribs of module &gt;&gt;</vh></v>
<v t="michael.20061002020357.14"><vh>&lt;&lt; add observer image in img_list &gt;&gt;</vh></v>
</v>
<v t="michael.20061002020357.15"><vh>&lt;&lt; fill list control &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20061002020357.16"><vh>state_changed</vh></v>
<v t="michael.20061002020357.17"><vh>_on_select_item</vh></v>
</v>
</v>
</v>
<v t="michael.20060804120410"><vh>Editor Assignment</vh>
<v t="michael.20060921225151"><vh>Assign Editors</vh></v>
<v t="michael.20060821115933"><vh>class EditorRegistry</vh></v>
</v>
</v>
</v>
</v>
<v t="michael.20060918141622"><vh>ChartView</vh>
<v t="mr7771.20060609152050" tnodeList="mr7771.20060609152050,mr7771.20060609151433,mr7771.20060609152050.1,mr7771.20060609152050.2,mr7771.20060609152050.3,mr7771.20060609152050.4,mr7771.20060609152050.5,mr7771.20060609152050.6,mr7771.20060609152050.7,mr7771.20060609152050.8,mr7771.20060609152050.9,mr7771.20060609152050.10,mr7771.20060609152050.11,mr7771.20060609152050.12,mr7771.20060609152050.13,mr7771.20060609152050.14,mr7771.20060609152050.15,mr7771.20060609152050.16,mr7771.20060609152050.17,mr7771.20060609152050.18,mr7771.20060609152050.19,michael.20060703173400,mr7771.20060609152050.20,mr7771.20060609152050.27,mr7771.20060609152050.23,mr7771.20060609152050.22,mr7771.20060609152050.26,mr7771.20060609152050.43,michael.20060703173400.1,mr7771.20060609152050.21,mr7771.20060609152050.36,mr7771.20060609152050.40,mr7771.20060609152050.44,mr7771.20060609152050.45,mr7771.20060609152050.47,michael.20060703173400.2,mr7771.20060609152050.24,mr7771.20060609152050.25,mr7771.20060609152050.30,mr7771.20060609152050.31,mr7771.20060609152050.32,mr7771.20060609152050.33,mr7771.20060609152050.46,michael.20060703173400.3,mr7771.20060609152050.37,mr7771.20060609152050.39,michael.20060703173400.4,mr7771.20060609152050.28,mr7771.20060609152050.29,mr7771.20060609152050.34,mr7771.20060609152050.35,mr7771.20060609152050.38,mr7771.20060609152050.41,mr7771.20060609152050.42,mr7771.20060609152050.48,mr7771.20060609152050.49,mr7771.20060609152050.50,mr7771.20060609152050.52,michael.20060703173400.5,mr7771.20060609152050.51,mr7771.20060609152050.53,mr7771.20060609152050.54,mr7771.20060609152050.55,mr7771.20060609152050.56,mr7771.20060609152050.57,mr7771.20060609152050.58,mr7771.20060609152050.59,mr7771.20060609152050.60,mr7771.20060609152050.61,mr7771.20060609152050.62,mr7771.20060609152050.63,mr7771.20060609152050.64,mr7771.20060609152050.65,mr7771.20060609152050.66,mr7771.20060609152050.67,mr7771.20060609152050.68,mr7771.20060609152050.69,mr7771.20060609152050.70,mr7771.20060609152050.71"><vh>@file gui/chartview.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="mr7771.20060609152050.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="mr7771.20060609152050.2"><vh>_cint</vh></v>
<v t="mr7771.20060609152050.3"><vh>_nop</vh></v>
<v t="mr7771.20060609152050.4"><vh>_chart_factory</vh></v>
<v t="mr7771.20060609152050.5"><vh>_timechart_factory</vh></v>
<v t="mr7771.20060609152050.6"><vh>class _ErrorChart</vh>
<v t="mr7771.20060609152050.7"><vh>&lt;&lt; class _ErrorChart declarations &gt;&gt;</vh></v>
<v t="mr7771.20060609152050.8"><vh>create</vh></v>
</v>
<v t="mr7771.20060609152050.9"><vh>class Toolbar</vh>
<v t="mr7771.20060609152050.10"><vh>_init_toolbar</vh></v>
<v t="mr7771.20060609152050.11"><vh>create_menus</vh></v>
<v t="mr7771.20060609152050.12"><vh>make_menu</vh></v>
<v t="mr7771.20060609152050.13"><vh>refresh_buttons</vh></v>
<v t="mr7771.20060609152050.14"><vh>set_history_buttons</vh></v>
<v t="mr7771.20060609152050.15"><vh>set_cursor</vh></v>
<v t="mr7771.20060609152050.16"><vh>draw_rubberband</vh></v>
<v t="mr7771.20060609152050.17"><vh>release</vh></v>
<v t="mr7771.20060609152050.18"><vh>mouse_move</vh></v>
</v>
<v t="mr7771.20060609152050.19"><vh>class ChartView</vh>
<v t="michael.20060703173400"><vh>Init Methods</vh>
<v t="mr7771.20060609152050.20"><vh>__init__</vh></v>
<v t="mr7771.20060609152050.27"><vh>_setup_events</vh></v>
<v t="mr7771.20060609152050.23"><vh>init_scrolling</vh></v>
<v t="mr7771.20060609152050.22"><vh>replace_data</vh></v>
<v t="mr7771.20060609152050.26"><vh>create_chart</vh></v>
<v t="mr7771.20060609152050.43"><vh>setup_scrolling</vh></v>
</v>
<v t="michael.20060703173400.1"><vh>wxPython Methods</vh>
<v t="mr7771.20060609152050.21"><vh>Destroy</vh></v>
<v t="mr7771.20060609152050.36"><vh>_on_timer</vh></v>
<v t="mr7771.20060609152050.40"><vh>_on_size</vh></v>
<v t="mr7771.20060609152050.44"><vh>_on_set_focus</vh></v>
<v t="mr7771.20060609152050.45"><vh>_on_kill_focus</vh></v>
<v t="mr7771.20060609152050.47"><vh>_on_idle</vh></v>
</v>
<v t="michael.20060703173400.2"><vh>Geometry Methods</vh>
<v t="mr7771.20060609152050.24"><vh>scale_figure</vh></v>
<v t="mr7771.20060609152050.25"><vh>check_limits</vh></v>
<v t="mr7771.20060609152050.30"><vh>zoom_to_fit</vh></v>
<v t="mr7771.20060609152050.31"><vh>horz_zoom</vh></v>
<v t="mr7771.20060609152050.32"><vh>vert_zoom</vh></v>
<v t="mr7771.20060609152050.33"><vh>scroll</vh></v>
<v t="mr7771.20060609152050.46"><vh>update_state</vh></v>
</v>
<v t="michael.20060703173400.3"><vh>Matplotlib Events</vh>
<v t="mr7771.20060609152050.37"><vh>mouse_over</vh></v>
<v t="mr7771.20060609152050.39"><vh>mouse_button</vh></v>
</v>
<v t="michael.20060703173400.4"><vh>Misc Methods</vh>
<v t="mr7771.20060609152050.28"><vh>become_visible</vh></v>
<v t="mr7771.20060609152050.29"><vh>duplicate</vh></v>
<v t="mr7771.20060609152050.34"><vh>change_link</vh></v>
<v t="mr7771.20060609152050.35"><vh>deferred</vh></v>
<v t="mr7771.20060609152050.38"><vh>mark_widget</vh></v>
<v t="mr7771.20060609152050.41"><vh>_show_info</vh></v>
<v t="mr7771.20060609152050.42"><vh>mouse_pos_data</vh></v>
<v t="mr7771.20060609152050.48"><vh>show_object</vh></v>
<v t="mr7771.20060609152050.49"><vh>_show_widget</vh></v>
<v t="mr7771.20060609152050.50"><vh>show_x_coord</vh></v>
<v t="mr7771.20060609152050.52"><vh>draw</vh></v>
</v>
<v t="michael.20060703173400.5"><vh>Metapie Methods</vh>
<v t="mr7771.20060609152050.51"><vh>accept_sibling</vh></v>
</v>
</v>
<v t="mr7771.20060609152050.53"><vh>class TimeViewManager</vh>
<v t="mr7771.20060609152050.54"><vh>&lt;&lt; class TimeViewManager declarations &gt;&gt;</vh></v>
<v t="mr7771.20060609152050.55"><vh>get_manager</vh></v>
<v t="mr7771.20060609152050.56"><vh>__init__</vh></v>
<v t="mr7771.20060609152050.57"><vh>register</vh></v>
<v t="mr7771.20060609152050.58"><vh>unregister</vh></v>
<v t="mr7771.20060609152050.59"><vh>update_siblings</vh></v>
<v t="mr7771.20060609152050.60"><vh>_update_scroll_info</vh></v>
<v t="mr7771.20060609152050.61"><vh>update_xlim</vh></v>
<v t="mr7771.20060609152050.62"><vh>shared</vh></v>
<v t="mr7771.20060609152050.63"><vh>get_sibling_pos</vh></v>
</v>
<v t="mr7771.20060609152050.64"><vh>class TimeChartView</vh>
<v t="mr7771.20060609152050.65"><vh>__init__</vh></v>
<v t="mr7771.20060609152050.66"><vh>create_chart</vh></v>
<v t="mr7771.20060609152050.67"><vh>scale_figure</vh></v>
<v t="mr7771.20060609152050.68"><vh>Destroy</vh></v>
<v t="mr7771.20060609152050.69"><vh>accept_sibling</vh></v>
<v t="mr7771.20060609152050.70"><vh>show_x_coord</vh></v>
<v t="mr7771.20060609152050.71"><vh>init_scrolling</vh></v>
</v>
</v>
<v t="michael.20060918141622.1" tnodeList="michael.20060918141622.1,mr7771.20060609151433,michael.20060918141622.2,michael.20060918141622.3,michael.20060918141622.4,michael.20060918141622.5,michael.20060918141622.6,michael.20060918141622.7,michael.20060918141622.8,michael.20060918141622.9,michael.20060918141622.10,michael.20060918141622.11,michael.20060918141622.12,michael.20060918141622.13,michael.20060918141622.14,michael.20060918141622.15,michael.20060918141622.16,michael.20060918141622.17,michael.20060918141622.18,michael.20060918141622.19,michael.20060918141622.20,michael.20060918141622.21,michael.20060918141622.22,michael.20060918141622.23,michael.20060918141622.24,michael.20060918141622.25,michael.20060918141622.26,michael.20060918141622.27,michael.20060918141622.28,michael.20060918141622.29,michael.20060918141622.30,michael.20060918141622.31,michael.20060918141622.32,michael.20060918141622.33,michael.20060918141622.34,michael.20060918141622.35,michael.20060918141622.36,michael.20060918141622.37,michael.20060918141622.38,michael.20060918141622.39,michael.20060918141622.40,michael.20060918141622.41,michael.20060918141622.42,michael.20060918141622.43,michael.20060918141622.44,michael.20060918141622.45,michael.20060918141622.46,michael.20060918141622.47,michael.20060918141622.48,michael.20060918141622.49,michael.20060918141622.50,michael.20060918141622.51,michael.20060918141622.52,michael.20060918141622.53,michael.20060918141622.54,michael.20060918141622.55,michael.20060918141622.56,michael.20060918141622.57,michael.20060918141622.58,michael.20060918141622.59,michael.20060918141622.60,michael.20060918141622.61,michael.20060918141622.62,michael.20060918141622.63,michael.20060918141622.64,michael.20060918141622.65,michael.20060918141622.66,michael.20060918141622.67,michael.20060918141622.68,michael.20060918141622.69,michael.20060918141622.70,michael.20060918141622.71,michael.20060918141622.73,michael.20060918141622.74,michael.20060918141622.75,michael.20060918141622.77,michael.20060918141622.78,michael.20060918141622.80,michael.20060918141622.82,michael.20060918141622.84,michael.20060918141622.86,michael.20060918141622.87,michael.20060918141622.88"><vh>@file gui/print_chart.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060918141622.2"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060918141622.3"><vh>class ChartPrinter</vh>
<v t="michael.20060918141622.4"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060918141622.5"><vh>__init__</vh></v>
<v t="michael.20060918141622.6"><vh>refresh</vh></v>
<v t="michael.20060918141622.7"><vh>reset_valid</vh></v>
<v t="michael.20060918141622.8"><vh>__call__</vh></v>
<v t="michael.20060918141622.9"><vh>_fire_others</vh></v>
<v t="michael.20060918141622.10"><vh>_get_filename</vh></v>
<v t="michael.20060918141622.11"><vh>_set_filename</vh></v>
<v t="michael.20060918141622.12"><vh>_get_unit</vh></v>
<v t="michael.20060918141622.13"><vh>_set_unit</vh></v>
<v t="michael.20060918141622.14"><vh>_get_width</vh></v>
<v t="michael.20060918141622.15"><vh>_set_width</vh></v>
<v t="michael.20060918141622.16"><vh>_get_height</vh></v>
<v t="michael.20060918141622.17"><vh>_set_height</vh></v>
<v t="michael.20060918141622.18"><vh>_get_dpi</vh></v>
<v t="michael.20060918141622.19"><vh>_set_dpi</vh></v>
<v t="michael.20060918141622.20"><vh>calc_media_size</vh></v>
<v t="michael.20060918141622.21"><vh>calc_command</vh></v>
<v t="michael.20060918141622.22"><vh>add_command_attributes</vh></v>
<v t="michael.20060918141622.23"><vh>check_constraints</vh></v>
<v t="michael.20060918141622.24"><vh>save</vh></v>
<v t="michael.20060918141622.25"><vh>call_ps2pdf</vh></v>
</v>
<v t="michael.20060918141622.26"><vh>class LimitsPrinter</vh>
<v t="michael.20060918141622.27"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060918141622.28"><vh>__init__</vh></v>
<v t="michael.20060918141622.29"><vh>zoom</vh></v>
<v t="michael.20060918141622.30"><vh>_fire_others</vh></v>
<v t="michael.20060918141622.31"><vh>_set_xmin</vh></v>
<v t="michael.20060918141622.32"><vh>_set_xmax</vh></v>
<v t="michael.20060918141622.33"><vh>_set_ymin</vh></v>
<v t="michael.20060918141622.34"><vh>_set_ymax</vh></v>
<v t="michael.20060918141622.35"><vh>_get_xmin</vh></v>
<v t="michael.20060918141622.36"><vh>_get_xmax</vh></v>
<v t="michael.20060918141622.37"><vh>_get_ymin</vh></v>
<v t="michael.20060918141622.38"><vh>_get_ymax</vh></v>
<v t="michael.20060918141622.39"><vh>set_max_limits</vh></v>
<v t="michael.20060918141622.40"><vh>add_command_attributes</vh></v>
</v>
<v t="michael.20060918141622.41"><vh>class WidgetPrinter</vh>
<v t="michael.20060918141622.42"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060918141622.43"><vh>_get_font_size</vh></v>
<v t="michael.20060918141622.44"><vh>_set_font_size</vh></v>
<v t="michael.20060918141622.45"><vh>add_command_attributes</vh></v>
</v>
<v t="michael.20060918141622.46"><vh>class TimePrinter</vh>
<v t="michael.20060918141622.47"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060918141622.48"><vh>__init__</vh></v>
<v t="michael.20060918141622.49"><vh>_set_tmin</vh></v>
<v t="michael.20060918141622.50"><vh>_set_tmax</vh></v>
<v t="michael.20060918141622.51"><vh>_get_tmin</vh></v>
<v t="michael.20060918141622.52"><vh>_get_tmax</vh></v>
<v t="michael.20060918141622.53"><vh>add_command_attributes</vh></v>
</v>
<v t="michael.20060918141622.54"><vh>class TimeWidgetPrinter</vh></v>
<v t="michael.20060918141622.55"><vh>class TimePlotPrinter</vh>
<v t="michael.20060918141622.56"><vh>add_command_attributes</vh></v>
</v>
<v t="michael.20060918141622.57"><vh>class PointPrinter</vh></v>
<v t="michael.20060918141622.58"><vh>class PrinterView</vh>
<v t="michael.20060918141622.59"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="michael.20060918141622.60"><vh>__init__</vh></v>
<v t="michael.20060918141622.61"><vh>create_buttons_controls</vh></v>
<v t="michael.20060918141622.62"><vh>prepare</vh></v>
<v t="michael.20060918141622.63"><vh>modify_subview</vh></v>
<v t="michael.20060918141622.64"><vh>_prepare_others</vh></v>
<v t="michael.20060918141622.65"><vh>button_cancel</vh></v>
<v t="michael.20060918141622.66"><vh>button_save</vh></v>
<v t="michael.20060918141622.67"><vh>make_size_int</vh></v>
<v t="michael.20060918141622.68"><vh>make_size_float</vh></v>
<v t="michael.20060918141622.69"><vh>state_changed</vh></v>
<v t="michael.20060918141622.70"><vh>constitute</vh></v>
</v>
<v t="michael.20060918141622.71"><vh>class LimitsPrinterView</vh>
<v t="michael.20060918141622.73"><vh>_prepare_others</vh></v>
<v t="michael.20060918141622.74"><vh>create_controls</vh></v>
</v>
<v t="michael.20060918141622.75"><vh>class WidgetPrinterView</vh>
<v t="michael.20060918141622.77"><vh>_prepare_others</vh></v>
</v>
<v t="michael.20060918141622.78"><vh>class TimePrinterView</vh></v>
<v t="michael.20060918141622.80"><vh>class TimePlotPrinterView</vh></v>
<v t="michael.20060918141622.82"><vh>class TimeWidgetPrinterView</vh></v>
<v t="michael.20060918141622.84"><vh>class PointPrinterView</vh></v>
<v t="michael.20060918141622.86"><vh>class PrintChart</vh>
<v t="michael.20060918141622.87"><vh>__init__</vh></v>
<v t="michael.20060918141622.88"><vh>ShowModal</vh></v>
</v>
</v>
</v>
<v t="michael.20060621114845" tnodeList="michael.20060621114845,mr7771.20060609151433,michael.20060621114845.1,michael.20060621114845.2,michael.20060622085024,michael.20060622085024.1,michael.20060621114845.3,michael.20060621114845.4,michael.20060621114845.5,michael.20060621114845.6,michael.20060621114845.7,michael.20060705004026,michael.20060621114845.8,michael.20060621114845.10,michael.20060621114845.9,michael.20060705003619,michael.20060621114845.14,michael.20060621114845.15,michael.20060621114845.16,michael.20060705003619.1,michael.20060621114845.33,michael.20060621114845.34,michael.20060621114845.31,michael.20060621114845.28,michael.20060705003619.2,michael.20060621114845.19,michael.20060621114845.20,michael.20060621114845.21,michael.20060705004026.1,michael.20060621114845.22,michael.20060621114845.12,michael.20060705004818,michael.20070116023524,michael.20060621114845.17,michael.20060621114845.18,michael.20060621114845.23,michael.20060621114845.24,michael.20060705004026.2,michael.20060621114845.13,michael.20060621114845.25,michael.20060621114845.26,michael.20060621114845.27,michael.20060621114845.35,michael.20060621114845.36,michael.20060621114845.37,michael.20060621114845.38,michael.20060621114845.39,michael.20060621114845.40,michael.20060621114845.41,michael.20060629005237,michael.20060621114845.42,michael.20060621114845.43,michael.20060621114845.44,michael.20060626184639,michael.20060621114845.45,michael.20060703212350.1,michael.20060703212350,michael.20060621114845.46,michael.20060621120211.7,michael.20060621131531,michael.20060622090146.1,michael.20060621120211.1,michael.20060621120211.2,michael.20060621120211.3,michael.20060724204736,michael.20060621120211.4,michael.20060621120211.5,michael.20060621120211.6,michael.20060621114845.47,michael.20060622090146.2,michael.20060703211129.1,michael.20060703191028,michael.20060703191028.1,michael.20060703211129,michael.20060621114845.48,michael.20060621114845.49,michael.20060621114845.50,michael.20060621114845.51,michael.20060621114845.52,michael.20060621114845.53,michael.20060621114845.54,michael.20060621114845.55,michael.20060621114845.56,michael.20060621114845.57,michael.20060621114845.58,michael.20060621114845.59,michael.20060621114845.60,michael.20060621114845.61,michael.20060621114845.62,michael.20060621114845.63,michael.20060621114845.64,michael.20061106013825,michael.20060621114845.65,michael.20060621114845.66,michael.20060621114845.67,michael.20060621114845.68,michael.20060621114845.69,michael.20060621114845.70,michael.20060621114845.71,michael.20060621114845.72,michael.20060621114845.73,michael.20060621114845.74,michael.20060621114845.75,michael.20070421153201,michael.20060621114845.76,michael.20060621114845.77,michael.20060621114845.78,michael.20060621114845.79,michael.20060919144445,michael.20060621114845.80,michael.20060621114845.81,michael.20060621114845.82,michael.20060621114845.83,michael.20060923134450.4,michael.20060621114845.84"><vh>@file gui/plangui.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060621114845.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060621114845.2"><vh>&lt;&lt; Setting Globals &gt;&gt;</vh></v>
<v t="michael.20060622085024"><vh>Tools</vh>
<v t="michael.20060622085024.1"><vh>_import_</vh></v>
<v t="michael.20060621114845.3"><vh>title_of_path</vh></v>
<v t="michael.20060621114845.4"><vh>is_project_file</vh></v>
<v t="michael.20060621114845.5"><vh>getsourcefile</vh></v>
<v t="michael.20060621114845.6"><vh>_generate_menu_wrapper</vh></v>
</v>
<v t="michael.20060621114845.7"><vh>class PlanBuffer</vh>
<v t="michael.20060705004026"><vh>Construct and Destroy Methods</vh>
<v t="michael.20060621114845.8"><vh>__init__</vh></v>
<v t="michael.20060621114845.10"><vh>__del__</vh></v>
<v t="michael.20060621114845.9"><vh>close</vh></v>
</v>
<v t="michael.20060705003619"><vh>Metapie Methods</vh>
<v t="michael.20060621114845.14"><vh>_right_click_</vh></v>
<v t="michael.20060621114845.15"><vh>register</vh></v>
<v t="michael.20060621114845.16"><vh>accept_sibling</vh></v>
</v>
<v t="michael.20060705003619.1"><vh>Mediator Methods</vh>
<v t="michael.20060621114845.33"><vh>goto_source</vh></v>
<v t="michael.20060621114845.34"><vh>find_in_source</vh></v>
<v t="michael.20060621114845.31" a="M"><vh>show_object</vh></v>
<v t="michael.20060621114845.28"><vh>get_edit_view</vh></v>
</v>
<v t="michael.20060705003619.2"><vh>Backup Methods</vh>
<v t="michael.20060621114845.19"><vh>get_backup_file</vh></v>
<v t="michael.20060621114845.20"><vh>remove_backup_file</vh></v>
<v t="michael.20060621114845.21"><vh>save_backup</vh></v>
</v>
<v t="michael.20060705004026.1"><vh>Buffer Methods</vh>
<v t="michael.20060621114845.22"><vh>__deferred_save</vh></v>
<v t="michael.20060621114845.12" a="M"><vh>refresh</vh>
<v t="michael.20060705004818"><vh>&lt;&lt; find path and consider backups &gt;&gt;</vh></v>
<v t="michael.20070116023524"><vh>&lt;&lt; fix efficiency misspelling &gt;&gt;</vh></v>
</v>
<v t="michael.20060621114845.17" a="M"><vh>get_encoding</vh></v>
<v t="michael.20060621114845.18"><vh>save</vh></v>
<v t="michael.20060621114845.23"><vh>save_buffer</vh></v>
<v t="michael.20060621114845.24"><vh>modified</vh></v>
</v>
<v t="michael.20060705004026.2"><vh>Misc Methods</vh>
<v t="michael.20060621114845.13"><vh>__str__</vh></v>
<v t="michael.20060621114845.25"><vh>menu_save_as</vh></v>
<v t="michael.20060621114845.26"><vh>set_focus</vh></v>
<v t="michael.20060621114845.27"><vh>set_menus</vh></v>
<v t="michael.20060621114845.35"><vh>set_observer</vh></v>
<v t="michael.20060621114845.36"><vh>__set_views</vh></v>
</v>
</v>
<v t="michael.20060621114845.37"><vh>class _Executer</vh>
<v t="michael.20060621114845.38"><vh>&lt;&lt; class _Executer declarations &gt;&gt;</vh></v>
<v t="michael.20060621114845.39"><vh>__init__</vh></v>
<v t="michael.20060621114845.40"><vh>get_module</vh></v>
<v t="michael.20060621114845.41"><vh>remove_modules</vh>
<v t="michael.20060629005237" a="M"><vh>&lt;&lt; remove module &gt;&gt;</vh></v>
</v>
<v t="michael.20060621114845.42"><vh>clear_cache</vh></v>
<v t="michael.20060621114845.43" a="M"><vh>execute_plan</vh></v>
<v t="michael.20060621114845.44"><vh>save_execute</vh></v>
<v t="michael.20060626184639"><vh>traceback</vh></v>
<v t="michael.20060621114845.45"><vh>__refresh_active_buffer_list</vh>
<v t="michael.20060703212350.1" a="M"><vh>&lt;&lt; get all loaded source files &gt;&gt;</vh></v>
<v t="michael.20060703212350"><vh>&lt;&lt; add new plan buffers &gt;&gt;</vh></v>
</v>
<v t="michael.20060621114845.46"><vh>__refresh_view_list</vh>
<v t="michael.20060621120211.7"><vh>&lt;&lt; init collections &gt;&gt;</vh></v>
<v t="michael.20060621131531" a="M"><vh>&lt;&lt; define is_valid_module &gt;&gt;</vh></v>
<v t="michael.20060622090146.1"><vh>&lt;&lt; import a possible gui part of the module &gt;&gt;</vh></v>
<v t="michael.20060621120211.1"><vh>&lt;&lt; check if k, v is an observer &gt;&gt;</vh></v>
<v t="michael.20060621120211.2"><vh>&lt;&lt; check if k, v is an project evaluation &gt;&gt;</vh></v>
<v t="michael.20060621120211.3"><vh>&lt;&lt; check if k, v is a resource &gt;&gt;</vh></v>
<v t="michael.20060724204736"><vh>&lt;&lt; check if k, v is a calendar &gt;&gt;</vh></v>
<v t="michael.20060621120211.4"><vh>&lt;&lt; check if k, v has menu &gt;&gt;</vh></v>
<v t="michael.20060621120211.5"><vh>&lt;&lt; assign collections to models &gt;&gt;</vh></v>
<v t="michael.20060621120211.6"><vh>&lt;&lt; create Toolmenu &gt;&gt;</vh></v>
</v>
<v t="michael.20060621114845.47"><vh>__execute_module</vh>
<v t="michael.20060622090146.2"><vh>&lt;&lt; check filename &gt;&gt;</vh></v>
<v t="michael.20060703211129.1"><vh>&lt;&lt; remove modules that have to be reloaded &gt;&gt;</vh></v>
<v t="michael.20060703191028"><vh>&lt;&lt; init main_module &gt;&gt;</vh></v>
<v t="michael.20060703191028.1"><vh>&lt;&lt; fetch code and execute it &gt;&gt;</vh></v>
<v t="michael.20060703211129"><vh>&lt;&lt; find imported modules &gt;&gt;</vh></v>
</v>
</v>
<v t="michael.20060621114845.48"><vh>class ShellView</vh>
<v t="michael.20060621114845.49"><vh>__init__</vh></v>
<v t="michael.20060621114845.50"><vh>_on_get_focus</vh></v>
</v>
<v t="michael.20060621114845.51"><vh>class LoggerView</vh>
<v t="michael.20060621114845.52"><vh>__init__</vh></v>
<v t="michael.20060621114845.53"><vh>_on_get_focus</vh></v>
</v>
<v t="michael.20060621114845.54"><vh>class Session</vh>
<v t="michael.20060621114845.55"><vh>&lt;&lt; class Session declarations &gt;&gt;</vh></v>
<v t="michael.20060621114845.56"><vh>__init__</vh></v>
<v t="michael.20060621114845.57"><vh>end_session</vh></v>
<v t="michael.20060621114845.58"><vh>get_help</vh></v>
<v t="michael.20060621114845.59"><vh>jump_to_file</vh></v>
<v t="michael.20060621114845.60"><vh>set_menus</vh></v>
<v t="michael.20060621114845.61"><vh>add_recent_file</vh></v>
<v t="michael.20060621114845.62"><vh>update_recent_menu</vh></v>
<v t="michael.20060621114845.63"><vh>register</vh></v>
<v t="michael.20060621114845.64"><vh>menu_recalc</vh></v>
<v t="michael.20061106013825"><vh>check_for_correction</vh></v>
<v t="michael.20060621114845.65"><vh>menu_help</vh></v>
<v t="michael.20060621114845.66"><vh>menu_send_project</vh></v>
<v t="michael.20060621114845.67"><vh>menu_howtos</vh></v>
<v t="michael.20060621114845.68"><vh>menu_new</vh></v>
<v t="michael.20060621114845.69"><vh>menu_open</vh></v>
<v t="michael.20060621114845.70"><vh>menu_close</vh></v>
<v t="michael.20060621114845.71"><vh>open_file</vh></v>
<v t="michael.20060621114845.72"><vh>check_modified_buffers</vh></v>
</v>
<v t="michael.20060621114845.73"><vh>showwarning</vh></v>
<v t="michael.20060621114845.74"><vh>check_installation</vh></v>
<v t="michael.20060621114845.75"><vh>check_memory</vh></v>
<v t="michael.20070421153201" a="M"><vh>class TaskBarIcon</vh></v>
<v t="michael.20060621114845.76"><vh>class FacesApp</vh>
<v t="michael.20060621114845.77"><vh>OnInit</vh></v>
<v t="michael.20060621114845.78"><vh>show_splash</vh></v>
<v t="michael.20060621114845.79"><vh>_on_frame_close</vh></v>
<v t="michael.20060919144445"><vh>_on_menu_open</vh></v>
<v t="michael.20060621114845.80"><vh>is_processing</vh></v>
<v t="michael.20060621114845.81"><vh>progress_start</vh></v>
<v t="michael.20060621114845.82"><vh>progress_update</vh></v>
<v t="michael.20060621114845.83"><vh>progress_end</vh></v>
<v t="michael.20060923134450.4"><vh>get_planbuffers</vh></v>
</v>
<v t="michael.20060621114845.84"><vh>main</vh></v>
</v>
<v t="michael.20060703233047" tnodeList="michael.20060703233047,mr7771.20060609151433,michael.20060703233047.1,michael.20060703233047.2,michael.20060703233047.3,michael.20060912153307,michael.20060703233047.4,michael.20060703233047.5,michael.20060703233047.6,michael.20060703233047.7,michael.20060703233047.8,michael.20060703233047.9,michael.20060703233047.10,michael.20060703233047.11,michael.20060703233047.12,michael.20060703233047.13,michael.20060703233047.14,michael.20060703233047.15,michael.20060703233047.16,michael.20060703233047.17,michael.20060703233047.18,michael.20060703233047.19,michael.20060703233047.20,michael.20060703233047.21,michael.20060703233047.22,michael.20060703233047.23,michael.20060703233047.24,michael.20060703233047.25,michael.20060703233047.26,michael.20060703233047.27,michael.20060703233047.28,michael.20060703233047.29,michael.20060703233047.30,michael.20060703233047.31,michael.20060703233047.32,michael.20060703233047.33,michael.20060703233047.34,michael.20060703233047.36,michael.20060703233047.37,michael.20060703233047.38,michael.20060703233047.39,michael.20060703233047.40,michael.20060703233047.41,michael.20060703233047.42,michael.20060703233047.43"><vh>@file gui/repview.py</vh>
<v t="mr7771.20060609151433"><vh>&lt;&lt; Copyright &gt;&gt;</vh></v>
<v t="michael.20060703233047.1"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="michael.20060703233047.2"><vh>convert_color</vh></v>
<v t="michael.20060703233047.3"><vh>_report_factory</vh></v>
<v t="michael.20060912153307"><vh>encode</vh></v>
<v t="michael.20060703233047.4"><vh>class _ErrorReport</vh>
<v t="michael.20060703233047.5"><vh>&lt;&lt; class _ErrorReport declarations &gt;&gt;</vh></v>
<v t="michael.20060703233047.6"><vh>make_report</vh></v>
</v>
<v t="michael.20060703233047.7"><vh>class CellRenderer</vh>
<v t="michael.20060703233047.8"><vh>__init__</vh></v>
<v t="michael.20060703233047.9"><vh>Draw</vh></v>
<v t="michael.20060703233047.10"><vh>GetBestSize</vh></v>
<v t="michael.20060703233047.11"><vh>Clone</vh></v>
</v>
<v t="michael.20060703233047.12"><vh>class ReportView</vh>
<v t="michael.20060703233047.13"><vh>__init__</vh></v>
<v t="michael.20060703233047.14"><vh>make_menu</vh></v>
<v t="michael.20060703233047.15"><vh>navigate</vh></v>
<v t="michael.20060703233047.16"><vh>set_grid_notifications</vh></v>
<v t="michael.20060703233047.17"><vh>change_link</vh></v>
<v t="michael.20060703233047.18"><vh>OnLeftDown</vh></v>
<v t="michael.20060703233047.19"><vh>OnRightDown</vh></v>
<v t="michael.20060703233047.20"><vh>OnCellSelect</vh></v>
<v t="michael.20060703233047.21"><vh>menu_print_report</vh></v>
<v t="michael.20060703233047.22"><vh>menu_export_csv</vh></v>
<v t="michael.20060703233047.23"><vh>Destroy</vh></v>
<v t="michael.20060703233047.24"><vh>show_object</vh></v>
<v t="michael.20060703233047.25"><vh>set_cursor</vh></v>
<v t="michael.20060703233047.26"><vh>replace_data</vh></v>
<v t="michael.20060703233047.27"><vh>__fill_grid</vh></v>
<v t="michael.20060703233047.28"><vh>calc_font_size</vh></v>
<v t="michael.20060703233047.29"><vh>accept_sibling</vh></v>
</v>
<v t="michael.20060703233047.30"><vh>class ExportCSV_Model</vh>
<v t="michael.20060703233047.31"><vh>&lt;&lt; class ExportCSV_Model declarations &gt;&gt;</vh></v>
<v t="michael.20060703233047.32"><vh>check_constraints</vh></v>
<v t="michael.20060703233047.33"><vh>exporter</vh></v>
</v>
<v t="michael.20060703233047.34"><vh>class ExportCSV_View</vh>
<v t="michael.20060703233047.36"><vh>prepare</vh></v>
<v t="michael.20060703233047.37"><vh>constitute</vh></v>
<v t="michael.20060703233047.38"><vh>state_changed</vh></v>
<v t="michael.20060703233047.39"><vh>button_cancel</vh></v>
<v t="michael.20060703233047.40"><vh>button_ok</vh></v>
</v>
<v t="michael.20060703233047.41"><vh>class ExportCSV_Dialog</vh>
<v t="michael.20060703233047.42"><vh>__init__</vh></v>
<v t="michael.20060703233047.43"><vh>ShowModal</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="michael.20060616141344">    @others</t>
<t tx="michael.20060616141400.1"></t>
<t tx="michael.20060616143205">def get_main_completion_list(self):
    """
    returns the completion list of the context
    """
    return ()


</t>
<t tx="michael.20060616143205.1">    @others</t>
<t tx="michael.20060616143938">def get_sub_completion_list(self, name):
    """
    returns the completions list of a specific attribute
    """
    return ()</t>
<t tx="michael.20060616144322"></t>
<t tx="michael.20060616144322.1"></t>
<t tx="michael.20060616144322.2"></t>
<t tx="michael.20060616144838"></t>
<t tx="michael.20060616144838.1"></t>
<t tx="michael.20060616144838.2"></t>
<t tx="michael.20060616144838.3"></t>
<t tx="michael.20060616151822">compl = self.__completion_list = self.get_session_completions()
try:
    if self.context.code_item.obj_type == pyeditor.FUNCTION:
        args = self.context.code_item.get_args()
        compl += map(lambda a: (a, a), args)
except AttributeError: pass</t>
<t tx="michael.20060616153549">def set_menus(self):
    self.model.set_menus()

    ctrl = controller()
    owner = ctrl.find_view_of(self)
    top = ctrl.get_top_menu()

    edit_menu = top.make_menu(_("&amp;Edit"), pos=100)
    fold_menu = edit_menu.make_menu(_("Fold"), pos=1000)
    help_menu = top.make_menu(_("&amp;Help"), pos=99999, id=wx.ID_HELP)
    file_menu = top.make_menu(_("&amp;File"))

    menu = lambda *args, **kw: edit_menu.make_item(owner, *args, **kw)
    def nrc(func):
        def no_record_call():
            self.no_record_call(func)
        return no_record_call

    &lt;&lt; create help menu &gt;&gt;
    &lt;&lt; create snapshot menu &gt;&gt;
    &lt;&lt; create basic edit menus &gt;&gt;
    &lt;&lt; create comment menus &gt;&gt;
    &lt;&lt; create bookmark menus &gt;&gt;
    &lt;&lt; create find menus &gt;&gt;
    &lt;&lt; create macro menus &gt;&gt;
    &lt;&lt; create context menu &gt;&gt;
    &lt;&lt; create correct code menu &gt;&gt;
    &lt;&lt; create menu separators &gt;&gt;
    &lt;&lt; create fold menus &gt;&gt;
    &lt;&lt; create Generate HTML menu &gt;&gt;

    return True
</t>
<t tx="michael.20060616162635">obj = self.get_dot_object(text)
if obj:
    self.__completion_list = self.make_attrib_list(obj)
else:
    self.__completion_list = None
</t>
<t tx="michael.20060616163019">def find_object(self, name):
    """
    Find an object by name.
    """
    return None</t>
<t tx="michael.20060616163651">    @others</t>
<t tx="michael.20060616163651.1">def get_object(self):
    """
    retrieve a valid code or pseudo object
    """
    try:
        obj = self.code_item.obj
    except AttributeError:
        obj = self.code_item.obj = self.get_default_pseudo()

    return obj
</t>
<t tx="michael.20060616170952">def get_dot_object(self, name):
    first_dot = name.index(".")
    last_dot = name.rindex(".")

    root_name = name[:first_dot]
    obj = self.context.find_object(root_name)

    if obj is None:
        obj = self.guess_object(root_name)

    if obj is None:
        obj = getattr(self.get_module(), root_name, None)

    try:
        return eval("obj%s" % name[first_dot:last_dot])
    except:
        return None

</t>
<t tx="michael.20060616171654">attrib = attrib or self.get_word_at(complete=True)
try:
    #attrib contains dots
    obj = self.get_dot_object(attrib)
    attrib = attrib[attrib.rindex(".") + 1:] 
except ValueError:
    try:
        obj = obj or self.context.code_item.obj
    except AttributeError: pass
</t>
<t tx="michael.20060616175116">class CBetweenObservers(Context):
    editor = None
    @others

Context.context_list.append(CBetweenObservers())</t>
<t tx="michael.20060616175207"></t>
<t tx="michael.20060616175207.1">def can_activate(self, editor, line, prev, next, inside):
    def check():
        if inside: return False
        if is_observer(prev) or is_observer_func(prev): return True
        if is_evaluation(prev):
            return line &gt; prev.get_last_line() + 1

        return is_observer(next)

    if check():
        self.editor = editor
        return True
    else:
        self.editor = None
        return False
</t>
<t tx="michael.20060616175302">class CObserverFunc(Context):
    @others

Context.context_list.append(CObserverFunc())</t>
<t tx="michael.20060616175302.1"></t>
<t tx="michael.20060616175302.2">def can_activate(self, editor, line, prev, next, inside):
    return is_observer_func(inside)
</t>
<t tx="michael.20060616181548"></t>
<t tx="michael.20060616181548.1">def get_main_completion_list(self):
    &lt;&lt; get_observers &gt;&gt;
    observers = []
    return get_observers(self.editor.get_module(), "", observers) \
            + self.editor.get_session_completions()
</t>
<t tx="michael.20060616182813">def get_observers(module, prefix, observers):
    if len(prefix.split(".")) &gt; 2: return observers

    try:
        attribs = module.__all__
    except AttributeError:
        attribs = dir(module)

    for a in attribs:
        if a.startswith("_"): continue

        obj = getattr(module, a, None)
        if isinstance(obj, types.ModuleType):
            name = prefix and ".".join((prefix, a)) or a
            get_observers(obj, name, observers)
            continue
        try:
            if issubclass(obj, fobserver.Observer):
                name = prefix and ".".join((prefix, a)) or a
                observers.append(("class %s" % name, "class |My%s(%s):\n" % (a, name)))
        except: pass
    return observers</t>
<t tx="michael.20060616185633">if not self.context.activate(self, line, prev, next, inside):
    #oldc = self.context
    for c in Context.context_list:
        if self.context is c: continue
        if c.activate(self, line, prev, next, inside):
            self.context = c
            break
    else:
        c = self.context = Context.default
        c.activate(self, line, prev, next, inside)</t>
<t tx="michael.20060616185633.1">self.Refresh(False)
if item: self.GetParent().browser.update_selection(item)

</t>
<t tx="michael.20060616185633.2">line = self.GetLine(line)
try:
    attrib_name = line[:line.index("=")].strip()
except ValueError:
    attrib_name = None</t>
<t tx="michael.20060616185633.3">if wx.Window_FindFocus() is self:
    try:
        self.model.show_object(self.GetParent().GetParent(), 
                               self.context.code_item.obj, 
                               attrib_name)
    except AttributeError:
        pass

self.__last_attrib = attrib_name
</t>
<t tx="michael.20060616192508">class CBetweenResource(Context):
    @others

Context.context_list.append(CBetweenResource())    </t>
<t tx="michael.20060616192508.1"></t>
<t tx="michael.20060616192508.2">def can_activate(self, editor, line, prev, next, inside):
    if inside: return False
    return is_resource(next) \
        and (is_resource(prev) \
             or is_import(prev) \
                and line &gt; prev.get_last_line() + 1)

</t>
<t tx="michael.20060616193412">class PTask(object):
    """
    A pseudo task object
    """
    __doc__ = ftask.Task.__doc__
    __attrib_completions__ = ftask.Task.__attrib_completions__.copy()
    __attrib_completions__.update({ "up" : "up", "root" : "root"})    
	@others


</t>
<t tx="michael.20060616193412.1">def __init__(self, code_item=None):
    self.code_item = code_item
    self.to_string = self.me = weakref.proxy(self)

    if code_item:
        self.name = code_item.name
        self.dict_children = dict(map(lambda c: (c.name, PTask(c)), 
                                  self.code_item.get_children()))
        try:
            self.title = code_item.obj.title
        except AttributeError:
            self.title = self.name
    else:
        self.name = self.title = ""</t>
<t tx="michael.20060616193412.2">def _get_root(self):
    last_parent = self.code_item
    parent = last_parent.get_parent()
    while parent:
        last_parent = parent
        parent = parent.get_parent()

    return PTask(last_parent)

root = property(_get_root)
</t>
<t tx="michael.20060616193412.3">def _get_up(self):
    parent = self.code_item.get_parent()
    return parent and PTask(parent) or None

up = property(_get_up)</t>
<t tx="michael.20060616202740"></t>
<t tx="michael.20060616202740.1">def get_main_completion_list(self):
    return [("class (Resource):", "class |NewResource(Resource):\n")]
</t>
<t tx="michael.20060616203047"></t>
<t tx="michael.20060616203047.1">def get_main_completion_list(self):
    import editor
    return editor._editor_completions \
           + self.editor.get_session_completions() \
           + [("class (Resource):", "class |NewResource(Resource):\n"),
              ("def NewProject():", "def |NewProject():\n" ) ]
</t>
<t tx="michael.20060616204036"></t>
<t tx="michael.20060616204036.1">def get_sub_completion_list(self, name):
    compl = super(CTask, self).get_sub_completion_list(name)
    if not compl:
        compl = self.code_item.editor.get_session_completions()

    compl += [("up", "up"), ("root", "root")]
    return compl

</t>
<t tx="michael.20060616212150">def get_main_completion_list(self):
    import editor
    return editor._editor_completions + self.editor.get_session_completions()


</t>
<t tx="michael.20060616213907">_editor_completions = [ ("faces_show_call_tips", "faces_show_call_tips = False" ),
                        ("faces_dimmer_color", 'faces_dimmer_color = "#A0A0A0"' ),
                        ("faces_task_completions", 
                         'faces_task_completions = [ (\'notes\', \'notes = """\\n\\n"""\') ]'),
                         ("alt_week_locator", "alt_week_locator()") ]</t>
<t tx="michael.20060619145551">@language python
&lt;&lt; Copyright &gt;&gt;
"""
This module contains all classes for project plan objects
"""
&lt;&lt; Imports &gt;&gt;

_is_source = True

STRICT = 3
SLOPPY = 2
SMART = 1

@others


"""
    Atttribute mit Bedeutung:

    calendar
    --------
    minimum_time_unit     |int in minutes|           
    working_days_per_week |int in days   |           
    working_days_per_month|int in days   |           
    working_days_per_year |int in days   |           
    working_hours_per_day |int in hours  |           
    vacation              | [ one_day, (from, to), .. ] |           
    working_days
    now



    Task
    -----
    load
    start
    end
    length
    effort
    duration
    resource
    booked_resource

    milestone
    complete
    done
    todo
    priority
    efficiency
    buffer                

    children
    depth
    index
    path
    dont_inherit

    performed_effort
    performed_end
    performed_start

    sum()
    min()
    max()
    costs()
    indent_name()
    max_load

    copy_src (set: copy all attributes of another task 
              get: reference of copy)

    balance

    for gantt
    -----
    line
    accumulate




    Resource
    ----------
    efficiency
    load
    vacation
    max_load

"""
</t>
<t tx="michael.20060619145551.1">import pcalendar
import resource
import types
import sys
import datetime
import operator as op
import warnings
import locale
import weakref
import opcode
import new
try:
    set
except NameError:
    from sets import Set as set
</t>
<t tx="michael.20060619145551.2">class _NEVER_USED_:
    pass

</t>
<t tx="michael.20060619145551.4">class AttributeError(AttributeError):
	&lt;&lt; class AttributeError declarations &gt;&gt;
</t>
<t tx="michael.20060619145551.5">is_frozen = False


</t>
<t tx="michael.20060619145551.6">class RecursionError(Exception):
    """This exception is raised in cas of cirular dependencies
    within an project"""
	&lt;&lt; class RecursionError declarations &gt;&gt;
</t>
<t tx="michael.20060619145551.7">pass


</t>
<t tx="michael.20060619145551.8">class _IncompleteError(Exception):
    """This exception is raised, when there is not enough
    data specified to calculate as task"""
	@others
</t>
<t tx="michael.20060619145551.9">def __init__(self, *args):
    if isinstance(args[0], (basestring)):
        Exception.__init__(self, *args)
    else:
        Exception.__init__(self,
                           "not enough data for calculating task, "\
                           "maybe you have a recursive reference",
                           *args)
</t>
<t tx="michael.20060619145551.10">class _MeProxy(object):
    """
    A Proxy class for the me attribute of tasks in the compile case
    """
	&lt;&lt; declarations &gt;&gt;
	@others</t>
<t tx="michael.20060619145551.11">__slots__ = "task"

</t>
<t tx="michael.20060619145551.12">def __init__(self, task):
    object.__setattr__(self, "task", task)
</t>
<t tx="michael.20060619145551.13">def __getattr__(self, name):
    if self.task._is_frozen:
        return getattr(self.task, name)

    if name in ("name", "up", "root", "path", 
                "depth", "index", "calendar", 
                "children", "resource", "balance"):
        return getattr(self.task, name)

    value = self.task.__dict__.get(name, _NEVER_USED_)
    def make_val(default):
        if value is _NEVER_USED_: return default
        return value

    if name in ("start", "end"):
        return self.task._to_start(make_val("1.1.2006"))

    if name in ("length", "effort", "duration", "todo", "done",
                "buffer", "performed", "performed_effort",
                "performed_end", "performed_start",
                "performed_work_time" ):
        return self.task._to_delta(make_val("0d"))

    if name in ("complete", "priority", "efficiency"):
        return make_val(0)

    if value is _NEVER_USED_:
        raise AttributeError("'%s' is not a valid attribute." % (name))

    return value
</t>
<t tx="michael.20060619145551.14">def __setattr__(self, name, value):
    self.task._set_attrib(name, value)
</t>
<t tx="michael.20060619145551.15">def add_attrib(self, name_or_iter, val=None):
    if not isinstance(name_or_iter, str):
        for n, v in name_or_iter:
            setattr(self, n, v)
    else:
        setattr(self, name_or_iter, val)
</t>
<t tx="michael.20060619145551.16">class _MeProxyRecalc(_MeProxy):
    """
    A Proxy class for the me attribute of tasks in the recalc case
    """
	@others
</t>
<t tx="michael.20060619145551.17">def __setattr__(self, name, value):
    if self.task._properties.has_key(name):
        self.task._set_attrib(name, value)
</t>
<t tx="michael.20060619145551.18">class _MeProxyError(_MeProxy):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619145551.19">__slots__ = ("task", "attrib", "exc")

</t>
<t tx="michael.20060619145551.20">def __init__(self, task, attrib, exc):
    _MeProxy.__init__(self, task)
    object.__setattr__(self, "attrib", attrib)
    object.__setattr__(self, "exc", exc)
</t>
<t tx="michael.20060619145551.21">def __setattr__(self, name, value):
    if name == self.attrib or not self.attrib:
        raise self.exc
</t>
<t tx="michael.20060619145551.22">class _MeProxyWarn(_MeProxy):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619145551.23">__slots__ = ("task", "attrib", "message")

</t>
<t tx="michael.20060619145551.24">def __init__(self, task, attrib, message):
    _MeProxy.__init__(self, task)
    object.__setattr__(self, "attrib", attrib)
    object.__setattr__(self, "message", message)
</t>
<t tx="michael.20060619145551.25">def __setattr__(self, name, value):
    if name == self.attrib or not self.attrib:
        warnings.warn(self.message, RuntimeWarning, 2)
        if not self.attrib:
            #warn only one time!
            object.__setattr__(self, "attrib", 1)
</t>
<t tx="michael.20060619145551.26">class _Path(object):
    """
    This class represents an instrumented path, to
    a task. If it points to an attribute of a task, it
    not only returns the value of the attribute. You can also
    find out the source attribute (task and attribute name)
    of the value.
    """
	@others

</t>
<t tx="michael.20060619145551.27">def __init__(self, task, path_str):
    self._task = task
    self._path_str = path_str
</t>
<t tx="michael.20060619145551.28">def __getattr__(self, name):
    new = getattr(self._task, name)
    if isinstance(new, Task):
        return _Path(new, self._path_str + "." + name)

    return _ValueWrapper(new, [(self._task, name)])
</t>
<t tx="michael.20060619145551.29">def __str__(self):
    return self._path_str
</t>
<t tx="michael.20060619145551.30">def _int_to_arg(value):
    return value % 256, value / 256
</t>
<t tx="michael.20060619145551.31">def _correct_labels(old_code, new_code):
    &lt;&lt; localize dot variables &gt;&gt;
    &lt;&lt; loop initialization &gt;&gt;
    while i &lt; n:
        op = old_code[i]
        nop = new_code[j]
        old_new_map[i] = j
        i = i + 1
        j = j + 1
        if op &gt;= HAVE_ARGUMENT:
            oparg = old_code[i] + old_code[i + 1] * 256
            i = i + 2
            j = j + 2
            if nop != op:
                j += 3 # skip the 3 addition opcodes for attrib access
            else:
                &lt;&lt; add label if necessary &gt;&gt;

    for offset, label in labels.iteritems():
        new_offset = old_new_map[offset]
        new_label = old_new_map[label]
        op = new_code[new_offset - 3]
        #change jump arguments
        if op in hasjrel:
            jump = _int_to_arg(new_label - new_offset)
            new_code[new_offset - 2:new_offset] = jump
        elif op in hasjabs:
            new_code[new_offset - 2:new_offset] = _int_to_arg(new_label)</t>
<t tx="michael.20060619145551.32">def _instrument(func):
    &lt;&lt; localize dot variables &gt;&gt;
    &lt;&lt; define local functions list_to_dict and is_local &gt;&gt;

    #convert code
    &lt;&lt; loop initialization &gt;&gt;
    while i &lt; n:
        if i == next_tab_point:
            &lt;&lt; calculate new tab point &gt;&gt;

        op = code[i]
        i += 1
        if op &gt;= HAVE_ARGUMENT:
            &lt;&lt; calculate argument &gt;&gt;
            i += 2

            if opname[op] == "LOAD_GLOBAL":
                global_names.add(oparg)

            elif opname[op] == "STORE_FAST":
                &lt;&lt; change "store fast" to "store attribute" &gt;&gt;

            elif opname[op] == "LOAD_FAST":
                &lt;&lt; change "load fast" to "load attribute" &gt;&gt;

            elif op in jumps:
                has_labels = True

            new_code.extend((op, arg0, arg1))
        else:
            new_code.append(op)

    if has_labels:
        _correct_labels(code, new_code)

    &lt;&lt; create new code and function objects and return &gt;&gt;</t>
<t tx="michael.20060619145551.33">def _calc_load(task, resource):
    #changed at the resource instance
    load = resource.__dict__.get("load")
    if load is not None: return load

    load = task.__dict__.get("load")
    if load is not None: return load

    #inherited by the task
    return min(task.load, task.max_load, resource.max_load or 100.0)
</t>
<t tx="michael.20060619145551.34">def _calc_maxload(task, resource):
    #changed at the resource instance
    max_load = resource.__dict__.get("max_load")
    if max_load: return max_load

    #an explicit load can overwrite max_load
    load = max(resource.__dict__.get("load", 0),
               task.__dict__.get("load"), 0)

    #change at the task
    max_load = task.__dict__.get("max_load")
    if max_load: return max(max_load, load)

    #inherited by the resource
    max_load = resource.max_load
    if max_load: return max(max_load, load)

    #inherited by the task
    return max(task.max_load, load)
</t>
<t tx="michael.20060619145551.35">#helper functions for _ValueWrapper
#----------------------------------

def _val(val):
    if isinstance(val, _ValueWrapper):
        return val._value

    return val
</t>
<t tx="michael.20060619145551.36">def _ref(val):
    if isinstance(val, _ValueWrapper):
        return val._ref

    return []
</t>
<t tx="michael.20060619145551.37">def _sref(val, ref):
    if isinstance(val, _ValueWrapper):
        val._ref = ref</t>
<t tx="michael.20060619145551.38">

class _ValueWrapper(object):
    """
    This class represents a value, of a task attribute or
    a return value of a task method. It contains the value,
    and the supplier of that value
    """
	@others
</t>
<t tx="michael.20060619145551.39">def __init__(self, value, ref):
    self._value = value
    self._ref = ref
</t>
<t tx="michael.20060619145551.40">def _vw(self, operand, *args):
    refs = _refsum(map(_ref, args))
    vals = map(_val, args)
    result = operand(*vals)
    return self.__class__(result, refs)
</t>
<t tx="michael.20060619145551.41">def _cmp(self, operand, *args):
    refs = _refsum(map(_ref, args))
    vals = map(_val, args)
    result = operand(*vals)
    map(lambda a: _sref(a, refs), args)
    return result
</t>
<t tx="michael.20060619145551.42">def __getattr__(self, name): return getattr(self._value, name)
</t>
<t tx="michael.20060619145551.43">def __str__(self): return str(self._value)
</t>
<t tx="michael.20060619145551.44">def __repr__(self): return repr(self._value)
</t>
<t tx="michael.20060619145551.45">def __nonzero__(self): return bool(self._value)
</t>
<t tx="michael.20060619145551.46">def __lt__(self, other): return self._cmp(op.lt, self, other)
</t>
<t tx="michael.20060619145551.47">def __le__(self, other): return self._cmp(op.le, self, other)
</t>
<t tx="michael.20060619145551.48">def __eq__(self, other): return self._cmp(op.eq, self, other)
</t>
<t tx="michael.20060619145551.49">def __ne__(self, other): return self._cmp(op.ne, self, other)
</t>
<t tx="michael.20060619145551.50">def __gt__(self, other): return self._cmp(op.gt, self, other)
</t>
<t tx="michael.20060619145551.51">def __ge__(self, other): return self._cmp(op.ge, self, other)
</t>
<t tx="michael.20060619145551.52">def __add__(self, other): return self._vw(op.add, self, other)</t>
<t tx="michael.20060619145551.53">def __sub__(self, other): return self._vw(op.sub, self, other)
</t>
<t tx="michael.20060619145551.54">def __mul__(self, other): return self._vw(op.mul, self, other)
</t>
<t tx="michael.20060619145551.55">def __floordiv__(self, other): return self._vw(op.floordiv, self, other)
</t>
<t tx="michael.20060619145551.56">def __mod__(self, other): return self._vw(op.mod, self, other)
</t>
<t tx="michael.20060619145551.57">def __divmod__(self, other): return self._vw(op.divmod, self, other)
</t>
<t tx="michael.20060619145551.58">def __pow__(self, other): return self._vw(op.pow, self, other)
</t>
<t tx="michael.20060619145551.59">def __lshift__(self, other): return self._vw(op.lshift, self, other)
</t>
<t tx="michael.20060619145551.60">def __rshift__(self, other): return self._vw(op.rshift, self, other)
</t>
<t tx="michael.20060619145551.61">def __and__(self, other): return self._vw(op.and_, self, other)
</t>
<t tx="michael.20060619145551.62">def __xor__(self, other): return self._vw(op.xor, self, other)
</t>
<t tx="michael.20060619145551.63">def __or__(self, other): return self._vw(op.or_, self, other)
</t>
<t tx="michael.20060619145551.64">def __div__(self, other): return self._vw(op.div, self, other)
</t>
<t tx="michael.20060619145551.65">def __radd__(self, other): return self._vw(op.add, other, self)
</t>
<t tx="michael.20060619145551.66">def __rsub__(self, other): return self._vw(op.sub, other, self)
</t>
<t tx="michael.20060619145551.67">def __rmul__(self, other): return self._vw(op.mul, other, self)
</t>
<t tx="michael.20060619145551.68">def __rdiv__(self, other): return self._vw(op.div, other, self)
</t>
<t tx="michael.20060619145551.69">def __rtruediv__(self, other): return self._vw(op.truediv, other, self)
</t>
<t tx="michael.20060619145551.70">def __rfloordiv__(self, other): return self._vw(op.floordiv, other, self)
</t>
<t tx="michael.20060619145551.71">def __rmod__(self, other): return self._vw(op.mod, other, self)
</t>
<t tx="michael.20060619145551.72">def __rdivmod__(self, other): return self._vw(op.divmod, other, self)
</t>
<t tx="michael.20060619145551.73">def __rpow__(self, other): return self._vw(op.pow, other, self)
</t>
<t tx="michael.20060619145551.74">def __rlshift__(self, other): return self._vw(op.lshift, other, self)
</t>
<t tx="michael.20060619145551.75">def __rrshift__(self, other): return self._vw(op.rshift, other, self)
</t>
<t tx="michael.20060619145551.76">def __rand__(self, other): return self._vw(op.and_, other, self)
</t>
<t tx="michael.20060619145551.77">def __rxor__(self, other): return self._vw(op.xor, other, self)
</t>
<t tx="michael.20060619145551.78">def __ror__(self, other): return self._vw(op.or_, other, self)
</t>
<t tx="michael.20060619145551.79">def __int__(self): return int(self._value)
</t>
<t tx="michael.20060619145551.80">def __long__(self): return long(self._value)
</t>
<t tx="michael.20060619145551.81">def __float__(self): return float(self._value)
</t>
<t tx="michael.20060619145551.82">def __len__(self): return len(self._value)
</t>
<t tx="michael.20060619145551.83">def __iter__(self): return iter(self._value)
</t>
<t tx="michael.20060619145551.84">def __hash__(self): return hash(self._value)
</t>
<t tx="michael.20060619145551.85">class _StringConverter(object):
    """This class is a helper for the to_string mechanism
    of tasks"""
	@others
</t>
<t tx="michael.20060619145551.86">def __init__(self, source, format=None):
    self.source = source
    self.format = format
</t>
<t tx="michael.20060619145551.87">def __getitem__(self, format):
    return _StringConverter(self.source, format)
</t>
<t tx="michael.20060619145551.88">def __getattr__(self, name):
    class StrWrapper(object):
        def __init__(self, value, name, source, format):
            self._value = value
            self.name = name
            self.source = source
            self.format = format

        def __call__(self, arg):
            formatter = self.source.formatter(self.name,
                                              arg,
                                              self.format)
            return formatter(self._value(arg))

    value = getattr(self.source, name)
    if callable(value):
        #for methods the wrapper has to 
        return StrWrapper(value, name, self.source, self.format)

    formatter = self.source.formatter(name, format=self.format)
    return formatter(value)
</t>
<t tx="michael.20060619145551.89">class AllocationAlgorithm(object):
    """This class is a base for resource allocation algorithms"""
	@others
</t>
<t tx="michael.20060619145551.90">def test_allocation(self, task, resource):
    """This method simulates the allocation of a specific resource.
    It returns a list of values representing the state of the allocation.
    The task allocator calls test_allocation for every alternative resource.
    It compares the first items of all return lists, and allocates the
    resource with the minum first item value"""
    return (task.end, )
</t>
<t tx="michael.20060619145551.91">def allocate(self, task, state):
    """This method eventually allocates a specific resource.
    State is the return list of test_allocation"""
    pass
</t>
<t tx="michael.20060619145551.92">class StrictAllocator(AllocationAlgorithm):
    """This class implements the STRICT resource allocation"""
	@others
</t>
<t tx="michael.20060619145551.93">def _distribute_len_loads(self, task, resource, effort, length):
    # A special load calculation, if effort and length are given.
    # and the resources have a defined maxload, the load must be
    # individually calculated for each resource.

    # Formulars: r=resources, t=task
    #   effort = length * efficiency(t) * sum[load(r) * effiency(r)]
    #   ==&gt; sum_load = sum[load(r) * effiency(r)]
    #                = effort / (length * efficiency(t))
    #

    sum_load = float(effort) / (task.efficiency * length)

    # algorithm:
    # The goal is to distribute the load (norm_load) equally
    # to all resources. If a resource has a max_load(r) &lt; norm_load
    # the load of this resource will be max_load(r), and the other
    # resources will have another (higher) norm_load

    max_loads = map(lambda r: (_calc_maxload(task, r), r), resource)
    max_loads.sort()

    efficiency_sum = sum(map(lambda r: r.efficiency, resource))
    norm_load = sum_load / efficiency_sum

    loads = {}
    for max_load, r in max_loads[:-1]:
        if max_load &lt; norm_load:
            loads[r] = max_load
            efficiency_sum -= r.efficiency
            sum_load -= max_load * r.efficiency
            norm_load = sum_load / efficiency_sum
        else:
            loads[r] = norm_load

    max_load, r = max_loads[-1]
    loads[r] = norm_load
    return loads
</t>
<t tx="michael.20060619145551.94">def test_allocation(self, task, resource):
    effort = task.__dict__.get("effort")
    to_start = task._to_start
    to_end = task._to_end
    to_delta = task._to_delta

    if task.performed_end:
        start = to_start(max(task.performed_end,
                             task.root.calendar.now,
                             task.start))
    else:
        start = task.start
        if task.root.has_actual_data and task.complete == 0:
            start = max(start, to_start(task.root.calendar.now))

    base_start = to_start(task.performed_start or task.start)
    calc_load = lambda r: _calc_load(task, r)
    loads = map(lambda r: (r, calc_load(r)), resource)

    length = task.__dict__.get("length")
    duration = task.__dict__.get("duration")
    end = task.__dict__.get("end")

    &lt;&lt; correct length &gt;&gt;
    &lt;&lt; correct duration &gt;&gt;
    &lt;&lt; check end &gt;&gt;
    &lt;&lt; correct effort and (re)calculate length &gt;&gt;
    &lt;&lt; set adjust_date and delta &gt;&gt;

    # find the earliest start date
    start, book_load\
           = self.balance(task, start, delta, adjust_date,
                          calc_load, resource)

    end = to_end(start + delta)
    start = to_start(start)

    if effort is None:
        #length is frozen ==&gt; a new effort will be calculated
        factor = sum(map(lambda a: a[1], loads))
        length = end - start

        effort = to_delta(length * factor\
                          + task.performed_effort).round()

    return (end, book_load), resource, calc_load, start, effort
</t>
<t tx="michael.20060619145551.95">def allocate(self, task, state):
    # now really book the resource 
    end_bl, resource, calc_load, start, effort = state
    end = end_bl[0]
    cal = task.root.calendar
    to_start = task._to_start
    to_end = task._to_end
    to_delta = task._to_delta

    task.start = task.performed_start \
                 and to_start(task.performed_start) \
                 or to_start(start)

    task.end = end
    task._unfreeze("length")
    task._unfreeze("duration")
    length = end - start

    for r in resource:
        book_load = calc_load(r)
        work_time = to_delta(length * book_load).round()
        r.book_task(task, start, end, book_load, work_time, False)

    #the following lines are important to be exactly at this
    #positions in that order:
    # done and todo are dependend on:
    #    - the existence of effort (if effort was set or not set)
    #    - book_task (they can only be calculated, if the task is booked)
    #    - booked_resource (to get the booked tasks)
    task.booked_resource = resource
    task.done = task.done
    task.todo = task.todo
    task.length = end - task.start
    task.effort = to_delta(effort + task.performed_effort)
</t>
<t tx="michael.20060619145551.96">    #now effort exists always


def balance(self, task, start, delta, adjust_date,
            calc_load, resource):
    book_load = max(map(lambda r: r.get_load(task.start, task.scenario), resource))
    return start, book_load
</t>
<t tx="michael.20060619145551.97">

class SmartAllocator(StrictAllocator):
	@others
</t>
<t tx="michael.20060619145551.98">def balance(self, task, start, delta, adjust_date,
            calc_load, resource):
    #find the earliest start date, at which all
    #resources in the team are free

    cal = task.root.calendar
    to_start = task._to_start
    start = adjust_date(start)
    scenario = task.scenario

    while True:
        #we have finished, when all resources have the
        #same next free start date
        for r in resource:
            max_load = _calc_maxload(task, r)
            load = calc_load(r)

            #find the next free time of the resource
            s = r.find_free_time(start, delta, load, max_load, scenario)
            if s != start:
                s = to_start(s)
                start = adjust_date(s)
                break
        else:
            #only one resource
            break

    return start, 1.0
</t>
<t tx="michael.20060619145551.99">

class SloppyAllocator(AllocationAlgorithm):
	@others
</t>
<t tx="michael.20060619145551.100">def test_allocation(self, task, resource):
    if task.__dict__.has_key("effort"):
        return self.test_allocation_effort(task, resource)

    return self.test_allocation_length(task, resource)
</t>
<t tx="michael.20060619145551.101">def test_allocation_length(self, task, resource):
    #length is frozen ==&gt; effort will be calculated
    to_start = task._to_start
    to_end = task._to_end
    to_delta = task._to_delta

    end = task.end
    if task.performed_end:
        start = to_start(max(task.performed_end,
                             task.root.calendar.now,
                             start))
    else:
        start = task.start

    base_start = to_start(task.performed_start or task.start)
    length = to_delta(max(task.length - (start - base_start), 0))
    sum_effort = 0
    intervals = []
    scenario = task.scenario
    for r in resource:
        date = start
        max_load = _calc_maxload(task, r)
        book_load = _calc_load(task, r)

        while date &lt; end:
            #find free time intervals and add them for booking
            endi, load = r.end_of_booking_interval(date, task)
            endi = min(endi, end)
            endi = to_end(endi)

            if book_load &lt;= 0:
                #variable book_load ==&gt; calc the maxmimal possible book_load &gt;= (the given book_load)
                used_book_load = - book_load
                diff_load = max_load - load
                if diff_load and diff_load &gt;= book_load:
                    used_book_load = diff_load
                else:
                    used_book_load = max_load
            else:
                used_book_load = book_load

            if max_load - load &gt;= used_book_load:
                intervals.append((r, used_book_load, date, endi))
                sum_effort = (endi - date) * used_book_load

            date = to_start(endi)

    return -sum_effort, end, resource, intervals
</t>
<t tx="michael.20060619145551.102">def test_allocation_effort(self, task, resource):
    #effort is frozen ==&gt; length will be calculated

    to_start = task._to_start
    to_end = task._to_end
    to_delta = task._to_delta

    intervals = []
    effort = task.__dict__.get("effort")

    if task.performed_end:
        next_date = to_start(max(task.performed_end,
                                 task.root.calendar.now,
                                 task.start))
    else:
        next_date = task.start
        if task.root.has_actual_data and task.complete == 0:
            next_date = max(next_date, to_start(task.root.calendar.now))

    #walks chronologicly through the booking
    #intervals of each resource, and reduces
    #the effort for each free interval
    #until it becomes 0

    alloc_effort = effort
    effort -= task.performed_effort
    while effort &gt; 0:
        date = next_date

        interval_resource = []
        interval_end = to_start(sys.maxint)
        factor = 0

        for r in resource:
            max_load = _calc_maxload(task, r)
            book_load = _calc_load(task, r)
            end, load = r.end_of_booking_interval(date, task)
            interval_end = to_start(min(end, interval_end))

            if book_load &lt;= 0:
                #variable book_load ==&gt; calc the maxmimal possible book_load &gt;= (the given book_load)
                book_load = - book_load
                diff_load = max_load - load
                if diff_load and diff_load &gt;= book_load:
                    book_load = diff_load
                else:
                    book_load = max_load

            if book_load + load &lt;= max_load:
                resource_factor = book_load * r.efficiency
                interval_resource.append((r, book_load, resource_factor))
                factor += resource_factor



        next_date = interval_end
        if factor:
            factor *= task.efficiency
            length = to_delta(effort / factor).round()
            end = date + length

            if interval_end &gt;= end:
                next_date = interval_end = end
                effort = 0
                book_end = end
            else:
                book_end = interval_end
                length = book_end - date
                minus_effort = length * factor
                effort -= minus_effort

            book_end = to_end(book_end)
            intervals.append((date, book_end, length, interval_resource))

    return next_date, alloc_effort, resource, intervals
</t>
<t tx="michael.20060619145551.103">def allocate(self, task, state):
    if task.__dict__.has_key("effort"): self.allocate_effort(task, state)
    else: self.allocate_length(task, state)
</t>
<t tx="michael.20060619145551.104">def allocate_length(self, task, state):
    # now really book the resource
    neg_sum_effort, end, resource, intervals = state

    cal = task.root.calendar
    to_start = task._to_start
    to_end = task._to_end
    to_delta = task._to_delta

    task.start = to_start(task.performed_start or task.start)
    task.end = to_end(end)
    task._unfreeze("length")
    task._unfreeze("duration")

    effort = 0
    for r, load, s, e in intervals:
        work_time = to_delta((e - s) * load).round()
        effort += work_time
        r.book_task(task, s, e, load, work_time, False)

    #see comment at StrictAllocator.allocate
    task.booked_resource = resource
    task.done = task.done
    task.todo = task.todo
    task.effort = to_delta(effort + task.performed_effort).round()
</t>
<t tx="michael.20060619145551.105">def allocate_effort(self, task, state):
    # now really book the resource
    end, effort, resource, intervals = state
    to_start = task._to_start
    to_end = task._to_end
    to_delta = task._to_delta

    task.start = task.performed_start \
                 and to_start(task.performed_start) \
                 or to_start(intervals[0][0])
    task.end = to_end(end)
    task._unfreeze("length")
    task._unfreeze("duration")

    for start, end, length, resources in intervals:
        for r, load, factor in resources:
            work_time = to_delta(length * load)
            r.book_task(task, start, end, load, work_time, False)

    task.booked_resource = resource
    task.done = task.done
    task.todo = task.todo
    task.effort = to_delta(effort)
    task.length = task.end - task.start
</t>
<t tx="michael.20060619145551.106">def _split_path(path):
    try:
        index = path.rindex(".")
        return path[:index], path[index + 1:]
    except:
        return path
</t>
<t tx="michael.20060619145551.107">def Multi(val, **kwargs):
    """returns a directory for mutlivalued attributes"""
    return dict(_default=val, **kwargs)</t>
<t tx="michael.20060619145551.108">def _get_tasks_of_sources(task, attrib_filter="end,start,effort,length,duration"):
    #return all source tasks, this task is dependend on

    dep_tasks = {}

    while task:
        for dep in task._sources.values():
            for d in dep:
                path, attrib = _split_path(d)
                if attrib and attrib_filter.find(attrib) &gt;= 0:
                    dep_tasks[path] = True

        task = task.up

    return dep_tasks.keys()
</t>
<t tx="michael.20060619145551.109">def _build_balancing_list(tasks):
    """
    Returns a specialy sorted list of tasks.
    If the tasks will allocate resources in the sorting order of that list
    correct balancing is ensured
    """

    # first sort the list for attributes
    index = 0
    balancing_list = [(-t.priority, t.balance, index, t) for index, t in enumerate(tasks)]
    balancing_list.sort()

    #print
    #for p, b, i, t  in balancing_list:
    #    print p, b, i, t.path

    balancing_list = [ t for p, b, i, t  in balancing_list ]

    #now correct the presorted list:
    #if task a is dependent on task b, b will be moved before a

    done_map = { }
    count = len(balancing_list)
    while len(done_map) &lt; count:
        for i in range(count):
            to_inspect = balancing_list[i]
            if done_map.has_key(to_inspect): 
                continue

            done_map[to_inspect] = True
            break
        else:
            break

        &lt;&lt; define inspect_depends_on &gt;&gt;
        for j in range(i + 1, count):
            check_task = balancing_list[j]
            if done_map.has_key(check_task):
                continue

            if inspect_depends_on(check_task):
                del balancing_list[j]
                balancing_list.insert(i, check_task)
                i += 1 # to_inspect is now at i + 1


    return balancing_list
</t>
<t tx="michael.20060619145551.110">def _as_string(val):
    if isinstance(val, basestring):
        return '"""%s"""' % val.replace("\n", "\\n")

    if isinstance(val, pcalendar._WorkingDateBase):
        return '"%s"' % val.strftime("%Y-%m-%d %H:%M")

    if isinstance(val, datetime.datetime):
        return '"%s"' % val.strftime("%Y-%m-%d %H:%M")

    if isinstance(val, datetime.timedelta):
        return '"%id %iM"' % (val.days, val.seconds / 60)

    if isinstance(val, tuple):
        result = map(_as_string, val)
        return "(%s)" % ", ".join(result)

    if isinstance(val, list):
        result = map(_as_string, val)
        return "[%s]" % ", ".join(result)

    if isinstance(val, resource.Resource):
        return val._as_string()

    if isinstance(val, Task):
        return val.path

    return str(val)
</t>
<t tx="michael.20060619145551.111">def _step_tasks(task):
    if isinstance(task, Task):
        yield task

    stack = [iter(task.children)]
    while stack:
        for task in stack[-1]:
            yield task

            if task.children:
                stack.append(iter(task.children))
                break
        else:
            stack.pop()
</t>
<t tx="michael.20060619145551.115">def YearlyMax(value):
    """
    Calculates a load parameter with a maximal yearly workload
    """
    &lt;&lt; calculate calendar and time_diff &gt;&gt;
    return float(time_diff) / \
            (cal.working_days_per_year \
             * cal.working_hours_per_day \
             * 60)</t>
<t tx="michael.20060619145551.117">def WeeklyMax(value):
    """
    Calculates a load parameter with a maximal weekly workload
    """
    &lt;&lt; calculate calendar and time_diff &gt;&gt;
    return float(time_diff) / \
            (cal.working_days_per_week \
             * cal.working_hours_per_day \
             * 60)

</t>
<t tx="michael.20060619145551.119">def MonthlyMax(value):
    """
    Calculates a load parameter with a maximal monthly workload
    """
    &lt;&lt; calculate calendar and time_diff &gt;&gt;
    return float(time_diff) / \
            (cal.working_days_per_month \
             * cal.working_hours_per_day \
             * 60)

</t>
<t tx="michael.20060619145551.121">def DailyMax(value):
    """
    Calculates a load parameter with a maximal daily workload
    """
    &lt;&lt; calculate calendar and time_diff &gt;&gt;
    return float(time_diff) / (cal.working_hours_per_day * 60)
</t>
<t tx="michael.20060619145551.123">class _TaskProperty(object):
	@others
</t>
<t tx="michael.20060619145551.124">def __init__(self, method):
    self.method = method
</t>
<t tx="michael.20060619145551.125">def __get__(self, instance, owner):
    if not instance:
        return None

    return instance._wrap_attrib(self.method)
</t>
<t tx="michael.20060619145551.126">class _RoundingTaskProperty(object):
	@others
</t>
<t tx="michael.20060619145551.127">def __init__(self, method, name):
    self.method = method
    self.name = name
</t>
<t tx="michael.20060619145551.128">def __get__(self, instance, owner):
    if not instance:
        return None

    result = instance._wrap_attrib(self.method).round()
    if instance._is_frozen:
        #correct the attrib to the rounded value
        setattr(instance, self.name, result)

    return result
</t>
<t tx="michael.20060619145551.129">class Task(object):
    &lt;&lt; description &gt;&gt;
	&lt;&lt; declarations &gt;&gt;
	@others</t>
<t tx="michael.20060619145551.130"># Variables for the gui interface
_date_completion = { "Date": 'Date("|")',
                     "max": "max(|)",
                     "min": "min(|)",
                     "Multi" : "Multi(|)" }


_delta_completion = { "Delta" : 'Delta("|")',
                      "Multi" : "Multi(|)" }


__attrib_completions__ = { \
    "def NewTask():" : "def |NewTask():\n",
    "milestone": 'milestone = True',
    "start": 'start = ',
    "end": 'end = ',
    "effort": 'effort = "|"',
    "duration": 'duration = "|"',
    "length": 'length = "|"',
    "todo": 'todo = "|"',
    "done": 'done = "|"',
    "title": 'title = "|"',
    "load": 'load = ',
    "max_load": 'max_load = ',
    "efficiency": 'efficiency = ',
    "complete": 'complete = ',
    "copy_src": 'copy_src =',
    "__constraint__": '__constraint__():\n|"',
    "priority": 'priority = ',
    "balance" : 'balance = ',
    "resource": 'resource = ',
    "performed"  : 'performed = [(|resource, "2002-02-01", "2002-02-05", "2H"),]',
    "add_attrib": "add_attrib(|'name', None)",
    "working_days_per_week": 'working_days_per_week = ',
    "working_days_per_month": 'working_days_per_month = ',
    "working_days_per_year": 'working_days_per_year = ',
    "working_hours_per_day": 'working_hours_per_day = ',
    "minimum_time_unit": 'minimum_time_unit = ',
    "vacation": 'vacation = [("|2002-02-01", "2002-02-05")]',
    "extra_work": 'extra_work = [("|2002-02-01", "2002-02-05")]',
    "working_days" : 'working_days = ["|mon,tue,wed,thu,fri", "8:00-12:00", "13:00-17:00"]',
    "now": 'now = "|"',
    "calendar" : 'calendar = ',
    "#load": { "YearlyMax": 'YearlyMax("|")',
               "WeeklyMax": 'WeeklyMax("|")',
               "MonthlyMax": 'MonthlyMax("|")',
               "DailyMax": 'DailyMax("|")',
               "VariableLoad" : "VariableLoad(|)"},
    "#max_load": { "YearlyMax": 'YearlyMax("|")',
                   "WeeklyMax": 'WeeklyMax("|")',
                   "MonthlyMax": 'MonthlyMax("|")',
                   "DailyMax": 'DailyMax("|")' },
    "#start": _date_completion,
    "#end": _date_completion,
    "#effort": _delta_completion,
    "#duration": _delta_completion,
    "#length": _delta_completion,
    "#todo": _delta_completion,
    "#done": _delta_completion,
    "#resource" : "get_resource_completions", 
    "#calendar" : "get_calendar_completions",
    "#balance": { "STRICT": "STRICT",
                  "SMART": "SMART",
                  "SLOPPY": "SLOPPY" } }


formats = { "start" : "%x %H:%M",
            "end"  : "%x %H:%M",
            "performed_start" : "%x %H:%M",
            "performed_end" : "%x %H:%M",
            "load" : "%.2f",
            "length" : "%dd{ %HH}{ %MM}",
            "effort" : "%dd{ %HH}{ %MM}",
            "estimated_effort" : "%dd{ %HH}{ %MM}",
            "performed_effort" : "%dd{ %HH}{ %MM}",
            "duration" : "%dd{ %HH}{ %MM}",
            "complete" : "%i",
            "priority" : "%i",
            "todo" : "%dd{ %HH}{ %MM}",
            "done" : "%dd{ %HH}{ %MM}",
            "efficiency" : "%.2f",
            "buffer" : "%dd{ %HH}{ %MM}",
            "costs" : "%.2f",
            "sum" : "%.2f",
            "max" : "%.2f",
            "min" : "%.2f",
            "milestone" : "%s",
            "resource" : "%s",
            "booked_resource" : "%s",
            "performed_resource" : "%s" }

_constraint = None
_is_frozen = False
_is_compiled = False
_is_parent_referer = False

scenario = None # only for autocompletion
milestone = False
performed = ()
performed_resource = ()
booked_resource = ()
_performed_resource_length = ()
_resource_length = ()
dont_inherit = ()
performed_start = None
performed_end = None
performed_work_time = pcalendar.Minutes(0)

_setting_hooks = {}</t>
<t tx="michael.20060619145551.131">def __init__(self, func, name, parent=None, index=1):
    assert(type(func) == types.FunctionType)

    func_key = (func.func_code, func.func_closure and id(func.func_closure))

    try:
        instrumented = instrumentation_cache[func_key]
    except KeyError:
        instrumented = _instrument(func)
        instrumented.org_code = func_key
        instrumentation_cache[func_key] = instrumented

    func.task_func = instrumented # will be used in the gui        
    self._function = instrumented
    self.name = name
    self.up = parent
    self.children = []
    self._sources = {} # all tasks, I am linked to
    self._dependencies = {} # all tasks that link to me
    self._original_values = {}
    self._properties = {} # a registry of all non standard attributes
    self.title = self.name
    self.root = parent and parent.root or self
    self.scenario = self.root.scenario
    self.path = parent and parent.path + "." + name or name
    self.depth = len(self.path.split(".")) - 1
    self.index = parent and ("%s.%i" % (parent.index, index)) \
                 or str(index)
    if self.formats.has_key(name):
        raise AttributeError("Task name '%s' hides attribute of parent." \
                             % name)

    cal = self.calendar
    self._to_delta = cal.Minutes
    self._to_start = cal.StartDate
    self._to_end = cal.EndDate

</t>
<t tx="michael.20060619145551.132">def __iter__(self):
    return _step_tasks(self)
</t>
<t tx="michael.20060619145551.133">def __repr__(self):
    return "&lt;Task %s&gt;" % self.name
</t>
<t tx="michael.20060619145551.134">def __cmp__(self, other):
    try:
        return cmp(self.path, other.path)
    except Exception:
        return cmp(self.path, other)
</t>
<t tx="michael.20060619145551.135">def _idendity_(self): return self.root.id + self.path[4:]
</t>
<t tx="michael.20060619145551.136">def to_string(self): return _StringConverter(self)
to_string = property(to_string)</t>
<t tx="michael.20060619145551.137">def indent_name(self, ident="    "):
    """
    returns a indented name, according to its depth in the hierachy.
    """

    return ident * self.depth + self.name

indent_name.attrib_method = True
indent_name.__call_completion__ = "indent_name()"
</t>
<t tx="michael.20060619145551.138">def costs(self, cost_name, mode="ep"):
    """
    calculates the resource costs for the task.
    cost_name is the name of a rate attribute of the reosurce
    mode is character combination:
              e calculates the estimated costs
              p calculates the performed costs
              ==&gt; pe calculates all costs
    """

    if self.children:
        return sum([ c.costs(cost_name, mode) for c in self.children])

    costs = 0
    if 'e' in mode:
        costs += sum(map(lambda rl: getattr(rl[0], cost_name) * rl[1],
                         self._resource_length))

    if 'p' in mode:
        costs += sum(map(lambda rl: getattr(rl[0], cost_name) * rl[1],
                         self._performed_resource_length))

    costs /= (60.0 * self.root.calendar.working_hours_per_day)
    return round(costs, 2)

costs.attrib_method = True
costs.__call_completion__ = 'costs("|")'
</t>
<t tx="michael.20060619145551.139">def sum(self, attrib_name):
    val = 0

    if self.children:
        val += sum(map(lambda c: c.sum(attrib_name), self.children))
        if self.is_inherited(attrib_name):
            return val

        if attrib_name not in self.dont_inherit:
            return val

    return val + getattr(self, attrib_name)

sum.attrib_method = True
sum.__call_completion__ = 'sum("|")'

</t>
<t tx="michael.20060619145551.140">def min(self, attrib_name):
    if self.children:
        return min(map(lambda c: c.min(attrib_name), self.children))

    return getattr(self, attrib_name)

min.attrib_method = True
min.__call_completion__ = 'min("|")'

</t>
<t tx="michael.20060619145551.141">def max(self, attrib_name):
    if self.children:
        return max(map(lambda c: c.max(attrib_name), self.children))

    return getattr(self, attrib_name)

max.attrib_method = True
max.__call_completion__ = 'max("|")'

</t>
<t tx="michael.20060619145551.142">def is_inherited(self, attrib_name):
    return not self.__dict__.has_key(attrib_name)
</t>
<t tx="michael.20060619145551.143">def formatter(self, attrib_name, arg=None, format=None):
    """returns a function which is able
    to convert the value of the given attrib_name to a string"""

    formats = self.formats
    format = format or formats.get(attrib_name)

    if attrib_name in ("start", "end", "length", "effort",
                       "done", "todo", "buffer", "estimated_effort",
                       "performed_effort", "performed_start", "performed_end"):
        def save_strftime(v):
            try:
                return v.strftime(format)
            #except AttributeError: some bug avoid catching this exception
            except Exception:
                return str(v)

        return save_strftime

    if attrib_name == "duration":
        def save_strftime(v):
            try:
                return v.strftime(format, True)
            except AttributeError:
                return str(v)

        return save_strftime

    if attrib_name in ("booked_resource", "performed_resource"):
        def get_resource_name(v):
            title = getattr(v, "title", None)
            if title: return title
            return ", ".join([r.title for r in v])
        return get_resource_name

    if arg and attrib_name in ("costs", "sum", "max", "min"):
        format = formats.get("%s(%s)" % (attrib_name, arg), format)

    if format:
        return lambda v: locale.format(format, v, True)

    return str
</t>
<t tx="michael.20060619145551.144">def all_resources(self):
    result = self._all_resources_as_dict()
    result = result.keys()
    result.sort()
    return result
</t>
<t tx="michael.20060619145551.145">def _unfreeze(self, attrib_name):
    if self.__dict__.has_key(attrib_name):
        del self.__dict__[attrib_name]
</t>
<t tx="michael.20060619145551.146">def _all_resources_as_dict(self):
    if self.children:
        result = {}
        for c in self.children:
            result.update(c._all_resources_as_dict())

        return result

    if self.resource:
        return dict(map(lambda r: (r, 1), self.resource.all_members()))

    return {}
</t>
<t tx="michael.20060619145551.147">def _iter_booked_resources(self):
    result = dict(map(lambda r: (r, 1), self.performed_resource))
    result.update(dict(map(lambda r: (r, 1), self.booked_resource)))
    return result.iterkeys()
</t>
<t tx="michael.20060619145551.148">def get_task(self, path=None):
    """
    Returns a task with the given path.
    """

    if not path:
        return self

    names = path.split(".")
    rest = ".".join(names[1:])
    result = getattr(self, names[0], None)
    return isinstance(result, Task) and result.get_task(rest) or None
</t>
<t tx="michael.20060619145551.149">def check(self):
    if self._constraint and self._is_compiled:
        globals_ = self._function.func_globals
        globals_["me"] = self
        globals_["up"] = self.up
        globals_["root"] = self.root
        globals_["assert_"] = self.__assert
        self._constraint()
</t>
<t tx="michael.20060619145551.150">def snapshot(self, indent="", name=None):
    text = indent + "def %s():\n" % (name or self.name)
    indent += "    "
    for name in ("priority", "balance", "complete",
                 "milestone", "end", "start", "effort", "load"):
        val = getattr(self, name, None)
        if val is None:
            continue

        if name[0] == "_":
            name = name[1:]

        text += "%s%s = %s\n" % (indent, name, _as_string(val))

    for name in self._properties:
        if name.startswith("performed"): continue
        val = getattr(self, name, None)
        try:
            if issubclass(val, resource.Resource): continue
        except TypeError:
            pass
        text += "%s%s = %s\n" % (indent, name, _as_string(val))

    resources = tuple(self._iter_booked_resources())
    if resources:
        text += "%sresource = \\\n" % indent
        def make_resource(res):
            return "%s    %s" \
                   % (indent, res.snapshot())

        text += "&amp;\\\n".join(map(make_resource, resources)) + "\n"

        def make_resource_booking(res):
            def make_booking(booking):
                return '%s    (%s, "%s", "%s", "%sM"),' \
                       % (indent, res.name,
                          booking.book_start.strftime("%Y%m%d %H:%M"),
                          booking.book_end.strftime("%Y%m%d %H:%M"),
                          booking.work_time)

            return "\n".join(map(make_booking, res.get_bookings(self)))


        text += "%sperformed = [\n" % indent
        text += "\n".join(map(make_resource_booking, resources)) + "]"


    child_text = map(lambda c: c.snapshot(indent), self.children)
    text += "\n\n"
    text += "".join(child_text)

    return text
</t>
<t tx="michael.20060619145551.151">def _test_allocation(self, resource_state, allocator):
    resource = self.resource._get_resources(resource_state)
    if not resource:
        return False

    return allocator.test_allocation(self, resource)
</t>
<t tx="michael.20060619145551.152">def _allocate(self, state, allocator):
    allocator.allocate(self, state)
    #activate cache for done and todo

    if self.start.to_datetime() &gt; self.end.to_datetime():
        #this can happen when performed effort are
        #during non working time
        tmp = self.start
        self.start = self.end
        self.end = tmp

    for r in self.performed_resource:
        r.correct_bookings(self)

    self._resource_length = map(lambda r: (weakref.proxy(r), \
                                           r.length_of(self)),
                                self._iter_booked_resources())
</t>
<t tx="michael.20060619145551.153">def _generate(self, deferred=None):
    do_raise = False
    deferred = deferred or [ self ]
    while deferred:
        new_deferred = []
        for task in deferred:
            task._compile(new_deferred, do_raise)

        do_raise = deferred == new_deferred
        deferred = new_deferred
</t>
<t tx="michael.20060619145551.154">def _recalc_properties(self):
    if not self._properties: return
    self.__compile_function([], False, _MeProxyRecalc(self))
    self._is_compiled = True
</t>
<t tx="michael.20060619145551.155">def _compile(self, deferred, do_raise):
    self.dont_inherit = ()
    self._constraint = None
    self._original_values.clear()
    self._properties.clear()

    try:
        self.__at_compile
        &lt;&lt; raise child recursion error &gt;&gt;
    except AttributeError:
        self.__at_compile = self, ""

    try:
        self.__compile_function(deferred, do_raise, _MeProxy(self))
    finally:
        del self.__at_compile

    for c in self.children:
        if not c._is_compiled:
            c._compile(deferred, do_raise)

    if self._is_compiled:
        self.__check_milestone()
        self.__check_task()
        self.root.has_actual_data |= self.__dict__.has_key("performed")

</t>
<t tx="michael.20060619145551.156">def __compile_function(self, deferred, do_raise, me_instance):
    self._is_compiled = self._is_frozen

    restore_globals = []
    globals_ = self._function.func_globals

    &lt;&lt; set function global values &gt;&gt;
    &lt;&lt; set me in global functions &gt;&gt;
    try:
        &lt;&lt; eval function &gt;&gt;
    finally:
        for fg in restore_globals:
            del fg["me"]

</t>
<t tx="michael.20060619145551.157">def __check_task(self):
    if self.children: return

    start = self._find_frozen("start")
    end = self._find_frozen("end")

    if not (start or end):
        self._raise(ValueError("You must specify either a"\
                               " start or an end attribute"))

    if start and end: return

    length = self.__dict__.get("length")
    duration = self.__dict__.get("duration")
    effort = self.__dict__.get("effort")
    if not (effort or length or duration):
        #set a default value
        self._set_effort("1d")
        #self._raise(ValueError("You must specify either a"\
        #                       " length or a duration or "\
        #                       "an effort attribute"))
</t>
<t tx="michael.20060619145551.158">def __check_milestone(self):
    if not self.milestone: return

    self.length = self._to_delta(0)
    start = self.__dict__.get("start")
    if not start:
        self._raise(ValueError("Milestone must have start attribute"),
                               "milstone")

    if self.__start_class.__name__ == "edt":
        #the milestone is probably dependent on the end date of
        #an other task (see edt in pcalendar) ==&gt; start at the end date
        self.start = self.end = self._to_end(self.start) 
    else:
        self.start = self.end = self._to_start(self.start)

</t>
<t tx="michael.20060619145551.159">def _set_attrib(self, name, value):
    if value is _NEVER_USED_: return

    try:
        value = self._setting_hooks[name](self, name, value)
    except KeyError: pass

    if name == "__constraint__":
        self._constraint = value
        return

    if type(value) == types.FunctionType:
        if value.func_code.co_argcount == 0:
            &lt;&lt; add child task &gt;&gt;

    if name[0] == "_":
        #private vars will not be set
        return

    if isinstance(value, _Path):
        value = value._task

    set_method = getattr(self, "_set_" + name, None)
    if set_method:
        &lt;&lt; set standard attribute &gt;&gt;
    else:
        &lt;&lt; set userdefined attribute &gt;&gt;
</t>
<t tx="michael.20060619145551.160">def _set_name(self, value):
    raise AttributeError("The attribute 'name' is readonly.")</t>
<t tx="michael.20060619145551.161">def _set_start(self, value):
    self.__start_class = value.__class__
    self.start = self._to_start(value).round()
</t>
<t tx="michael.20060619145551.162">def _set_end(self, value): 
    self.end = self._to_end(value)
</t>
<t tx="michael.20060619145551.163">def _set_max_load(self, max_load): 
    self.max_load = float(max_load)
</t>
<t tx="michael.20060619145551.164">def _set_load(self, load): 
    self.load = float(load)
</t>
<t tx="michael.20060619145551.165">def _set_length(self, value): 
    self.length = self._to_delta(value).round()
</t>
<t tx="michael.20060619145551.166">def _set_effort(self, value):
    self.effort = self._to_delta(value).round()
</t>
<t tx="michael.20060619145551.167">def _set_duration(self, value): 
    self.duration = self._to_delta(value, True).round()
</t>
<t tx="michael.20060619145551.168">def _set_complete(self, value): 
    self.complete = value
</t>
<t tx="michael.20060619145551.169">def _set_done(self, value): 
    self.done = self._to_delta(value).round()
</t>
<t tx="michael.20060619145551.170">def _set_todo(self, value): 
    self.todo = self._to_delta(value).round()
</t>
<t tx="michael.20060619145551.171">def _set_milestone(self, value): 
    self.milestone = value
</t>
<t tx="michael.20060619145551.172">def _set_resource(self, value):
    if not value: 
        self.resource = None
        return

    if isinstance(value, (tuple, list)):
        value = reduce(lambda a, b: a &amp; b, value)

    self.resource = value()
</t>
<t tx="michael.20060619145551.173">def _set_copy_src(self, value):
    if isinstance(value, _MeProxy):
        raise RuntimeError("Cannot copy me.")

    if not value._is_compiled:
        raise _IncompleteError(value, "copy_src")

    if value.resource and not self.resource:
        self.resource = value.resource

    if value.balance and not self.balance:
        self.balance = value.balance

    copy_parms = ("priority", "todo", "complete", 
                  "_constraint", "load", "length",
                  "effort", "duration")

    for p in copy_parms:
        v = value.__dict__.get(p)
        if v: setattr(self, p, v)

    self.copy_src = value
    self._properties.update(value._properties)
    for k in value._properties.iterkeys():
        setattr(self, k, getattr(value, k))
</t>
<t tx="michael.20060619145551.174">def _wrap_attrib(self, method):
    attrib_name = method.__name__[7:]
    recursion_attrib = "_rec" + attrib_name

    try:
        dest, dattr = self.__at_compile
        raise RecursionError("Recursive definition of %s(%s) and %s(%s)" \
                             % (self.path, attrib_name, dest.path, dattr))
    except AttributeError: pass

    if not self._is_compiled:
        raise _IncompleteError(self, attrib_name)

    try:
        getattr(self, recursion_attrib)
        raise RecursionError(self, attrib_name)
    except AttributeError: pass

    setattr(self, recursion_attrib, True)

    try:
        result = method(self)

        if self._is_frozen:
            setattr(self, attrib_name, result)

        return result
    finally:
        delattr(self, recursion_attrib)
</t>
<t tx="michael.20060619145551.175">def _find_frozen(self, attrib_name, default=None):
    value = self.__dict__.get(attrib_name)
    if value is not None:
        return value

    up = self.up
    return up and up._find_frozen(attrib_name) or default
</t>
<t tx="michael.20060619145551.177">def __calc_start(self):
    to_start = self._to_start

    if self.children:
        try:
            return min([ to_start(t.start) for t in self.children
                         if not t._is_parent_referer ])
        except ValueError:
            &lt;&lt; raise child recursion error &gt;&gt;

    try:
        end = self.end
        duration = self.__dict__.get("duration")
        if duration is not None:
            start = end.to_datetime() - datetime.timedelta(minutes=duration)
        else:
            start = end - self.length

        return to_start(start)

    except RecursionError:
        start = self._find_frozen("start")
        if start: return to_start(start)
        &lt;&lt; raise recursion error &gt;&gt;

start = _TaskProperty(__calc_start)

</t>
<t tx="michael.20060619145551.178">def __calc_end(self):
    to_end = self._to_end

    if self.children:
        try:
            return max([ to_end(t.end) for t in self.children
                         if not t._is_parent_referer ])
        except ValueError:
            &lt;&lt; raise child recursion error &gt;&gt;

    try:
        start = self.start
        duration = self.__dict__.get("duration")
        if duration is not None:
            end = start.to_datetime() + datetime.timedelta(minutes=duration)
        else:
            end = start + self.length

        return to_end(end)

    except RecursionError:
        end = self._find_frozen("end")
        if end: return to_end(end)
        &lt;&lt; raise recursion error &gt;&gt;


end = _TaskProperty(__calc_end)
</t>
<t tx="michael.20060619145551.179">def __calc_load(self):
    length = self.__dict__.get("length")
    effort = self.__dict__.get("effort")

    if length is not None and effort is not None:
        return float(effort) / (float(length) or 1.0)

    load = self._find_frozen("load")
    if load is not None: return load
    return 1.0

load = _TaskProperty(__calc_load)
</t>
<t tx="michael.20060619145551.180">def __calc_length(self):
    effort = self.__dict__.get("effort")
    if effort is None:
        return self.end - self.start

    return self._to_delta(effort / self.load)

length = _RoundingTaskProperty(__calc_length, "length")
</t>
<t tx="michael.20060619145551.181">def __calc_duration(self):
    return self._to_delta(self.end.to_datetime()\
                          - self.start.to_datetime(), True)

duration = _TaskProperty(__calc_duration)
</t>
<t tx="michael.20060619145551.182">def __calc_effort(self):
    if self.children:
        return self._to_delta(sum([ t.effort for t in self.children ]))

    return self._to_delta(self.length * self.load)

effort = _RoundingTaskProperty(__calc_effort, "effort")
</t>
<t tx="michael.20060619145551.183">def __calc_done(self):
    if self.children:
        dones = map(lambda t: t.done, self.children)
        return self._to_delta(sum(dones))

    res = self._iter_booked_resources()
    done = sum(map(lambda r: r.done_of(self), res))

    complete = self.__dict__.get("complete")
    todo = self.__dict__.get("todo")

    if not done and complete == 100 or todo == 0:
        #if now is not set
        done = self.effort

    return self._to_delta(done)

done = _TaskProperty(__calc_done)
</t>
<t tx="michael.20060619145551.184">def __calc_buffer(self):
    if self.children:
        return self._to_delta(min(map(lambda t: t.buffer, self.children)))

    scenario = self.scenario
    end = self.end
    old_end = self.__dict__.get("end")

    &lt;&lt; find all tasks, that depend on my end &gt;&gt;

    &lt;&lt; define unfreeze_parents &gt;&gt;

    buffers = [ ]
    for d in deps.keys():
        path, attrib = _split_path(d)
        if attrib != "start":
            continue

        &lt;&lt; calculate buffer to descendant 'd' &gt;&gt;

        buffers.append(buffer_)
        if not buffer_:
            break

    if buffers:
        return self._to_delta(min(buffers))

    return not self.milestone \
           and self.root.end - end \
           or self._to_delta(0)

buffer = _TaskProperty(__calc_buffer)
</t>
<t tx="michael.20060619145551.185">def __calc_complete(self):
    done = self.done
    todo = self.todo
    return int(100.0 * done / ((done + todo) or 1))

complete = _TaskProperty(__calc_complete)
</t>
<t tx="michael.20060619145551.186">def __calc_todo(self):
    complete = self.__dict__.get("complete")
    if complete:
        # effort = done + todo
        #             done               done
        # complete = ------ ==&gt; todo = -------- - done
        #            effort            complete
        complete = float(complete)
        done = self.done
        if done:
            done = float(done)
            return self._to_delta(done * 100.0 / complete - done)
        return self._to_delta(self.effort * complete / 100.0)

    if self.children:
        todos = map(lambda t: t.todo, self.children)
        return self._to_delta(sum(todos))

    todo = sum(map(lambda r: r.todo_of(self), self.booked_resource))
    return self._to_delta(max(todo, self.effort - self.done))

todo = _TaskProperty(__calc_todo)
</t>
<t tx="michael.20060619145551.187">def _convert_performed(self, all_resources):
    performed = self.performed
    if not performed: return False

    if not isinstance(performed, (tuple, list)) \
       or not isinstance(performed[0], (tuple, list)) \
       or not len(performed[0]) &gt;= 3:
        self._raise(TypeError("""The format of the performed attribute must be:
[( res_name, start_literal, end_literal, working_time ),  ... ].
"""), "performed")

    round_down_delta = self.root.calendar.minimum_time_unit / 2
    round_down_delta = datetime.timedelta(minutes=round_down_delta)

    def convert_item(index):
        item = performed[index]
        res, start, end = item[:3]
        if isinstance(res, str):
            found = filter(lambda r: r.name == res, all_resources)
            if found: res = found[0]

        try:
            if not isinstance(res, (resource.Resource,
                                    resource._MetaResource)):
                raise ValueError("the resource '%s' is unknown." %  res)

            start = _to_datetime(start)
            end = _to_datetime(end)

            if len(item) &gt; 3:
                working_time = self._to_delta(item[3]).round()
            else:
                working_time = self._to_delta(end - start, True)

            return ((res, start, end, working_time), index)
        except Exception, exc:
            self._raise(exc.__class__("Item %i: %s" \
                                      % (index + 1, str(exc))),
                        "performed")

    converted = dict(map(convert_item, range(len(performed))))
    converted = converted.items()
    converted.sort()

    #check for overlapping items
    last_res = None
    for item, index in converted:
        res, start, end, work_time = item
        if last_res == res and start &lt; last_end:
            self._warn("Items %i, %i:  %s and %s are overlapping." \
                       % (last_index + 1, index + 1,
                          str(performed[last_index]),
                          str(performed[index])),
                       "performed")

        last_res = res
        last_end = end
        last_index = index

    self._performed = map(lambda x: x[0], converted)
    return True
</t>
<t tx="michael.20060619145551.188">def _allocate_performed(self, performed):
    if not performed: return

    to_delta = self._to_delta
    to_start = self._to_start
    to_end = self._to_end

    last = datetime.datetime.min
    first = datetime.datetime.max
    effort = 0
    work_time_sum = 0
    zero_minutes = to_delta(0)
    minimum_time_unit = to_delta(self.calendar.minimum_time_unit)
    summary = {}

    for item in performed:
        res, start, end, work_time = item
        effort += work_time * self.efficiency * res.efficiency
        work_time_sum += work_time

        res = res()
        ss, es, wts = summary.get(res, (datetime.datetime.max,
                                        datetime.datetime.min,
                                        zero_minutes))
        summary[res] = (min(ss, start), max(es, end), wts + work_time)

    for r, v in summary.iteritems():
        start, end, work_time = v
        assert(start.__class__ is datetime.datetime)
        assert(end.__class__ is datetime.datetime)

        #the booking limits should be inside the workingtime
        #to display them correct in resource charts
        cstart = to_start(start).to_datetime()
        if cstart &gt; start: cstart = to_end(start).to_datetime()

        cend = to_end(end).to_datetime()
        if cend &lt; end: cend = to_start(end).to_datetime()

        if self.root.is_snapshot:
            delta = to_end(cend) - to_start(cstart)
        else:
            delta = to_delta(cend - cstart).round()

        if not delta:
            delta = minimum_time_unit

        book_load = float(work_time) / delta
        r().book_task(self, cstart, cend, book_load, work_time, True)
        last = max(end, last)
        first = min(start, first)

    self._performed_resource_length = tuple([ (r, v[2]) for r, v in summary.iteritems() ])
    self.performed_resource = tuple(summary.keys())
    self.performed_end = last
    self.performed_start = first
    self.performed_effort = to_delta(effort)
    self.performed_work_time = to_delta(work_time_sum)
    self._check_completion()
</t>
<t tx="michael.20060619145551.189">def _check_completion(self):
    if not self.performed_effort: return
    if self.root.is_snapshot: return

    # allocation is not done yet ==&gt; self.todo, self.done,
    # self.complete cannot be calculated
    if self._find_frozen("complete", 0) &lt; 100 \
           and self.__dict__.get("todo", 1) &gt; 0:
        return

    start = self.performed_start
    end = self.performed_end
    #ensure that self.start.to_datetime() &lt; self.end.to_datetime()
    cstart = self._to_start(start)
    if cstart.to_datetime() &gt; start: cstart = self._to_end(start)

    cend = self._to_end(end)
    if cend.to_datetime() &lt; end: cend = self._to_start(end)

    self.start = cstart
    self.end = cend

    if self.performed_effort != self.effort:
        self.estimated_effort = self.effort                       
        self.effort = self.performed_effort
</t>
<t tx="michael.20060619145551.190">def __assert(self, value):
    if not value:
        warnings.warn('assertion in scenario: "%s"' % self.scenario,
                      RuntimeWarning, 2)
</t>
<t tx="michael.20060619145551.191">def __set_sources(self, attrib_name, value):
    &lt;&lt; find references &gt;&gt;
    if not sources: return

    #track only dependcies within the same project
    root = self.root
    sources = [ task.path + "." + attrib
                for task, attrib in sources
                if task and task.root is root ] 
    self._sources[attrib_name] = tuple(sources)
    attr_path = self.path + "." + attrib_name

    #set dependencies of my sources
    for d in sources:
        path, attrib = _split_path(d)
        task = self.get_task(path)
        r_d = task._dependencies
        d_l = r_d.setdefault(attrib, {})
        d_l[attr_path] = True
</t>
<t tx="michael.20060619145551.192">def _warn(self, message, attrib=None, level=2):
    self.__compile_function([], True, _MeProxyWarn(self, attrib, message))
</t>
<t tx="michael.20060619145551.193">def _raise(self, exc, attrib=None):
    self.__compile_function([], True, _MeProxyError(self, attrib, exc))
    raise exc
</t>
<t tx="michael.20060619145551.194">def __getattr__(self, name):
    try:
        if name[0] != "_":
            parent = self.up
            while parent:
                if name not in parent.dont_inherit:
                    result = getattr(parent, name)
                    if not (isinstance(result, Task) and result.up == parent):
                        return result

                parent = parent.up
    except AttributeError:
        pass
    except IndexError:
        raise AttributeError()

    exception = AttributeError("'%s' is not a valid attribute of '%s'"
                               % (name, self.path))
    exception.is_frozen = self._is_frozen
    raise exception
</t>
<t tx="michael.20060619145551.195">class _ProjectBase(Task):
    """
    Base class for all projects.
    """
	&lt;&lt; class _ProjectBase declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619145551.196">__attrib_completions__ = { }
__attrib_completions__.update(Task.__attrib_completions__)
del __attrib_completions__["milestone"] #project cannot be milestones

priority = 500    
efficiency = 1.0
max_load = 1.0
balance = 0
resource = None
copy_src = None
has_actual_data = False
is_snapshot = False

</t>
<t tx="michael.20060619145551.197">def __init__(self, top_task, scenario="_default", id=""):
    self.calendar = pcalendar.Calendar()        
    Task.__init__(self, top_task, top_task.func_name)
    self.id = id or self.name
    self.scenario = scenario
    self.all_scenarios = set(("_default",))
    self.path = "root"
    self._globals = top_task.func_globals.copy()
    self._generate()

</t>
<t tx="michael.20060619145551.198">def _idendity_(self): return self.id
</t>
<t tx="michael.20060619145551.200">def __renew_dates(self):
    for attrib in ("effort", "start", "end", "length", "todo"):
        try:
            self._set_attrib(attrib, self._original_values[attrib])
        except KeyError:
            pass

</t>
<t tx="michael.20060619145551.201">def free(self):
    all_resources = self.all_resources()
    for r in all_resources:
        r().unbook_tasks_of_project(self.id, self.scenario)

    for t in self:
        t.booked_resource = ()

    return all_resources
</t>
<t tx="michael.20060619145551.202">def _get_balancing_list(self):

    try:
        cached_list = balancing_cache[self._function.org_code]
        if len(cached_list) != len(tuple(self)): 
            # different scenarios can have different tasks
            raise KeyError()

    except KeyError:
        cached_list = _build_balancing_list(self)
        balancing_cache[self._function.org_code] = cached_list
    else:
        cached_list = [ self.get_task(t.path) for t in cached_list ]

    return cached_list
</t>
<t tx="michael.20060619145551.204">def _set_vacation(self, value):
    self.__make_calendar()
    self.calendar.set_vacation(value)
    self._properties["vacation"] = True
    self.vacation = value
    self.__renew_dates()
</t>
<t tx="michael.20060619145551.205">def _set_extra_work(self, value):
    self.__make_calendar()
    self.calendar.set_extra_work(value)
    self._properties["extra_work"] = True
    self.extra_work = value
    self.__renew_dates()
</t>
<t tx="michael.20060619145551.206">def _set_working_days(self, value):
    if type(value[0]) is str:
        value = (value, )

    self.working_days = value
    self._properties["working_days"] = True
    self.__make_calendar()

    for v in value:
        day_range = v[0]
        tranges = tuple(v[1:])
        self.calendar.set_working_days(day_range, *tranges)

    self.__renew_dates()</t>
<t tx="michael.20060619145551.207">def _set_now(self, value):
    proxy = weakref.proxy
    self.calendar.now = _to_datetime(value)
</t>
<t tx="michael.20060619145551.208">def _set_minimum_time_unit(self, value):
    self.__make_calendar()
    self.calendar.minimum_time_unit = value
    self._properties["minimum_time_unit"] = True
</t>
<t tx="michael.20060619145551.209">def _get_minimum_time_unit(self):
    return self.calendar.minimum_time_unit

minimum_time_unit = property(_get_minimum_time_unit)
</t>
<t tx="michael.20060619145551.210">def _set_working_days_per_week(self, value):
    self.__make_calendar()
    self.calendar.working_days_per_week = value
    self._properties["working_days_per_week"] = True
</t>
<t tx="michael.20060619145551.211">def _get_working_days_per_week(self):
    return self.calendar.working_days_per_week

working_days_per_week = property(_get_working_days_per_week)
</t>
<t tx="michael.20060619145551.212">def _set_working_days_per_month(self, value):
    self.__make_calendar()
    self.calendar.working_days_per_month = value
    self._properties["working_days_per_month"] = True
</t>
<t tx="michael.20060619145551.213">def _get_working_days_per_month(self):
    return self.calendar.working_days_per_month

working_days_per_month = property(_get_working_days_per_month)
</t>
<t tx="michael.20060619145551.214">def _set_working_days_per_year(self, value):
    self.__make_calendar()
    self.calendar.working_days_per_year = value
    self._properties["working_days_per_year"] = True
</t>
<t tx="michael.20060619145551.215">def _get_working_days_per_year(self):
    return self.calendar.working_days_per_year

working_days_per_year = property(_get_working_days_per_year)
</t>
<t tx="michael.20060619145551.216">def _set_working_hours_per_day(self, value):
    self.__make_calendar()
    self.calendar.working_hours_per_day = value
    self._properties["set_working_hours_per_day"] = True
</t>
<t tx="michael.20060619145551.217">def _get_working_hours_per_day(self):
    return self.calendar.working_hours_per_day

working_hours_per_day = property(_get_working_hours_per_day)
</t>
<t tx="michael.20060619145551.218">def snapshot(self, indent="", name=None):
    text = Task.snapshot(self, indent, name)

    lines = text.splitlines(True)
    indent += "    "

    def make_resource(r):
        return '%sclass %s(Resource): title = "%s"\n' \
               % (indent, r.name, r.title)

    now = datetime.datetime.now().strftime("%x %H:%M")
    resource_text = map(lambda r: make_resource(r), self.all_resources())
    lines.insert(1, "%sfrom faces import Resource\n" % indent)
    lines.insert(2, "".join(resource_text) + "\n")
    lines.insert(3, '%snow = "%s"\n' % (indent, now))
    lines.insert(4, '%sis_snapshot = True\n' % indent)
    return "".join(lines)
</t>
<t tx="michael.20060619145551.219">class Project(_ProjectBase):
    """
    Generates a Project without allocating resources.

    @param top_task: Specifies the highest function of a project definiton.

    @param scenario: Specifies the name of the scenario which should be scheduled.

    @param id: Specifiess a unique idenfication name to distinguish the project from
    other projects in the resource database. The default value for id
    is the name of top_task.
    """
	&lt;&lt; class Project declarations &gt;&gt;
	@others

</t>
<t tx="michael.20060619145551.220">__call_completion__ = 'Project(|top_task, scenario="_default", id=None)'

</t>
<t tx="michael.20060619145551.221">def __init__(self, top_task, scenario="_default", id=None):
    _ProjectBase.__init__(self, top_task, scenario, id)
    no_snapshot = not self.is_snapshot
    for t in self:
        t._is_frozen = True
        t._recalc_properties()
        no_snapshot and t.check()

    self._restore_globals()

</t>
<t tx="michael.20060619145551.222">class _AllocationPoject(_ProjectBase):
	@others
</t>
<t tx="michael.20060619145551.223">def unfreeze_parents(self):
    if self.has_actual_data:
        for t in filter(lambda t: t.children, self):
            if not t._original_values.has_key("start"): t._unfreeze("start")
            if not t._original_values.has_key("end"): t._unfreeze("end")
</t>
<t tx="michael.20060619145551.224">class BalancedProject(_AllocationPoject):
    """
    Generates a project with allocated resources. The tasks are balanced
    to fit the resources load conditions.
    """
	&lt;&lt; class BalancedProject declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619145551.225">__call_completion__ = """BalancedProject(|top_task, scenario="_default",
id=None, balance=SMART, performed=None)"""

</t>
<t tx="michael.20060619145551.226">def __init__(self, top_task, scenario="_default",
             id=None, balance=SMART, performed=None):
    _AllocationPoject.__init__(self, top_task, scenario, id)
    self.balance = balance
    if performed:
        self._distribute_performed(performed)
        self.has_actual_data = True

    no_snapshot = not self.is_snapshot
    if no_snapshot:
        self.allocate()
    else:
        self.allocate_snapshot()

    for t in self:
        t._is_frozen = True
        t._recalc_properties()
        no_snapshot and t.check()

    self._restore_globals()</t>
<t tx="michael.20060619145551.227">def allocate_snapshot(self):
    all_resources = self.free()
    scenario = self.scenario
    has_actual_data = True
    for t in self:
        if not t.resource or t.milestone or t.children:
            continue

        t._convert_performed(all_resources)
        t._allocate_performed(t._performed)
</t>
<t tx="michael.20060619145551.228">def allocate(self):
    all_resources = self.free()
    balancing_list = self._get_balancing_list()
    scenario = self.scenario

    #for t in balancing_list:
    #    print t.path

    for t in balancing_list:
        t._compile([], True)

        if not t.resource or t.milestone or t.children:
            continue

        if t._convert_performed(all_resources):
            has_actual_data = True

        try:
            t._allocate_performed(t._performed)
        except AttributeError:
            pass

        allocator = _allocators[t.balance]
        min_val = None
        min_state = None
        for p in range(t.resource._permutation_count()):
            state = t._test_allocation(p, allocator)

            if not state: continue

            to_minimize = state[0]
            if not min_val or min_val &gt; to_minimize:
                min_val = to_minimize
                min_state = state

        if min_state:
            t._allocate(min_state, allocator)
        elif t.performed_start:
            # t could not be allocated ==&gt;
            # performance data holds all information
            t.start = t._to_start(t.performed_start)
            t.end = t._to_end(t.performed_end)

    self.unfreeze_parents()
</t>
<t tx="michael.20060619145551.229">def _distribute_performed(self, performed):
    project_id = self._idendity_()
    plen = len(project_id)

    performed = filter(lambda item: item[0].startswith(project_id),
                       performed)
    performed.sort()

    task = None
    for item in performed:
        path = item[0]
        rpath = "root" + path[plen:]
        task = self.get_task(rpath)

        if not task:
            &lt;&lt; extract task in activity path &gt;&gt;

        if not task or task.children:
            self._warn("The performance data contain "
                       "a task with id '%s'. But such "
                       "a task does not exist in your "
                       "project." % path)
            continue

        if not isinstance(task.performed, list):
            task.performed = list(task.performed)

        task.performed.append(item[1:])</t>
<t tx="michael.20060619145551.230">class AdjustedProject(_AllocationPoject):
    """
    Generates a project with allocated resources. The tasks are
    adjusted to the actual tracking data and balanced to fit the
    resources load conditions.
    """
	&lt;&lt; class AdjustedProject declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619145551.231">__call_completion__ = 'AdjustedProject(|base_project)'

</t>
<t tx="michael.20060619145551.232">def __init__(self, base_project):
    _AllocationPoject.__init__(self, base_project._function,
                               base_project.scenario, 
                               base_project.id)

    self.balance = base_project.balance
    self.has_actual_data = base_project.has_actual_data
    self.allocate(base_project)
    for t in self:
        t._is_frozen = True
        t._recalc_properties()
        t.check()

    self._restore_globals()


</t>
<t tx="michael.20060619145551.233">def allocate(self, base):
    balancing_list = self._get_balancing_list()
    scenario = self.scenario
    cal = self.calendar
    now = cal.now

    #for t in balancing_list:
    #    print t.path

    &lt;&lt; free the resources, we have to rebook &gt;&gt;

    for t in balancing_list:
        src = base.get_task(t.path)

        if src.end &lt;= now and src.complete == 100:
            &lt;&lt; copy the attribs of complete tasks &gt;&gt;
            continue

        t._compile([], True)
        if not t.resource or t.milestone or t.children:
            continue

        # now allocate the uncomplete tasks
        &lt;&lt; allocate performed data &gt;&gt;
        allocator = _allocators[t.balance]

        if src.start &gt;= now:
            &lt;&lt; allocate tasks, that have not begun yet &gt;&gt;
        else:
            &lt;&lt; allocate tasks, that are allready at work &gt;&gt;

    self.unfreeze_parents()</t>
<t tx="michael.20060619145930"></t>
<t tx="michael.20060619145930.1"></t>
<t tx="michael.20060619145930.2">@others

_smart_allocator = SmartAllocator()
_sloppy_allocator = SloppyAllocator()
_strict_allocator = StrictAllocator()
_allocators = { SMART: _smart_allocator,
                SLOPPY: _sloppy_allocator,
                STRICT: _strict_allocator }

_allocator_strings = { SMART: "SMART",
                       SLOPPY: "SLOPPY",
                       STRICT: "STRICT" }
</t>
<t tx="michael.20060619145930.3"></t>
<t tx="michael.20060619150055"></t>
<t tx="michael.20060619150413">@doc
This section contains code for byte code instrumenting
the task functions</t>
<t tx="michael.20060619150413.1"></t>
<t tx="michael.20060619150519"></t>
<t tx="michael.20060619150542"></t>
<t tx="michael.20060619151509">for t in balancing_list:
    src = base.get_task(t.path)
    if src.end &gt; now or src.complete &lt; 100:
        for r in src._iter_booked_resources():
            r.unbook_task(src)</t>
<t tx="michael.20060619151509.1">t.effort = src.effort
t.load = src.load
t.start = src.start
t.end = src.end
t.done = src.done
t.todo = src.todo
t.booked_resource = src.booked_resource
t.performed_resource = src.performed_resource
t._unfreeze("length")
t._unfreeze("duration")</t>
<t tx="michael.20060619151509.2">try:
    t._performed = src._performed
    t._allocate_performed(t._performed)
except AttributeError:
    pass</t>
<t tx="michael.20060619151509.3">min_val = None
min_state = None
for p in range(t.resource._permutation_count()):
    state = t._test_allocation(p, allocator)
    if not state: continue

    to_minimize = state[0]
    if not min_val or min_val &gt; to_minimize:
        min_val = to_minimize
        min_state = state

if min_state:
    t._allocate(min_state, allocator)
elif t.performed_start:
    t.start = t._to_start(t.performed_start)
    t.end = t._to_end(t.performed_end)
</t>
<t tx="michael.20060619151846">if t.__dict__.has_key("effort"):
    t.effort = t._to_delta(src.done + src.todo).round()

resource = src.booked_resource or src.performed_resource
state = allocator.test_allocation(t, resource)
if state:
    t._allocate(state, allocator)</t>
<t tx="michael.20060619153005">deps = { }
task = self
while task:
    deps.update(task._dependencies.get("end", {}))
    task = task.up</t>
<t tx="michael.20060619153005.1">def unfreeze_parents():
    task = self.up
    while task:
        task._unfreeze("end")
        task = task.up</t>
<t tx="michael.20060619153005.2">unfreeze_parents()

# the following code considers a expressione like
# start = predecessor.end + Delta("1d") the buffer
# calculation must be aware of the 1d delay. 
# (therefore a simple succ_start - end would be 
# incorrect)
# Solution: Simluate a later end and calculate the
# real delay

succ_task = self.get_task(path)
simulated_task = Task(succ_task._function,
                      succ_task.name,
                      succ_task.up, 1)

current_start = succ_task.start
simulated_end = current_start
self.end = current_start

simulated_task._generate()
simulated_start = simulated_task.start

unfreeze_parents()
if old_end: self.end = old_end
else: self._unfreeze("end")
del simulated_task

current_delay = current_start - end
simulated_delay = simulated_start - simulated_end
real_delay = current_delay - simulated_delay
try:
    buffer_ = real_delay + succ_task.buffer
except RecursionError, err:
    self._raise(err)</t>
<t tx="michael.20060619163321">def guess_object(self, name, pos=None, context=None):
    """
    try to calculate the value of variable "name", 
    by finding an assignment to name
    """
    &lt;&lt; calculate search end &gt;&gt;
    &lt;&lt; find context start line &gt;&gt;
    &lt;&lt; define find_last &gt;&gt;
    pos, is_seq = find_last(self.PositionFromLine(line))

    if pos &gt;= 0:
        expression = self.get_expression(self.LineFromPosition(pos))
        if is_seq:
            expression = expression[:expression.index(":")] + ": break"

        try:
            attribs = self.eval_expression(expression, {name : None},
                                           context=context)
            return attribs[name]
        except Exception: pass

    return None

</t>
<t tx="michael.20060619163321.1">find_str_eq = r"\&lt;%s\&gt;[^=]*=" % name
find_str_in = r"for.*\&lt;%s\&gt;.*\&lt;in\&gt;" % name

def find(start, fstr):
    pos = start
    while pos &gt;= 0:
        last_pos = pos
        pos = self.FindText(pos + 1, end, fstr,
                            wx.stc.STC_FIND_REGEXP\
                            |wx.stc.STC_FIND_MATCHCASE)

    if last_pos &lt;= start: last_pos = sys.maxint 
    return last_pos


def find_last(pos):
    p1 = find(pos, find_str_eq)
    p2 = find(pos, find_str_in)
    pos = min(p1, p2)
    if p1 == p2: return -1, False
    return pos, pos == p2

</t>
<t tx="michael.20060619164503"></t>
<t tx="michael.20060619164503.2">def find_object(self, name):
    """
    Find an object by name.
    """

    &lt;&lt; define get_observer &gt;&gt;

    if name == "self":
        return get_observer()

    args = list(self.code_item.get_args())
    try:
        no = args.index(name)
    except ValueError:
        return None

    observer = get_observer()
    &lt;&lt; get argument description &gt;&gt;

    try:        
        obj = arg_desc[no - 1]
    except IndexError:
        return None

    if isinstance(obj, basestring):
        # a string indicates a refrence to an attribute
        parent = CObserver(self.code_item.get_parent())
        obj = parent.find_object(obj)

    return obj</t>
<t tx="michael.20060619164749">context = context or self.context
try:
    line = context.code_item.get_line()
except AttributeError:
    line = 0

</t>
<t tx="michael.20060619183441"></t>
<t tx="michael.20060619183441.1">def get_main_completion_list(self):
    """
    returns the completion list of the context
    """
    fimport = lambda n: ("import faces.lib.%s" % n, 
                         "import faces.lib.%s as %s" % (n, n)) 
    ffrom = lambda n: ("from faces.lib.%s" % n, 
                       "from faces.lib.%s import %s" % (n, n))

    modules = ("report", "gantt", "resource", "generator", "workbreakdown")
    return map(fimport, modules) + map(ffrom, modules)




</t>
<t tx="michael.20060619184051">def get_observer_pseudo(code_item):
    module = code_item.editor.get_module()
    for base in code_item.get_args():
        try:
            bo = eval("module.%s" % base)
            if issubclass(bo, fobserver.Observer):
                return bo
        except AttributeError: pass
        except TypeError: pass
        except SyntaxError: pass

    return fobserver.Observer</t>
<t tx="michael.20060619191608">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A report generator
"""
&lt;&lt; declarations &gt;&gt;
@others
</t>
<t tx="michael.20060619191608.1">import task
import observer
import datetime as datetime
import inspect
import pcalendar
import plocale
import utils
from task import _ValueWrapper

_is_source_ = True
_ = plocale.get_gettext()


header_names = { "indent_name": _("Name"),
                 "name": _("Name"),
                 "index": _("Index"),
                 "title" : _("Title"),
                 "start" : _("Start"),
                 "end"  : _("End"),
                 "load" : _("Load"),
                 "estimated_effort" : _("Estimated Effort"),
                 "performed_effort" : _("Performed Effort"),
                 "performed_end" : _("Performed End"),
                 "performed_start" : _("Performed Start"),
                 "performed_work_time" : _("Worktime"),
                 "length" : _("Length"),
                 "effort" : _("Effort"),
                 "duration" : _("Duration"),
                 "real_effort" : _("Real Effort"),
                 "quotient" : _("Quotient"),
                 "complete" : _("Complete"),
                 "priority" : _("Priority"),
                 "todo" : _("Todo"),
                 "efficiency" : _("Efficiency"),
                 "buffer" : _("Buffer"),
                 "costs" : _("Costs"),
                 "sum" : _("Sum"),
                 "max" : _("Max"),
                 "min" : _("Min"),
                 "milestone" : _("Milestone"),
                 "resource" : _("Resource"),
                 "booked_resource" : _("Booked Resource") }


</t>
<t tx="michael.20060619191608.2"></t>
<t tx="michael.20060619191608.3">def _val(val):
    if isinstance(val, _ReportValueWrapper):
        return val._value

    return val
</t>
<t tx="michael.20060619191608.4">def _has_ref(val):
    if isinstance(val, _ReportValueWrapper):
        return val._ref

    return False
</t>
<t tx="michael.20060619191608.5">class _ReportValueWrapper(_ValueWrapper):
	@others</t>
<t tx="michael.20060619191608.6">def __init__(self, value, ref=(None, "")):
    _ValueWrapper.__init__(self, value, ref)
</t>
<t tx="michael.20060619191608.7">def _vw(self, operand, *args):
    refs = map(_has_ref, args)
    refs = filter(bool, refs)
    vals = map(_val, args)
    result = operand(*vals)
    return _ReportValueWrapper(result, refs and refs[0] or (None, ""))
</t>
<t tx="michael.20060619191608.8">def _cmp(self, operand, *args):
    vals = map(_val, args)
    return operand(*vals)
</t>
<t tx="michael.20060619191608.9">def __call__(self, *args):
    vals = map(_val, args)
    other = _ReportValueWrapper(self._value(*vals),
                                (self._ref[0], self._ref[1], args))
    return other
</t>
<t tx="michael.20060619191608.10">def __repr__(self):
    if isinstance(self._value, basestring):
        return self._value

    formatter = self._ref[0].formatter(self._ref[1])
    return formatter(self._value)
</t>
<t tx="michael.20060619191608.11">__str__ = __repr__

def type(self):
    return type(self._value)
</t>
<t tx="michael.20060619191608.12">

class _TaskWrapper:
	@others
</t>
<t tx="michael.20060619191608.13">def __init__(self, task):
    self.task = task
</t>
<t tx="michael.20060619191608.14">def __getattr__(self, name):
    if name == "copy_src":
        return self.task.copy_src and _TaskWrapper(self.task.copy_src)

    if name == "to_string":
        return _ToStringWrapper(self.task.to_string)

    value = getattr(self.task, name)

    if isinstance(value, task.Task):
        result = _TaskWrapper(value)
    else:
        result = _ReportValueWrapper(value, (self.task, name))

    setattr(self, name, result)
    return result
</t>
<t tx="michael.20060619191608.15">def __iter__(self):
    def wrap_iter():
        for t in self.task:
            yield _TaskWrapper(t)

    return wrap_iter()
</t>
<t tx="michael.20060619191608.16">def __str__(self):
    return "_TaskWrapper %s" % self.task
</t>
<t tx="michael.20060619191608.17">

class _ToStringWrapper:
	@others
</t>
<t tx="michael.20060619191608.18">def __init__(self, converter):
    self.converter = converter
</t>
<t tx="michael.20060619191608.19">def __getattr__(self, name):
    value = getattr(self.converter, name)
    result = _ReportValueWrapper(value, (self.converter.source, name))
    setattr(self, name, result)
    return result
</t>
<t tx="michael.20060619191608.20">def __getitem__(self, format):
    return _ToStringWrapper(self.converter[format])
</t>
<t tx="michael.20060619191608.21">


class _ReportIter(object):
	@others
</t>
<t tx="michael.20060619191608.22">def __init__(self, report):
    self.report = report
    try:
        self.stepper = iter(report.make_report(report.data))
    except Exception, e:
        report._raise(e)
</t>
<t tx="michael.20060619191608.23">def __iter__(self):
    return self
</t>
<t tx="michael.20060619191608.24">def next(self):
    row = self.stepper.next()
    if not isinstance(row, (tuple, list)):
        row = (row, )

    def to_cell(c):
        if isinstance(c, Cell): return c
        return Cell(c)

    row = map(to_cell, row)
    if row[0].left_border is None:
        row[0].left_border = True

    return self.report.modify_row(row)
</t>
<t tx="michael.20060619191608.25"></t>
<t tx="michael.20060619191608.26">class Cell(object):
    """
    The class represents a cell within a report row

    @var back_color:
    Specifies the background color of the cell.  Valid value are any
    html hex string like '\#eeefff' or legal html names for colors,
    like 'red', 'burlywood' and 'chartreuse'.

    @var text_color:
    Specifies the text color of the cell. Valid value are any html hex
    string like '\#eeefff' or legal html names for colors, like 'red',
    'burlywood' and 'chartreuse'.

    @var font_bold:
    Specifies if the text should be displayed bold. Valid values are
    True or False.

    @var font_italic:
    Specifies if the text should be displayed italic. Valid values
    are True or False.

    @var font_underline:
    Specifies if the text should be displayed underlined. Valid
    values are True or False.

    @var font_size:
    Specifies the font size of the text. Valid values are either an
    absolute value of"xx-small", "x-small", "small", "medium", "large",
    "x-large", "xx-large"; or a relative value of"smaller" or "larger";
    or an absolute font size, e.g. 12.

    @var left_border:
    Specifies if a left border apperars. Valid values
    are True or False.

    @var top_border:
    Specifies if a top border apperars. Valid values
    are True or False.

    @var right_border:
    Specifies if a right border apperars. Valid values
    are True or False.

    @var bottom_border:
    Specifies if a bottom border apperars. Valid values
    are True or False.

    @var align:
    Specifies the alignment of the cell. Valid values are
    LEFT(0), RIGHT(1), CENTER(2)
    """
	&lt;&lt; declarations &gt;&gt;
	@others

    __repr__ = __str__</t>
<t tx="michael.20060619191608.27">LEFT = 0
RIGHT = 1
CENTER = 2

back_color = None
text_color = None
font_bold = False
font_italic = False
font_underline = False
font_size = None
left_border = None
top_border = False
right_border = True
bottom_border = True
align = LEFT

__all__ = ("LEFT", "RIGHT", "CENTER", "back_color",\
           "text_color", "font_bold", "font_italic",\
           "font_underline", "font_size", "left_border",\
           "top_border", "right_border", "bottom_border",\
           "align")

</t>
<t tx="michael.20060619191608.28">def __init__(self, value, **kwargs):
    for k, v in kwargs.iteritems():
        setattr(self, k, v)

    self.value = value
    if self.get_type() is float:
        self.align = self.RIGHT
</t>
<t tx="michael.20060619191608.29">def get_label(self):
    if isinstance(self.value, _ReportValueWrapper):
        return self.value._ref[1]

    return ""
</t>
<t tx="michael.20060619191608.30">def get_type(self):
    if isinstance(self.value, _ReportValueWrapper):
        return type(self.value._value)

    return type(self.value)
</t>
<t tx="michael.20060619191608.31">def get_ref(self):
    if isinstance(self.value, _ReportValueWrapper):
        return self.value._ref

    return (None, "")
</t>
<t tx="michael.20060619191608.32">def __str__(self):
    return str(self.value)
</t>
<t tx="michael.20060619191608.33">def __unicode__(self):
    return unicode(self.value)
</t>
<t tx="michael.20060619191608.34">def __nonzero__(self):
    return bool(self.value)
</t>
<t tx="michael.20060619191608.35">def __cmp__(self, other):
    return cmp(self.value, other.value)
</t>
<t tx="michael.20060619191608.36">def native(self):
    """
    returns the native value of the cell.
    """

    if isinstance(self.value, _ReportValueWrapper):
        return self.value._value

    return self.value
</t>
<t tx="michael.20060619191608.37">class Report(observer.Observer):
    """
    A standart report.

    @var headers:
    A tuple specifying the report header.
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619191608.38">__type_name__ = "report"
__type_image__ = "report"
data = None
headers = ()

__attrib_completions__ = observer.Observer.__attrib_completions__.copy()
__attrib_completions__.update({\
    "#data" : "get_evaluation_completions", 
    "data" : 'data = ',
    "headers" : 'headers = ()',
    "def make_report" : "def make_report(self, data):\nfor d0 in data: \nyield (|d0.indent_name(), d0.start)",
    "def prepare_data" : "def prepare_data(self, data):\nreturn data",
    "def modify_row" : "def modify_row(self, row):\nreturn row" })

__all__ = ("headers", "data")
</t>
<t tx="michael.20060619191608.39">def __init__(self):
    if not self.data:
        self._raise(RuntimeError('no data attribute specified'))

    if not self.headers:
        def get_header(c):
            result = c.get_label()
            return header_names.get(result, result)

        first = iter(self).next()
        if not self.headers:
            self.headers = tuple(map(get_header, first))
</t>
<t tx="michael.20060619191608.40">def _raise(self, exc):
    line = inspect.getsourcelines(self.__class__)[1]
    fname = inspect.getsourcefile(self.__class__)
    raise exc.__class__('%s (File "%s", line %i)' % (str(exc), fname, line))
</t>
<t tx="michael.20060619191608.41">def make_report(self, data):
    raise RuntimeError("called base report")

make_report.args = ("data",)</t>
<t tx="michael.20060619191608.42">def prepare_data(self, data):
    return data
</t>
<t tx="michael.20060619191608.43">def instrument_data(self, data):
    def wrap_obj(obj):
        if isinstance(obj, task.Task):
            return _TaskWrapper(obj)

        if isinstance(obj, _TaskWrapper):
            return obj

        if isinstance(obj, basestring):
            return obj

        try:
            return map(wrap_obj, iter(obj))
        except TypeError:
            return obj

    return wrap_obj(data)
</t>
<t tx="michael.20060619191608.44">def modify_row(self, row):
    return row

modify_row.args = ([Cell]*20,)

</t>
<t tx="michael.20060619191608.45">__is_prepared = False
def __iter__(self):
    if not self.__is_prepared:
        self.data = self.prepare_data(self.data)
        self.data = self.instrument_data(self.data)
        self.__is_prepeditared = True
    return _ReportIter(self)
</t>
<t tx="michael.20060619192815">def get_observer():
    parent = self.code_item.get_parent()
    try:
        return parent.obj
    except AttributeError:
        return get_observer_pseudo(parent)</t>
<t tx="michael.20060619193106">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A library of different reports.
"""
&lt;&lt; imports &gt;&gt;

_is_source_ = True
Cell = _report.Cell
_ = faces.plocale.get_gettext()

__all__ = ("Standard", "Titles", "Critical", "Calendar")


@others
</t>
<t tx="michael.20060619193106.1">import faces.report as _report
import faces.pcalendar as _pcalendar
import faces.task as _task
import datetime as _datetime
import bisect as _bisect
import faces.plocale
import locale


</t>
<t tx="michael.20060619193106.2">class Standard(_report.Report):
    """
    A standard report
    """

	@others
</t>
<t tx="michael.20060619193106.4">def make_report(self, data):
    for t in data:
        yield (t.indent_name(), t.start, t.end, t.effort, t.length)

</t>
<t tx="michael.20060619193106.5">class Titles(Standard):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619193106.6">__attrib_completions__ = Standard.__attrib_completions__.copy()
del __attrib_completions__["def modify_row"]

</t>
<t tx="michael.20060619193106.7">def modify_row(self, row):
    task = row[0].get_ref()[0]
    if not isinstance(task, _task.Task):
        return row

    if task.children:
        ds = { 
            0 : "xx-large",
            1 : "x-large",
            2 : "large",
            }.get(int(task.depth))

        for c in row:
            c.font_bold = True
            c.font_size = ds

    return row
</t>
<t tx="michael.20060619193106.8">class Critical(Standard):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619193106.9">colors = { 0 : "red" }

__attrib_completions__ = Standard.__attrib_completions__.copy()
__attrib_completions__.update({\
    "colors" : 'colors = { |0 : "red" }' })
del __attrib_completions__["def modify_row"]


</t>
<t tx="michael.20060619193106.10">def __init__(self):
    self._colors = []

    to_minutes = _pcalendar._default_calendar.Minutes
    self._colors = map(lambda i: (to_minutes(i[0]), i[1]),
                       self.colors.items())
    self._colors.sort()
    self._colors.reverse()

    Standard.__init__(self)
</t>
<t tx="michael.20060619193106.11">def modify_row(self, row):
    task = row[0].get_ref()[0]
    if not isinstance(task, _task.Task):
        return row

    color = None
    for v, c in self._colors:
        if task.buffer &lt;= v: color = c

    if color:
        for c in row:
            c.back_color = color

    return row
</t>
<t tx="michael.20060619193106.12">class Calendar(Standard):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619193106.13">__type_image__ = "calendar"

show_start = True
show_end = True
start = None
end = None

__attrib_completions__ = Standard.__attrib_completions__.copy()
__attrib_completions__.update({\
    "show_start" : 'show_start = True',
    "show_end" : 'show_end = True',
    "start" : 'start = None',
    "end" : 'end = None',
    "def modify_cell" : "def modify_cell(self, cell):\npass" })

del __attrib_completions__["def modify_row"]
del __attrib_completions__["def make_report"]


</t>
<t tx="michael.20060619193106.14">def instrument_data(self, data):
    data = tuple(data)
    self.dates = dates = {}

    mind = _datetime.datetime.max
    maxd = _datetime.datetime.min

    &lt;&lt; define insert_task &gt;&gt;

    for i, t in enumerate(data):
        if self.show_start:
            mind, maxd = insert_task(i, t.start, 0, mind, maxd)

        if self.show_end:
            mind, maxd = insert_task(i, t.end, 1, mind, maxd)

    if not self.start:
        self.start = mind
    else:
        self.start = _pcalendar.WorkingDate(self.start).to_datetime()

    if not self.end:
        self.end = maxd
    else:
        self.end = _pcalendar.WorkingDate(self.end).to_datetime()

    self._create_columns(self.start, self.end)
    self._create_headers()

    return Standard.instrument_data(self, data)
</t>
<t tx="michael.20060619193106.15">def get_dates(self, date):
    result = self.dates.get(date, ())
    return map(lambda i: (self.data[i[2]], i[1]), result)
</t>
<t tx="michael.20060619193106.16">def make_cell(self, value, **kwargs):
    cell = Cell(value, **kwargs)
    date = kwargs["date"]
    is_header = kwargs.get("header", False)

    if date and date.weekday() in (5, 6) and not is_header:
        cell.back_color = "gray"

    self.modify_cell(cell)
    return cell
</t>
<t tx="michael.20060619193106.17">def modify_cell(self, cell):
    pass

modify_cell.args = (Cell,)</t>
<t tx="michael.20060619193106.18">def make_report(self, data):
	day_header = None
	day_rows =  None

    &lt;&lt; define add_row &gt;&gt;
    &lt;&lt; define add_date &gt;&gt;

	col_range = range(len(self.columns))
	for d in range(1, 32):
        #iterate through all days
	    day_header = []
	    day_rows = []

        &lt;&lt; create day header cells &gt;&gt;
	    add_row()

        &lt;&lt; create day data cells &gt;&gt;
	    day_rows.insert(0, day_header)

        &lt;&lt; adjust borders &gt;&gt;

	    for r in day_rows:
            r[0].left_border = left_frame_border
            yield r
</t>
<t tx="michael.20060619193106.21">def get_start_text(self, task):
    text = task.to_string["%H:%M"].start + " " + task.title + " (start)"
    if task.booked_resource:
        text += "\n     " + task.to_string.booked_resource
    return text
</t>
<t tx="michael.20060619193106.22">def get_end_text(self, task):
    text = task.to_string["%H:%M"].end + " " + task.title + " (end)"
    if task.booked_resource:
        text += "\n     " + task.to_string.booked_resource
    return text
</t>
<t tx="michael.20060619193106.23">def _create_columns(self, start, end):
    start = start.year * 12 + start.month - 1
    end = end.year * 12 + end.month
    def to_date(month):
        return _datetime.datetime(month / 12, 1 + (month % 12), 1)
    self.columns = map(to_date, range(start, end))
</t>
<t tx="michael.20060619193106.24">def _create_headers(self):
    encoding = locale.getlocale()[1] or "ascii"
    self.headers = map(lambda d: d.strftime("%B %y").decode(encoding),
                       self.columns)
</t>
<t tx="michael.20060619193517">for c in inspect.getmro(observer):
    try:
        func = getattr(c, self.code_item.name)
        arg_desc = func.args
        break
    except AttributeError: 
        pass
else:
    return None</t>
<t tx="michael.20060619194944">def add_row():
    row = map(lambda c: self.make_cell("", 
                                       right_border=c.right_border,
                                       font_size="small",
                                       header=False,
                                       bottom_border=False,
                                       date=c.date),\
              day_header)

    day_rows.append(row)</t>
<t tx="michael.20060619194944.1">def add_date(col, date):
    if day_rows[-1][col].value:
        add_row()
        day_rows[-1][col].value = date
        return

    for r in day_rows:
        if not r[col].value:
            r[col].value = date
            break</t>
<t tx="michael.20060619200005">for month in self.columns:
    try:
        date = month.replace(day=d).date()
        c = self.make_cell(date.strftime("%d. %A"),
                           back_color="gold",
                           bottom_border=False,
                           header=True,
                           date=date)
        if day_header: day_header[-1].right_border = True
        day_header.append(c)
    except:
        #the day does not exist at tha month
        c = self.make_cell("", 
                           right_border=False,
                           bottom_border=False,
                           header=False,
                           date=None)
        day_header.append(c)</t>
<t tx="michael.20060619200005.1">for c in col_range:
    date = day_header[c].date
    if not date: continue
    tasks = self.get_dates(date)
    for t, soe in tasks:
        if soe == 0:
            text = self.get_start_text(t)
        else:
            text = self.get_end_text(t)

        if text:
            add_date(c, text)</t>
<t tx="michael.20060619200005.2">for c in col_range:
    date = day_header[c].date
    if date:
        day_rows[-1][c].bottom_border = True

left_frame_border = bool(day_header[0].date)</t>
<t tx="michael.20060619200744">def insert_task(index, date, soe, min_date, max_date):
    date = date.to_datetime()
    day = dates.setdefault(date.date(), [])
    _bisect.insort_right(day, (date.time(), soe, index))
    return min(date, min_date), max(date, max_date)</t>
<t tx="michael.20060619222451">@language python
&lt;&lt; Copyright &gt;&gt;
"""
Matplotlib-based charts
"""
&lt;&lt; imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

__all__ = ("TimeWidgetChart", "TableChart", "TimeAxisWidgetChart",
           "TimeAxisPlotChart", "TimeAxisMultiChart",
           "TimeAxisTabledChart")
@others</t>
<t tx="michael.20060619222451.1">import matplotlib.figure as figure
import matplotlib.backends
import matplotlib.font_manager as font
import matplotlib.backend_bases as bases
import matplotlib.ticker as ticker
import matplotlib.axes as axes
import matplotlib.transforms as mtrans
import matplotlib.pylab as pylab
import faces
import faces.pcalendar as pcal
import faces.utils as utils
import faces.observer
import faces.plocale
import patches
import widgets as widget
import printer
import faxes
import taxis
import timescale
from tools import *



</t>
<t tx="michael.20060619222451.8">class MatplotChart(faces.observer.Observer, widget._PropertyAware):
    """
    Base Class for all charts.

    @var properties:
    Specifies a dictionary of display properties.

    @var show_tips:
    Specifies a boolean value, wether the charts should display tool tips.

    @var scroll_bars:
    Specifies a boolean value, wether the charts should display scroll bars.

    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.9">__type_name__ = "matplot_chart"
properties = {
    "family" : "sans-serif",
    #"family": [ "Arial", "Verdana", "Bitstream Vera Sans" ] ,        
    "background.facecolor" : "w",
    "fill" : 1,
    "alpha" : 1,
    "marker.edgecolor" : "blue",
    "marker.linewidth" : 2,
    "marker.antialiased" : True,
    "marker.facecolor" : "green",
    "marker.alpha" : "0.4",
    "focused.marker.edgecolor" : "red" }

__attrib_completions__ = faces.observer.Observer.__attrib_completions__.copy()
__attrib_completions__.update({\
    "properties" : 'properties = { | }',
    "show_tips" : 'show_tips = False',
    "scroll_bars" : 'scroll_bars = False',
    "def add_decorations" : """def add_decorations(self, axes):
pass
"""
    })


show_tips = True    
scroll_bars = True

</t>
<t tx="michael.20060619222451.10">def printer(cls, **kwargs):
    return printer.FreePrinter(cls, **kwargs)

printer = classmethod(printer)</t>
<t tx="michael.20060619222451.11">def __init__(self, paint_to=None, rect=None, **kwargs):
    faces.observer.Observer.__init__(self)
    widget._PropertyAware.__init__(self)

    self.figure = None
    self.axes = None

    back_face = self.get_property("background.facecolor")
    if isinstance(paint_to, figure.Figure):
        self.figure = paint_to
        self.axes = self.create_axes(rect, **kwargs)
        self.axes.set_axis_bgcolor(back_face)
        self.setup_axes_interface(self.axes)

    if isinstance(paint_to, axes.Axes):
        self.axes = paint_to
        self.figure = self.axes.get_figure()
        self.axes.set_axis_bgcolor(back_face)
        self.setup_axes_interface(self.axes)

    if self.figure:
        self.create()
        self._add_decorations()
</t>
<t tx="michael.20060619222451.12">def _add_decorations(self):
    self.add_decorations(self.axes)
</t>
<t tx="michael.20060619222451.13">def add_decorations(self, axes):
    """
    Overwrite this method to add decorations to the chart
    """
    pass

add_decorations.args = (faxes.WidgetAxes,)
</t>
<t tx="michael.20060619222451.14">def create_axes(self, rect=None, **kwargs):
    """
    creates the default axes for the chart
    """
    raise RuntimeError("abstract")
</t>
<t tx="michael.20060619222451.15">def create(self):
    """
    create the chart
    """

    raise RuntimeError("abstract")
</t>
<t tx="michael.20060619222451.16">def get_tip(self, tipobj):
    return None
</t>
<t tx="michael.20060619222451.17">def setup_axes_interface(self, axes):
    """
    Setup interface for chartview and printer
    """
    def dumy(*args): return None
    self._set_frame_on = axes.set_frame_on
    self._axes_patch = axes.axesPatch
    self._left_margin = getattr(axes, "left_margin", None)
    self._right_margin = getattr(axes, "right_margin", None)
    self._top_margin = getattr(axes, "top_margin", None)
    self._bottom_margin = getattr(axes, "bottom_margin", None)
    self._trans_data = axes.transData
    self._data_lim = axes.dataLim
    self._view_lim = axes.viewLim
    self._bbox = getattr(axes, "content_bbox", self.axes.bbox)
    self._set_xlim = axes.set_xlim
    self._set_ylim = axes.set_ylim
    self._get_xlim = axes.get_xlim
    self._get_ylim = axes.get_ylim
    self._set_autoscale_on = axes.set_autoscale_on
    self._autoscale_view = axes.autoscale_view
    self._set_auto_scale_y =getattr(axes, "set_auto_scale_y", dumy) 
    self._zoomx = axes.zoomx
    self._zoomy = axes.zoomy
    self._widget_at = getattr(axes, "widget_at", dumy)
    self._find_widget = getattr(axes, "find_widget", dumy)
    self._set_focused_on = getattr(axes, "set_focused_on", dumy)
    self._set_focused_off = getattr(axes, "set_focused_off", dumy)
    self._speed_up = getattr(axes, "speed_up", dumy) 
    self._clear_speed_cache = getattr(axes, "clear_speed_cache", dumy)
    self._widget_x_visible = getattr(axes, "widget_x_visible", dumy)
    self._widget_y_visible = getattr(axes, "widget_y_visible", dumy)
    self._share_axes = axes
    self._mark_widget = getattr(axes, "mark_widget", dumy)
    self._check_limits = getattr(axes, "check_limits", dumy)
    self._get_time_lim = getattr(axes, "get_time_lim", dumy)
    self._set_time_lim = getattr(axes, "set_time_lim", dumy)
    self._widgets = getattr(axes, "widgets", ())
</t>
<t tx="michael.20060619222451.18">class TimeWidgetChart(MatplotChart):
    """
    Base class for all charts that have a horizontal time axes.

    @var sharex:
    Specifies a group of charts that share their time axis. All charts
    with the same attribute will be synchronized within the gui.

    @var show_rowlines:
    Specifies wether the chart should display row lines.

    @var auto_scale_y:
    Specifies wether the chart should be also autoscaled in the y axis
    to fit in a window.

    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.19">__type_name__ = "matplot_timechart"
__type_image__ = "gantt"
data = None
sharex = None
show_rowlines = False
auto_scale_y = False

__attrib_completions__ = MatplotChart.__attrib_completions__.copy()
__attrib_completions__.update({\
    "data" : 'data = ',
    "sharex" : 'sharex = "time_share"',
    "show_rowlines" : "show_rowlines = False",
    "auto_scale_y" : 'auto_scale_y = False',
    "#data" : "get_evaluation_completions" })


</t>
<t tx="michael.20060619222451.20">def __init__(self, *args, **kwargs):
    self.calendar = pcal._default_calendar
    self.time_scale = timescale._default_scale

    if not self.data:
        raise RuntimeError("no data attribute specified")

    MatplotChart.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060619222451.21">def to_date(self, date):
    """
    converts a date to a x value
    """
    return self.time_scale.to_num(date)
</t>
<t tx="michael.20060619222451.22">def create_axes(self, rect=None, **kwargs):
    pprop = self.get_patch
    rect = rect or [ 0, 0, 1, 1 ]

    ax = self.figure.add_axes(faxes.TimeWidgetAxes(self.figure,
                                                   rect, **kwargs))
    ax.auto_scale_y = self.auto_scale_y
    ax.cla()
    ax.set_marker(pprop("focused.marker"), pprop("marker"))
    return ax
</t>
<t tx="michael.20060619222451.23">def create(self):
    if not isinstance(self.axes, faxes.TimeWidgetAxes):
        raise RuntimeError("axes has to be an instance "\
                           "of TimeWidgetAxes but is %s" \
                           % self.axes.__class__.__name__)

    row_widgets = filter(lambda w: hasattr(w, "row"), self.axes.widgets)
    if row_widgets:
        rows = map(lambda w: (w.row.y.get(), w.row), row_widgets)
        row = min(rows)[1]
    else:
        row = None

    push_active(self)
    widget.Row.show_rowline = self.show_rowlines

    all_widgets = self.create_all_widgets(row)

    utils.progress_start(_("create widgets for %s") \
                         % self.__class__.__name__,
                         len(all_widgets))

    for count, w in enumerate(all_widgets):
        self.axes.add_widget(w)
        utils.progress_update(count)

    utils.progress_end()
    self.axes.xaxis_timescale(self.time_scale)
    pop_active()
</t>
<t tx="michael.20060619222451.24">def create_all_widgets(self, start_row):
    raise RuntimeError("abstract")
</t>
<t tx="michael.20060619222451.25">def _finalize_row_widgets(self, row_widgets, start_row):
    rows = enumerate(map(lambda w: w.row, row_widgets)) #get rows

    rows = map(lambda r: (r[1], r), rows) # save row order
    rows.reverse() # to elimnate duplicates with higher row numbers
    rows = dict(rows)     #eliminate duplicates
    rows = rows.values()
    rows.sort()           #restore row order
    rows = map(lambda r: r[1], rows) # back to sequence

    if start_row:
        y = start_row.next_y()
    else:
        y = mtrans.zero()

    for r in rows: y = r.set_y(y)
    return rows
</t>
<t tx="michael.20060619222451.26">class TimePlotChart(MatplotChart):
	&lt;&lt; class TimePlotChart declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.27">__type_name__ = "matplot_timechart"
__type_image__ = "plot"
calendar = None
sharex = None

__attrib_completions__ = MatplotChart.__attrib_completions__.copy()
__attrib_completions__.update({\
    "calendar" : 'calendar = ',
    "sharex" : 'sharex = "time_share"',
    "def create_plot" : """def create_plot(self, to_x):
pass
"""})

</t>
<t tx="michael.20060619222451.28">def __init__(self, *args, **kwargs):
    if not self.calendar:
        raise RuntimeError("no calendar specified")

    self.time_scale = timescale.TimeScale(self.calendar)
    MatplotChart.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060619222451.29">def create_axes(self, rect=None, **kwargs):
    pprop = self.get_patch
    rect = rect or [ 0, 0, 1, 1 ]

    ax = self.figure.add_axes(faxes.TimePlotAxes(self.figure,
                                                 rect, **kwargs))
    ax.cla()
    return ax
</t>
<t tx="michael.20060619222451.30">def create(self):
    push_active(self)
    self.create_plot(self.time_scale.to_num)
    self.axes.xaxis_timescale(self.time_scale)
    pop_active()
</t>
<t tx="michael.20060619222451.31">def create_plot(self, to_x):
    pass
</t>
<t tx="michael.20060619222451.32">class TimeMultiChart(MatplotChart):
	&lt;&lt; class TimeMultiChart declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.33">__type_name__ = "matplot_timechart"
__type_image__ = "gantt"
sharex = None
auto_scale_y = False

__attrib_completions__ = MatplotChart.__attrib_completions__.copy()
__attrib_completions__.update({\
    "auto_scale_y" : 'auto_scale_y = True',
    "sharex" : 'sharex = "time_share"'})


</t>
<t tx="michael.20060619222451.34">def __init__(self, *args, **kwargs):
    self.charts = []
    self.time_scale = timescale._default_scale
    self.main_axes = None
    MatplotChart.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060619222451.35">def create_axes(self, rect=None, **kwargs):
    pprop = self.get_patch
    rect = rect or [ 0, 0, 1, 1 ]

    ax = self.figure.add_axes(faxes.TimeWidgetAxes(self.figure,
                                                   rect, **kwargs))
    ax.auto_scale_y = self.auto_scale_y
    ax.cla()
    ax.set_navigate(False)
    ax.set_marker(pprop("focused.marker"), pprop("marker"))
    ax.set_frame_on(True)
    ax.axesPatch.set_fill(True)
    return ax
</t>
<t tx="michael.20060619222451.36">def create(self):
    push_active(self)
    self.create_chart()

    #find a better timescale
    for ax in self.figure.get_axes():
        if ax is not self.axes and isinstance(ax, faxes.TimeAxes):
            self.time_scale = ax.time_scale
            ax.time_axis.set_visible(False)
            ax.update_time_axis()

    self.axes.xaxis_timescale(self.time_scale)
    self.axes.update_time_axis()
    self.setup_axes_interface(self.main_axes)

    pop_active()
</t>
<t tx="michael.20060619222451.37">def add_TimeWidgetAxes(self, **kwargs):
    pprop = self.get_patch
    kwargs["sharex"] = self.axes
    if not kwargs.has_key("rect"): kwargs["rect"] = (0, 0, 1, 1)
    rect = kwargs["rect"]
    if rect[1] + rect[3] &gt;= 1:
        kwargs["top_margin"] = self.axes.top_margin

    ax = faxes.TimeWidgetAxes(self.figure, **kwargs)
    self.figure.add_axes(ax)
    ax.auto_scale_y = self.auto_scale_y
    ax.cla()
    ax.set_frame_on(False)
    ax.set_marker(pprop("focused.marker"), pprop("marker"))
    ax.set_frame_on(False)
    ax.axesPatch.set_fill(False)
    self.main_axes = ax
    return ax
</t>
<t tx="michael.20060619222451.38">def add_TimePlotAxes(self, **kwargs):
    kwargs["sharex"] = self.axes
    if not kwargs.has_key("rect"): kwargs["rect"] = (0, 0, 1, 1)
    rect = kwargs["rect"]
    if rect[1] + rect[3] &gt;= 1:
        kwargs["top_margin"] = self.axes.title_height

    ax = faxes.TimePlotAxes(self.figure, **kwargs)
    self.figure.add_axes(ax)
    ax.cla()
    ax.set_frame_on(False)
    return ax
</t>
<t tx="michael.20060619222451.39">def add_chart(self, chart):
    push_active(self)
    try:
        self.charts.append(chart)
    finally:
        pop_active()
</t>
<t tx="michael.20060619222451.40">def get_tip(self, tipobj):
    if not self.show_tips: return
    for c in self.charts:
        info = c.get_tip(tipobj)
        if info: return info

    return None
</t>
<t tx="michael.20060619222451.41">def create_chart(self):
    pass
</t>
<t tx="michael.20060619222451.42">class TimeAxisChart(object):
    """
    A Mixin for Charts with a Time Axis

    @var time_axis_properties:
    Specifies a dictionary of display properties for the time axis.

    @var show_grid:
    A boolean value that specifies wether to display a horizontal grid.

    @var show_scale:
    A boolean value that specifies wether to display the time scale.

    @var show_free_time:
    A boolean value that specifies wether to distinguish between free
    times and working times.

    @var show_now:
    A boolean value that specifies wether to display a line at now.
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.43">time_axis_properties = None
show_grid = True
show_scale = True
show_free_time = True
show_now = True

__attrib_completions__ = {\
    "time_axis_properties" : 'time_axis_properties = { | }',
    "show_grid": "show_grid = False",
    "show_scale": "show_scale = False",
    "show_free_time": "show_free_time = False",
    "show_now": "show_now = False" }

</t>
<t tx="michael.20060619222451.44">def create(self):
    super(TimeAxisChart, self).create()
    self.set_time_axis()
</t>
<t tx="michael.20060619222451.45">def set_time_axis(self):
    self.time_axis = taxis.TimeAxis(self.time_axis_properties)
    self.time_axis.show_grid = self.show_grid
    self.time_axis.show_scale = self.show_scale
    self.time_axis.show_free_time = self.show_free_time
    self.time_axis.show_now = self.show_now
    self.time_axis.time_scale = self.time_scale
    self.axes.set_time_axis(self.time_axis)
</t>
<t tx="michael.20060619222451.46">class TimeAxisWidgetChart(TimeAxisChart, TimeWidgetChart):
	&lt;&lt; class TimeAxisWidgetChart declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.47">__attrib_completions__ = TimeAxisChart.__attrib_completions__.copy()
__attrib_completions__.update(TimeWidgetChart.__attrib_completions__)

</t>
<t tx="michael.20060619222451.48">def printer(cls, **kwargs):
    return printer.TimeWidgetPrinter(cls, **kwargs)

printer = classmethod(printer)
</t>
<t tx="michael.20060619222451.49">class TimeAxisPlotChart(TimeAxisChart, TimePlotChart):
	&lt;&lt; class TimeAxisPlotChart declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.50">__attrib_completions__ = TimeAxisChart.__attrib_completions__.copy()
__attrib_completions__.update(TimePlotChart.__attrib_completions__)

</t>
<t tx="michael.20060619222451.51">def printer(cls, **kwargs):
    return printer.TimePlotPrinter(cls, **kwargs)

printer = classmethod(printer)
</t>
<t tx="michael.20060619222451.52">class TimeAxisMultiChart(TimeAxisChart, TimeMultiChart):
	&lt;&lt; class TimeAxisMultiChart declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.53">__attrib_completions__ = TimeAxisChart.__attrib_completions__.copy()
__attrib_completions__.update(TimeMultiChart.__attrib_completions__)

</t>
<t tx="michael.20060619222451.54">def printer(cls, **kwargs):
    return printer.TimeWidgetPrinter(cls, **kwargs)

printer = classmethod(printer)    
</t>
<t tx="michael.20060619222451.55">class TableChart(MatplotChart):
	&lt;&lt; class TableChart declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.56">__type_name__ = "matplot_pointchart"
show_rowlines = True
show_collines = True

__attrib_completions__ = MatplotChart.__attrib_completions__.copy()
__attrib_completions__.update({\
    "show_collines" : 'show_collines = True',
    "show_rowlines" : 'show_rowlines = True' })


</t>
<t tx="michael.20060619222451.57">def printer(cls, **kwargs):
    return printer.PointPrinter(cls, **kwargs)

printer = classmethod(printer)
</t>
<t tx="michael.20060619222451.58">def __init__(self, *args, **kwargs):
    self.cols = {}
    self.rows = {}
    self.widgets = []
    MatplotChart.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060619222451.59">def create_axes(self, rect=None, **kwargs):
    pprop = self.get_patch
    rect = rect or [0, 0, 1, 1]
    fig = self.figure
    ax = fig.add_axes(faxes.PointAxes(fig, rect, **kwargs))
    ax.cla()
    ax.set_marker(pprop("focused.marker"), pprop("marker"))
    return ax
</t>
<t tx="michael.20060619222451.60">def create(self):
    if not isinstance(self.axes, faxes.PointAxes):
        raise RuntimeError("axes has to be an instance "\
                           "of PointAxes but is %s" \
                           % self.axes.__class__.__name__)

    push_active(self)

    header_transform = self.axes.build_margin_transform(top=False)
    def dumy(*args): pass

    try:
        self.create_all_widgets()
        self._finalize_row_widgets()
        self._finalize_col_widgets()

        utils.progress_start(_("create widgets for %s") \
                             % self.__class__.__name__,
                             len(self.widgets))

        count = 0
        for w in self.widgets:
            self.axes.add_widget(w)
            utils.progress_update(count)
            count += 1

        utils.progress_end()

        for r in self.rows.itervalues(): self.axes.add_widget(r)
        for c in self.cols.itervalues(): self.axes.add_widget(c)
    finally:
        pop_active()
</t>
<t tx="michael.20060619222451.61">def get_col(self, col_no):
    col = self.cols.get(col_no)
    if not col:
        widget.Column.show_colline = self.show_collines
        col = self.cols[col_no] = widget.Column()

    return col
</t>
<t tx="michael.20060619222451.62">def get_row(self, row_no=None):
    if row_no is None:
        if self.rows: 
            row_no = max(self.rows.keys()) + 1
        else:
            row_no = 0

    row = self.rows.get(row_no)
    if not row:
        widget.Row.show_rowline = self.show_rowlines
        row = self.rows[row_no] = widget.Row()

    return row
</t>
<t tx="michael.20060619222451.63">def add_cell(self, row_no, col_no, fobj, properties=None):
    row = self.get_row(row_no)
    col = self.get_col(col_no)
    cell = widget.CellWidget(row, col, fobj, properties)
    self.widgets.append(cell)
    return cell
</t>
<t tx="michael.20060619222451.64">def create_all_widgets(self):
    pass
</t>
<t tx="michael.20060619222451.65">def _finalize_row_widgets(self):
    row_widgets = filter(lambda w: hasattr(w, "row"), self.axes.widgets)
    if row_widgets:
        rows = map(lambda w: (w.row.y.get(), w.row), row_widgets)
        y = min(rows)[1].next_y()
    else:
        y = mtrans.zero()

    rows = self.rows.items()
    rows.sort()           #restore row order
    for rno, row in rows:
        y = row.set_y(y)
</t>
<t tx="michael.20060619222451.66">def _finalize_col_widgets(self):
    col_widgets = filter(lambda w: hasattr(w, "col"), self.axes.widgets)
    if col_widgets:
        cols = map(lambda w: (w.col.x.get(), w.col), col_widgets)
        x = max(cols)[1].next_x()
    else:
        x = mtrans.zero()

    cols = self.cols.items()
    cols.sort()
    for cno, col in cols:
        x = col.set_x(x)

</t>
<t tx="michael.20060619222451.67">class _DescriptionTable(TableChart):
	&lt;&lt; class _DescriptionTable declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.68">properties = { "edgecolor" : "black",
               "title.facecolor" : "darkgray",
               "title.antialiased" : True,
               "title.linewidth" : 1 }

</t>
<t tx="michael.20060619222451.69">def __init__(self, report, src_axes, paint_to=None, rect=None,
             property_prefix="", properties=None, **kwargs):
    self.src_axes = src_axes
    self.report = report
    self.property_prefix = property_prefix
    self.properties = properties or  { }
    TableChart.__init__(self, paint_to, rect, **kwargs)
</t>
<t tx="michael.20060619222451.70">def get_col(self, col_no):
    col = self.cols.get(col_no)
    if not col:
        class TitleColumn(widget.Column):
            def set_transform(self, transform):
                transform = self.axes.build_margin_transform(top=False)
                widget.Column.set_transform(self, transform)
                widget.Column.set_clip_box(self, transform.get_bbox2())

        TitleColumn.show_colline = self.show_collines
        col = self.cols[col_no] = TitleColumn()

    return col
</t>
<t tx="michael.20060619222451.71">def create_all_widgets(self):
    rows = { }
    cells = { }

    report = self.report()
    self.create_header(report)
    rows[-1] = self.header_row

    for r in report:
        for c in r:
            task, attrib = c.get_ref()[:2]
            if task: break
        else:
            continue

        src_widget = self.src_axes.find_widget(task)
        if not src_widget: continue

        for i, c in enumerate(r):
            col = self.get_col(i)
            row = rows.get(src_widget.row)
            if not row:
                row = rows[src_widget.row] = widget.Row()
                row.show_rowline = self.show_rowlines
                row.height = src_widget.row.height
                row.top_sep = src_widget.row.top_sep
                row.bottom_sep = src_widget.row.bottom_sep
                row.set_y(src_widget.row.y)

            task, attrib = c.get_ref()[:2]
            cell = cells.get((row, col))
            if not cell:
                cell = cells[(row, col)] = widget.CellWidget(row, col, task)
                cell.fattrib = attrib
                self.widgets.append(cell)

            #cell.vert_sep = row.top_sep + row.bottom_sep
            #row.top_sep = row.bottom_sep = 0
            self.modify_widget(cell, task, c)

    self.rows = rows
</t>
<t tx="michael.20060619222451.72">def create_header(self, report):
    class TitleWidget(object):
        def set_transform(self, transform):
            Point = mtrans.Point
            Bbox = mtrans.Bbox
            zero = mtrans.zero()

            point_to_pixel = self.axes.fig_point_to_pixel
            bbox = self.axes.bbox
            dbox = transform.get_bbox1()
            top_margin = self.axes.top_margin
            left = self.axes.left_margin * point_to_pixel
            right = self.axes.right_margin * point_to_pixel
            mheight = point_to_pixel * top_margin
            bheight = bbox.ur().y() - bbox.ll().y()
            offset = bheight - mheight

            view_box = Bbox(Point(bbox.ll().x() + left, 
                                  bbox.ll().y() + offset),
                            Point(bbox.ur().x() - right, 
                                  bbox.ur().y()))

            data_box = Bbox(Point(dbox.ll().x() , zero - top_margin),
                            Point(dbox.ur().x(), zero))

            transform = mtrans.get_bbox_transform(data_box, view_box)
            super(TitleWidget, self).set_transform(transform)
            super(TitleWidget, self).set_clip_box(bbox)


        def contains(self, x, y):
            return False


    class TitleRow(TitleWidget, widget.Row):
        def update_height(self, height): pass

    class TitleCell(TitleWidget, widget.CellWidget): pass

    self.header_row = TitleRow()
    self.header_row.axes = self.axes
    self.header_row.show_rowline = True
    self.header_row.top_sep = self.header_row.bottom_sep = 0
    self.header_row.height = Lazy(self.axes.top_margin)
    self.header_row.set_y(0)
    self.header_row._is_header = True
    kwargs = make_properties(self.get_property,
                             self.property_prefix+"title")
    back = patches.Polygon(((LEFT, TOP), (LEFT, BOTTOM),
                            (RIGHT, BOTTOM), (RIGHT, TOP)), **kwargs)
    self.header_row.add_artist(back)
    for i, header in enumerate(report.headers):
        col = self.get_col(i)
        col._is_header = True
        cell = TitleCell(self.header_row, col, None)
        cell._is_header = True
        self.modify_header_widget(cell, header)
        self.widgets.append(cell)
</t>
<t tx="michael.20060619222451.73">def _finalize_row_widgets(self):
    pass
</t>
<t tx="michael.20060619222451.74">def modify_header_widget(self, cell, title):
    cell.horz_sep = 6
    cell.text(title, 
              HCENTER, VCENTER,
              horizontalalignment ="center",
              verticalalignment="center",
              fontproperties=self.property_prefix+"title")
</t>
<t tx="michael.20060619222451.75">def modify_widget(self, widget, obj, cell):
    if widget.artists: return

    if cell.back_color:
        back = patches.Polygon(((LEFT, TOP), (LEFT, BOTTOM),
                                (RIGHT, BOTTOM), (RIGHT, TOP)),
                               facecolor=cell.back_color,
                               linewidth=0)
        widget.add_artist(back)


    halign = { cell.LEFT : "left",
               cell.RIGHT : "right",
               cell.CENTER : "center" }[cell.align]

    t = widget.text(str(cell), 
                    LEFT + 2 * HSEP, VCENTER,
                    horizontalalignment=halign,
                    verticalalignment="center",
                    fontproperties=self.property_prefix+"row")

    if cell.back_color: t.set_backgroundcolor(cell.back_color)
    if cell.text_color: t.set_color(cell.text_color)
    if cell.font_bold: t.set_weight("bold")
    if cell.font_italic: t.set_style("italic")
    if cell.font_size: t.set_size(cell.font_size)
    #if cell.left_border = None
    #if cell.top_border = False
    #if cell.right_border = True
    #if cell.bottom_border = True
    widget.horz_sep = 6
</t>
<t tx="michael.20060619222451.76">class TimeTabledChart(MatplotChart):
	&lt;&lt; class TimeTabledChart declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619222451.77">__type_name__ = "matplot_timechart"
__type_image__ = "gantt"

properties = { "background.facecolor" : "white" }

sharex = None
auto_scale_y = False
content_charts = ()
plot_chart = None
left_report = None
right_report = None

__attrib_completions__ = MatplotChart.__attrib_completions__.copy()
__attrib_completions__.update({\
    "sharex" : 'sharex = "time_shared"',
    "auto_scale_y" : 'auto_scale_y = True',
    "content_charts" : 'content_charts = ()',
    "plot_chart" : 'plot_chart = None',
    "left_report" : 'left_report = None',
    "right_report" : 'right_report = None'})


</t>
<t tx="michael.20060619222451.78">def printer(cls, **kwargs):
    return printer.TimeWidgetPrinter(cls, **kwargs)
</t>
<t tx="michael.20060619222451.79">printer = classmethod(printer)


def __init__(self, *args, **kwargs):
    self.charts = []
    self.time_scale = timescale._default_scale
    MatplotChart.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060619222451.80">def setup_axes_interface(self, axes):
    super(TimeTabledChart, self).setup_axes_interface(self.content_axes)
    self._share_axes = axes
    del self._check_limits
    del self._widget_at
    del self._mark_widget
</t>
<t tx="michael.20060619222451.81">def _check_limits(self, cut=True):
    self.left_axes.check_limits(cut)
    self.axes.check_limits(cut)
    self.right_report and self.right_axes.check_limits(cut)
</t>
<t tx="michael.20060619222451.82">def _widget_at(self, x, y):
    try:
        return self.content_axes.widget_at(x, y) \
               or self.left_axes.widget_at(x, y) \
               or self.right_axes.widget_at(x, y)
    except AttributeError:
        return None
</t>
<t tx="michael.20060619222451.83">def _mark_widget(self, widget):
    changed = 0
    changed += self.content_axes.mark_widget(widget)
    changed += self.left_axes.mark_widget(widget)
    try:
        changed += self.right_axes.mark_widget(widget)
    except AttributeError:
        pass

    return bool(changed)
</t>
<t tx="michael.20060619222451.84">def create_axes(self, rect=None, **kwargs):
    rect = ( 0, 0, 1, 1 )

    #be carefully the order of the following
    #is very important (and unfortunatly quite complicated)
    #A fine tuned use of lazy values...

    top_margin = kwargs["top_margin"] = mtrans.Value(0)
    self.left_axes = faxes.PointAxes(self.figure, ( 0, 0, 1, 1 ), **kwargs)
    self.figure.add_axes(self.left_axes).cla()

    #self.left_axes.point_to_pixel and self.left_axes.fig_point_to_pixel
    #have new lazy values after add_axes

    font_factor = self.left_axes.point_to_pixel \
                  / self.left_axes.fig_point_to_pixel

    right_data_lim = mtrans.unit_bbox()
    right_offset = self.figure.figwidth * mtrans.Value(72 / 2)\
                   - right_data_lim.ur().x() * font_factor

    self.right_axes = faxes.PointAxes(self.figure, ( 0.5, 0, 0.5, 1 ),
                                      left_margin=right_offset,
                                      sharey=self.left_axes,
                                      **kwargs)

    self.figure.add_axes(self.right_axes).cla()
    self.right_axes.dataLim = right_data_lim

    kwargs["left_margin"] = self.left_axes.dataLim.ur().x() * font_factor
    kwargs["right_margin"] = self.right_axes.dataLim.ur().x() * font_factor

    class MainAxes(faxes.TimeWidgetAxes):
        def update_time_axis(self):
            self.time_axis.show_scale = True #this axes must always have a scale
            faxes.TimeWidgetAxes.update_time_axis(self)

    main_axes = MainAxes(self.figure, rect, **kwargs)
    main_axes.auto_scale_y = self.auto_scale_y
    main_axes.set_navigate(False)

    kwargs["sharex"] = main_axes
    kwargs["sharey"] = self.left_axes
    self.content_axes = faxes.TimeWidgetAxes(self.figure, rect, **kwargs)
    self.content_axes.set_frame_on(False)

    self.figure.add_axes(main_axes).cla()
    self.figure.add_axes(self.content_axes).cla()

    #correct the axespatch of mainaxes
    dtrans = main_axes.build_margin_transform(top=False)
    atrans = mtrans.get_bbox_transform(mtrans.unit_bbox(),
                                       dtrans.get_bbox2())
    main_axes.axesPatch.set_transform(atrans)
    return main_axes
</t>
<t tx="michael.20060619222451.85">def create(self):
    push_active(self)
    self.charts = map(lambda c: c(self.content_axes), self.content_charts)

    if self.left_report:
        _DescriptionTable(self.left_report,
                          self.content_axes,
                          self.left_axes,
                          property_prefix="left.",
                          properties=self.properties)


    if self.right_report:
         _DescriptionTable(self.right_report,
                           self.content_axes,
                           self.right_axes,
                           property_prefix="right.",
                           properties=self.properties)

    prop = self.get_property
    pprop = self.get_patch
    self.figure.set_facecolor(prop("background.facecolor"))

    if self.left_axes.widgets:
        self.left_axes.set_axis_bgcolor(prop("left.background.facecolor"))
        self.left_axes.set_marker(pprop("left.focused.marker"),
                                  pprop("left.marker"))

    if not self.right_axes.widgets:
        self.figure.delaxes(self.right_axes)
        del self.right_axes
    else:
        self.right_axes.set_axis_bgcolor(prop("right.background.facecolor"))    
        self.right_axes.set_marker(pprop("right.focused.marker"),
                                   pprop("right.marker"))

    self.time_scale = self.content_axes.time_scale
    self.axes.xaxis_timescale(self.time_scale)
    self.content_axes.time_axis.set_visible(False)
    self.content_axes.update_time_axis()
    self.content_axes.set_axis_bgcolor(prop("content.background.facecolor"))
    self.content_axes.set_marker(pprop("focused.marker"), pprop("marker"))
    pop_active()
</t>
<t tx="michael.20060619222451.86">def get_tip(self, tipobj):
    if not self.show_tips: return
    for c in self.charts:
        info = c.get_tip(tipobj)
        if info: return info

    return None
</t>
<t tx="michael.20060619222451.87">def create_chart(self):
    pass
</t>
<t tx="michael.20060619222451.88">class TimeAxisTabledChart(TimeAxisChart, TimeTabledChart):
	&lt;&lt; class TimeAxisTabledChart declarations &gt;&gt;
</t>
<t tx="michael.20060619222451.89">__attrib_completions__ = TimeAxisChart.__attrib_completions__.copy()
__attrib_completions__.update(TimeTabledChart.__attrib_completions__)



</t>
<t tx="michael.20060619223120">def _dumy(): return None, None, None

matplotlib.backends.pylab_setup = _dumy

def _wrong_pylab_function(*args, **kwargs):
    raise RuntimeError("this function may not be called inside faces")

def _new_figure_manager(*args, **kwargs):
    return _figure_manager

pylab.switch_backend = _wrong_pylab_function
pylab.subplot_tool = _wrong_pylab_function
pylab.close = _wrong_pylab_function
pylab.show = _wrong_pylab_function
pylab.draw_if_interactive = _dumy
pylab.new_figure_manager = _new_figure_manager

class _DumyFigureManager(bases.FigureManagerBase):
    def __init__(self):
        self.canvas = None
        self.num = -1

    def key_press(self, event):
        pass

_figure_manager = _DumyFigureManager()
</t>
<t tx="michael.20060619225419">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;
&lt;&lt; Declarations &gt;&gt;

@others</t>
<t tx="michael.20060619225419.1">import faces
import faces.pcalendar as pcal
import faces.charting.charts as charts
import faces.charting.widgets as widget
import faces.charting.shapes as shapes
import faces.charting.timescale as timescale
import faces.charting.connector as connector
import faces.task as task
import faces.plocale
from faces.charting.tools import *
from faces.charting.shapes import *
</t>
<t tx="michael.20060619225419.2">_is_source_ = True
_ = faces.plocale.get_gettext()

_color_index = ( "navy",
                 "seagreen",
                 "indianred",
                 "violet",
                 "skyblue",
                 "purple",
                 "limegreen",
                 "darkgray" )


GanttWidget = widget.GanttWidget

__all__ = ("Standard", "Compare", "Critical") + shapes.__all__</t>
<t tx="michael.20060619225419.3">class Gantt(charts.TimeAxisWidgetChart):
    """
    A standard gantt chart

    @var show_connectors:
    A boolean value that specifies wether to display connectors between tasks.

    @var show_complete:
    A boolean value that specifies wether to display a completion bar
    inside the gantt bars.

    @var row_attrib:
    A string value specifying the name of the row attribute inside the
    project definitions.  With this attribute you can control in which
    row a task will be displayed.

    @var accumulate_attrib:
    A string value specifying the name of the accumulate attribute
    inside the project definitions.  If a parent task defines the
    accumulate attribute as True it will be displayed as
    leaf, and all child tasks will not be displayed.

    @var shape_attrib:
    A string value specifying the name of the shape attribute inside
    the project definitions.  The shape attribute controls the
    displayed shape of the gantt object.

    @var shape_properties_attrib:
    A string value specifying the name of the shape properties
    attribute inside the project definitions.  The shape properties
    attribute controls the style properties of the gantt object.

    @var parent_shape:
    A string value specifying the name of the general shape for parent tasks.

    @var milestone_shape:
    A string value specifying the name of the general shape for milestone tasks.

    @var leaf_shape:
    A string value specifying the name of the general shape for leaf tasks.

    @var title_attrib:
    A string value specifying the name of the task attribute that 
    should be displayed at the gantt object, to identify the task.

    @var show_resource:
    A boolean value that specifies wether to display the allocated
    resources after the title.
    """
	&lt;&lt; declarations &gt;&gt;
	@others

&lt;&lt; set __all__ attribute &gt;&gt;

</t>
<t tx="michael.20060619225419.4">__editor__ = ("faces.gui.edit_gantt", "Standard")

show_connectors = True
show_complete = True
row_attrib = "gantt_same_row"
accumulate_attrib = "gantt_accumulate"
shape_attrib = "gantt_shape"
shape_properties_attrib = "gantt_properties"
parent_shape = "brace"
milestone_shape = "diamond"
leaf_shape = "bar"
title_attrib = "title"
show_resource = True
properties = { "parent.facecolor": "black",
               "complete.facecolor" : "black",
               "connector.end.facecolor" : "darkslategray",
               "connector.end.edgecolor" : "darkslategray",
               "connector.edgecolor" : "darkslategray",
               "facecolor" : "blue",
               "milestone.facecolor" : "black",
               "background.facecolor" : "w",
               "height" : 4, "complete.height" : 2 }

__attrib_completions__ = charts.TimeAxisWidgetChart\
                         .__attrib_completions__.copy()
__attrib_completions__.update({\
    "show_resource" : 'show_resource = False',
    "show_connectors" : 'show_connectors = True',
    "show_complete" : 'show_complete = True',
    "row_attrib" : 'row_attrib = "gantt_same_row"',
    "accumulate_attrib" : 'accumulate_attrib = "gantt_accumulate"',
    "shape_attrib" : 'shape_attrib = "gantt_shape"',
    "shape_properties_attrib" : 'shape_properties_attrib = "gantt_properties"',
    "parent_shape" : 'parent_shape = "brace"',
    "milestone_shape" : 'milestone_shape = "diamond"',
    "leaf_shape" : 'leaf_shape = "bar"',
    "title_attrib" : 'title_attrib = "title"',
    "def create_objects" : """def create_objects(self, data):
for t in data:
yield t
""",
    "def modify_widget" : """def modify_widget(self, gantt_widget, task):
gantt_widget.text(task.to_string["%x"].start, 
LEFT, BOTTOM - 1.5 * VSEP, 
verticalalignment = "top",
horizontalalignment = "center") 
""",
    "def modify_connector" : """def modify_connector(self, src, dest, connector):
return True
"""
    })



</t>
<t tx="michael.20060619225419.5">def create_all_widgets(self, start_row):
    widgets = map(self.create_widget, self.create_objects(self.data))
    task_map = dict(map(lambda w: (w.fobj, w), widgets))

    if self.calendar is pcal._default_calendar:
        self.calendar = task_map.keys()[0].root.calendar

    self.time_scale = timescale.TimeScale(self.calendar)
    to_num = self.time_scale.to_num

    for w in widgets:
        w.start = to_num(w.start)
        w.end = to_num(w.end)

        row_task = getattr(w.fobj, self.row_attrib, None)
        if row_task and not w.fobj.is_inherited(self.row_attrib):
            row_widget = task_map.get(row_task)
            if row_widget: w.row = row_widget.row

    rows = self._finalize_row_widgets(widgets, start_row)
    if not self.show_rowlines:
        rows = filter(lambda t: t.all_artists(), rows)

    widgets.extend(rows)
    if not self.show_connectors: return widgets

    # make connectors
    connectors = []
    for w in widgets:
        if not w.fobj: continue

        try:
            sources = w.fobj._sources.iteritems()
        except AttributeError:
            sources = {}

        for dattrib, sources in sources:
            for s in sources:
                path, sattrib = faces.task._split_path(s)
                src_task = w.fobj.get_task(path)
                src_widget = task_map.get(src_task)
                if not src_widget: continue

                connectors.append((src_widget, sattrib, w, dattrib))

    widgets.extend(self.create_connectors(connectors))
    return widgets
</t>
<t tx="michael.20060619225419.6">def create_objects(self, data):
    for t in data:
        if getattr(t, self.accumulate_attrib, False) \
           and t.is_inherited(self.accumulate_attrib):
            continue

        yield t
</t>
<t tx="michael.20060619225419.7">def get_shape_name(self, task):
    if task.children and not getattr(task, self.accumulate_attrib, False):
        shape_name = self.parent_shape
    else:
        if task.milestone:
            shape_name = self.milestone_shape
        else:
            shape_name = self.leaf_shape

    return task.__dict__.get(self.shape_attrib, shape_name)
</t>
<t tx="michael.20060619225419.8">def get_property_group(self, task):
    if task.children and not getattr(task, self.accumulate_attrib, False):
        return "parent"

    if task.milestone:
        return "milestone"

    return "leaf"
</t>
<t tx="michael.20060619225419.9">def calc_title(self, task):
    """
    Calculate the task title.
    """
    if self.title_attrib:
        title = getattr(task, self.title_attrib)
    else:
        title = ""

    if self.show_resource:
        if task.booked_resource:
            title += " ("+ task.to_string.booked_resource + ")"
        elif task.performed_resource:
            title += " ("+ task.to_string.performed_resource + ")"

    return title
</t>
<t tx="michael.20060619225419.10">def make_shape(self, shape_name, gantt_widget, title, propname=None):
    """
    Assigns a shape to gantt_widget.
    """
    try:
        shape_func = getattr(self, "make_%s_shape" % shape_name)
    except AttributeError:
        if shape_name in shapes.symbols:
            self.make_symbol_shape(shape_name, gantt_widget,
                                   title, propname)
        else:
            self.make_combined_shape(shape_name, gantt_widget,
                                     title, propname)
    else:
        try:
            shape_func(gantt_widget, title, propname)
        except TypeError:
            shape_func(gantt_widget, title)
</t>
<t tx="michael.20060619225419.11">def create_widget(self, task):
    """
    Create a gantt widget for a task.
    """
    if isinstance(task, widget.Widget): return task

    title = self.calc_title(task)
    shape_name = self.get_shape_name(task)
    props = task.__dict__.get(self.shape_properties_attrib, None)
    gantt_widget = widget.GanttWidget(task.start, task.end,
                                      task, properties=props)
    gantt_widget.row.top_sep = gantt_widget.row.bottom_sep = 3
    self.make_shape(shape_name, gantt_widget, title)
    self.modify_widget(gantt_widget, task)
    return gantt_widget
</t>
<t tx="michael.20060619225419.12">def modify_widget(self, widget, task):
    """
    Overwrite this method to decorate a widget.
    """

modify_widget.args = (widget.GanttWidget, task.Task)</t>
<t tx="michael.20060619225419.13">def make_combined_shape(self, shape_name, widget, title, propname=None):
    end_shapes = shape_name.split("_bar_")
    if len(end_shapes) != 2:
        raise ValueError("Cannot find a shape %s" % shape_name)

    left, right = end_shapes
    left = getattr(shapes, left)
    right = getattr(shapes, right)

    try:
        complete = self.show_complete and widget.fobj.complete or 0
    except AttributeError:
        complete = 0

    propname = propname or self.get_property_group(widget.fobj)
    widget.set_shape(shapes.combibar, propname, left, right, complete)
    widget.text(title, HCENTER, TOP + VSEP,
                horizontalalignment ="center",
                verticalalignment="bottom",
                fontproperties=propname)
</t>
<t tx="michael.20060619225419.14">def make_symbol_shape(self, shape_name, widget, title, propname=None):
    propname = propname or self.get_property_group(widget.fobj)
    widget.set_shape(getattr(shapes, shape_name), propname)
    widget.text(title, RIGHT + HSEP, VCENTER,
                horizontalalignment ="left",
                verticalalignment="center",
                fontproperties=propname)
</t>
<t tx="michael.20060619225419.15">def make_bar_shape(self, widget, title, propname=None):
    try:
        complete = self.show_complete and widget.fobj.complete or 0
    except AttributeError:
        complete = 0

    propname = propname or self.get_property_group(widget.fobj)
    widget.set_shape(shapes.bar, propname, complete)
    widget.inside_text(title, RIGHT + HSEP, VCENTER,
                       verticalalignment="center",
                       inside_properties=propname+".inside",
                       fontproperties=propname)
</t>
<t tx="michael.20060619225419.16">def make_brace_shape(self, widget, title, propname=None):
    propname = propname or self.get_property_group(widget.fobj)
    widget.set_shape(shapes.brace, propname)
    widget.text(title, HCENTER, TOP + VSEP,
                horizontalalignment ="center",
                verticalalignment="bottom",
                fontproperties=propname)
</t>
<t tx="michael.20060619225419.17">def find_path(self, sa, da):
    aamap = {
        ("start", "start") : connector.StartStartPath,
        ("end", "start") : connector.EndStartPath,
        ("start", "end") : connector.StartEndPath,
        ("end", "end") : connector.EndEndPath }

    return aamap.get((sa, da)) #connector.ShortestPath
</t>
<t tx="michael.20060619225419.18">def create_connectors(self, connectors):
    cws = []
    for src, sa, dest, da in connectors:
        path = self.find_path(sa, da)
        if path:
            cw = connector.GanttConnector(src, dest, path)
            if self.modify_connector(src, dest, cw):
                cws.append(cw)

    return cws
</t>
<t tx="michael.20060619225419.19">def modify_connector(self, src, dest, connector):
    return True

modify_connector.args = (task.Task, task.Task, connector.GanttConnector)</t>
<t tx="michael.20060619225419.20">def get_tip(self, tipobj):
    if not self.show_tips: return
    try:
        if isinstance(tipobj.fobj, task.Task):
            return self.get_task_tip(tipobj.fobj)
    except AttributeError:
        pass

    return None
</t>
<t tx="michael.20060619225419.21">def get_task_tip(self, tsk):
    lines = [
        (_("Name"), tsk.title),
        (_("Timeframe"), "%s - %s" % (tsk.to_string.start,\
                                      tsk.to_string.end)),
        (_("Effort"), tsk.to_string.effort),
        (_("Length"), tsk.to_string.length),
        (_("Load"), tsk.to_string.load),
        (_("Complete"), tsk.to_string.complete),
        (_("Done"), tsk.to_string.done),
        (_("Todo"), tsk.to_string.todo)  ]

    append = lines.append
    if tsk.booked_resource:
        append((_("Resources"), tsk.to_string.booked_resource))
    elif tsk.performed_resource:
        append((_("Resources"), tsk.to_string.performed_resource))

    try:
        append((_("Buffer"), tsk.to_string.buffer))
    except task.RecursionError:
        pass

    return lines
</t>
<t tx="michael.20060619225419.22">class Critical(Standard):
    """
    A Gantt to visualize the critical chain.

    @var colors:
    Specify a dictionary, that defines colours for different
    buffer values.
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619225419.23">__type_image__ = "critical_gantt"
show_rowlines = False
show_connectors = True
colors = { "0d" : "red" }

__editor__ = ("faces.gui.edit_gantt", "Critical")
__attrib_completions__ = Standard.__attrib_completions__.copy()
__attrib_completions__.update({\
    "colors" : 'colors = { |"0d" : "red" }' })
del __attrib_completions__["def modify_widget"]


</t>
<t tx="michael.20060619225419.24">def __init__(self, *args, **kwargs):
    to_minutes = pcal._default_calendar.Minutes

    self._colors = map(lambda i: (to_minutes(i[0]), i[1]),
                       self.colors.items())
    self._colors.sort()
    self._colors.reverse()

    Standard.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060619225419.25">def modify_widget(self, widget, task):
    for v, c in self._colors:
        if task.buffer &lt;= v:
            shape_name = self.get_shape_name(task)
            group = self.get_property_group(task)
            widget.set_property("%s.facecolor" % group, c)
            widget.set_property("%s.bar.facecolor" % group, c)

    return widget
</t>
<t tx="michael.20060619225419.26">class Compare(Gantt):
    """
    A Gantt chart for comparing different projects.

    @var colors:
    Specifies a list of different colors for each project.
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619225419.27">__type_image__ = "compare_gantt"
colors = _color_index
show_rowlines = True
show_connectors = False

__editor__ = ("faces.gui.edit_gantt", "Compare")
__attrib_completions__ = Gantt.__attrib_completions__.copy()
__attrib_completions__.update({\
    "colors" : 'colors = ( "navy", "seagreen", "indianred")' })
del __attrib_completions__["def create_objects"]


</t>
<t tx="michael.20060619225419.28">def create_objects(self, data):
    colors = self.colors

    for task_list in data:
        if not isinstance(task_list, (tuple, list)):
            task_list = (task_list, )

        last = len(task_list) - 1
        sum_widget = None
        sum_start = 0
        sum_end = -0
        last_widget = None

        for i, task in enumerate(task_list):
            if not task: continue

            if getattr(task, self.accumulate_attrib, False) \
                   and task.is_inherited(self.accumulate_attrib):
                break

            if task.children:
                if not sum_widget:
                    sum_widget = self.create_widget(task)
                    sum_start = task.start
                    sum_end = task.end
                else:
                    sum_start = min(sum_start, task.start)
                    sum_end = max(sum_end, task.end)
            else:
                last_widget = widget = self.create_widget(task)
                shape_name = self.get_shape_name(task)
                widget.set_property("facecolor", colors[i % len(colors)])
                widget.row.show_rowline = False
                yield widget

        if last_widget:
            last_widget.row.show_rowline = self.show_rowlines

        if sum_widget:
            sum_widget.start = sum_start
            sum_widget.end = sum_end
            yield sum_widget
</t>
<t tx="michael.20060619230125">Gantt.__all__ = filter(lambda n: getattr(getattr(Gantt, n), "im_func", None) is None, dir(Gantt))
Gantt.__all__ += [ "calc_title", "make_shape", "create_widget"  ]
Gantt.__all__ = tuple(Gantt.__all__)</t>
<t tx="michael.20060619230818">@
Mathplot widgets
@code
@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others
</t>
<t tx="michael.20060619230818.1">import matplotlib.text as dtext
import patches
import sys
import faces.plocale
import matplotlib.artist as artist
import matplotlib.transforms as mtrans
import matplotlib.font_manager as font
from matplotlib.colors import colorConverter
import locale
import tools
from tools import *

</t>
<t tx="michael.20060619230818.2">class LazyText(dtext.Text):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.3">height_cache = {}

</t>
<t tx="michael.20060619230818.4">def __init__(self, x, y, text, *args, **kwargs):
    if isinstance(text, str):
        text = unicode(text, tools.chart_encoding)
    dtext.Text.__init__(self, x, y, text, *args, **kwargs)

def set_x(self, x):
    self._x = x

def set_y(self, y):
    self._y = y

</t>
<t tx="michael.20060619230818.5">def get_prop_tup(self):
    x, y = self._transform.xy_tup((self._x, self._y))
    return (float(self._x), float(self._y), x, y, self._text, self._color,
            self._verticalalignment, self._horizontalalignment,
            hash(self._fontproperties), self._rotation)
</t>
<t tx="michael.20060619230818.6">def draw(self, renderer):
    if self.get_size() &lt; 3: return False
    dtext.Text.draw(self, renderer)
    return True
</t>
<t tx="michael.20060619230818.7">def get_bottom_top(self, renderer):
    height = self.height_cache.get(hash(self._fontproperties))
    if height is None:
        w, height = renderer.get_text_width_height("Xg",
                                                   self._fontproperties,
                                                   False)
        self.height_cache[hash(self._fontproperties)] = height

    if self._verticalalignment=='center': yo = -height/2.
    elif self._verticalalignment=='top': yo = -height
    else: yo = 0
    xb, yb = self._transform.xy_tup((self._x, self._y))
    yt = yb + height
    return yb, yt
</t>
<t tx="michael.20060619230818.8">def get_window_extent(self, renderer=None):
    text = self._text
    self._text = self._text.replace(" ", "_")
    result = dtext.Text.get_window_extent(self, renderer)
    self._text = text
    return result
</t>
<t tx="michael.20060619230818.9">

class _PropertyType(type):
	@others
</t>
<t tx="michael.20060619230818.10">def __init__(cls, name, bases, dict_):
    super(_PropertyType, cls).__init__(name, bases, dict_)

    bchain = [ cls ]
    for b in (cls, ) + cls.__bases__:
        bchain.extend(getattr(b, "_base_chain", []))

    #remove duplicates and preserve order

    bchain = filter(lambda b: hasattr(b, "properties"), bchain)
    bchain = dict(zip(bchain, enumerate(bchain))).values()
    bchain.sort()
    bchain = map(lambda c: c[1], bchain)
    cls._base_chain = tuple(bchain)

    prop_vars = filter(lambda kv: kv[0].endswith("properties")\
                       and isinstance(kv[1], dict),
                       dict_.items())
    for pk, dv in prop_vars:
        for k, v in dv.iteritems():
            check_property(k, v)
</t>
<t tx="michael.20060619230818.11">def check_property(name, value):
    def do_raise(choices=None):
        if choices:
            raise ValueError(_('Invalid value "%(value)s" '\
                               'for property "%(name)s. Possible Values are: %(choices)s"') %
                             { "name" : name, "value" : str(value), 'choices' : choices } )
        else:
            raise ValueError(_('Invalid value "%(value)s" '\
                               'for property "%(name)s"') %
                             { "name" : name, "value" : str(value) } )

    def name_mends(*args):
        for n in args:
            if name.endswith(n): return True
        return False

    name_ends = name.endswith

    if name_ends("color"):
        try:
            colorConverter.to_rgb(value)
        except ValueError:
            do_raise()

    elif name_mends("width", "alpha", "magnification", "height"):
        try:
            float(value)
        except ValueError:
            do_raise()

    elif name_ends("family"):
        try:
            font.fontManager.ttfdict[value]
        except KeyError:
            default_names = ['serif', 'sans-serif', 'cursive',
                             'fantasy', 'monospace', 'sans']
            if value not in default_names:
                do_raise(", ".join(font.fontManager.ttfdict.keys()\
                                   + default_names))

    elif name.endswith("weight"):
        try:
            if not (isinstance(value, basestring) and font.weight_dict[value]):
                int(value)
        except Exception:
            do_raise()

    elif name.endswith("size"):
        try:
            if not (isinstance(value, basestring) and font.font_scalings[value]):
                int(value)
        except Exception:
            do_raise()

    elif name.endswith("variant"):
        if value not in ('normal', 'capitals', 'small-caps'):
            do_raise()

    elif name.endswith("linestyle"):
        if value not in ("solid", "dashed", "dashdot", "dotted"):
            do_raise()

    elif name.endswith("joinstyle"):
        if value not in ('miter', 'round', 'bevel'):
            do_raise()

    elif name.endswith("style"):
        if value not in ("italics", "oblique", "normal"):
            do_raise()

    elif name == "tickers":
        if not isinstance(value, (tuple, list, int)):
            do_raise()
</t>
<t tx="michael.20060619230818.12">




class _PropertyAware(object):
	&lt;&lt; class _PropertyAware declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.13">__metaclass__ = _PropertyType 

search_chain = ()
font_attribs = ("family", "style", "weight", "size", "variant")
patch_attribs = ("edgecolor", "linewidth", "antialiased", \
                 "fill", "facecolor", "alpha" )


</t>
<t tx="michael.20060619230818.14">def __init__(self, properties=None):
    self.properties = {}
    if properties:
        self.properties.update(properties)
</t>
<t tx="michael.20060619230818.15">def set_property(self, name, value):
    """
    Sets a specific property
    """
    check_property(name, value)
    self.properties[name] = value
</t>
<t tx="michael.20060619230818.16">def remove_property(self, name):
    """
    Removes a property, and restores a default value.
    """

    try:
        del self.properties[name]
    except:
        pass
</t>
<t tx="michael.20060619230818.17">def _find_property_in_chain(self, name):
    try:
        return self.properties[name]
    except KeyError:
        pass

    for s in getattr(self, "search_chain", ()):
        try:
            return s._find_property_in_chain(name)
        except KeyError: pass


    for s in self._base_chain:
        try:
            return s.properties[name]
        except KeyError: pass

    raise KeyError(name)
</t>
<t tx="michael.20060619230818.18">def _find_property(self, name):
    index = 0
    while True:
        try:
            value = self._find_property_in_chain(name[index:])
            self.properties[name] = value
            return value
        except KeyError: pass
        index = name.find(".", index) + 1
        if index &lt;= 0: break

    raise KeyError("Key error: %s" % name)
</t>
<t tx="michael.20060619230818.19">def get_font(self, name):
    kwargs = {}
    for a in self.font_attribs:
        kwargs[a] = self.get_property(name + "." + a)

    return font.FontProperties(**kwargs)
</t>
<t tx="michael.20060619230818.20">def get_property(self, name, default=None):
    try:
        return self._find_property(name)
    except KeyError:
        if default is not None:
            return default
        raise
</t>
<t tx="michael.20060619230818.21">def set_gc(self, gc, name=""):
    prop = self.get_property
    if gc:
        gc.set_foreground(prop(name + ".edgecolor"))
        gc.set_linewidth(prop(name + ".linewidth"))
        gc.set_linestyle(prop(name + ".linestyle"))
        gc.set_antialiased(prop(name + ".antialiased"))
        gc.set_alpha(prop(name + ".alpha"))
    else:
        prop(name + ".edgecolor")
        prop(name + ".linewidth")
        prop(name + ".linestyle")
        prop(name + ".antialiased")
        prop(name + ".alpha")
</t>
<t tx="michael.20060619230818.22">def get_patch(self, name=""):
    kwargs = {}
    for a in self.patch_attribs:
        kwargs[a] = self.get_property(name + "." + a)

    return kwargs
</t>
<t tx="michael.20060619230818.23">class Widget(artist.Artist, _PropertyAware):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.24">properties = {
    "weight" : "normal",
    "size" : "medium",
    "style" : "normal",
    "variant" : "normal", 
    "color": 'black',
    "facecolor" : 'black',
    "edgecolor" : 'black',
    "linewidth" : 1,
    "joinstyle" : 'miter',
    "linestyle" : 'solid',
    "fill" : 1,
    "antialiased" : True,
    "alpha" : 1.0 }

search_chain = (chart_properties,)

bbox = mtrans.unit_bbox()
fobj = None

</t>
<t tx="michael.20060619230818.25">def __init__(self, properties=None):
    _PropertyAware.__init__(self, properties)
    artist.Artist.__init__(self)
    self.artists = []
</t>
<t tx="michael.20060619230818.26">def _extend_text_properties(self, kwargs):
    fp = kwargs.get("fontproperties", "")
    if not isinstance(fp, font.FontProperties):
        kwargs["fontproperties"] = self.get_font(fp)

    if not kwargs.has_key("color") and isinstance(fp, basestring):
        kwargs["color"] = self.get_property(fp + ".color")

    return kwargs
</t>
<t tx="michael.20060619230818.27">def clear(self):
    """
    Clears all decorations of the widget.
    """
    self.artists = []

clear.__call_completion__ = "clear()"
</t>
<t tx="michael.20060619230818.28">def text(self, txt, x, y, **kwargs):
    """
    Adds a text decoration to the widget.
    """
    kwargs = self._extend_text_properties(kwargs)
    artist = LazyText(x, y, txt, **kwargs)
    self.artists.append(artist)
    return artist

text.__call_completion__ = """text("|",
HCENTER, TOP + VSEP,
horizontalalignment="center",
verticalalignment="bottom",
fontproperties="center")
"""    
</t>
<t tx="michael.20060619230818.29">def set_figure(self, figure):
    artist.Artist.set_figure(self, figure)
    for t in self.all_artists():
        t.set_figure(figure)
</t>
<t tx="michael.20060619230818.30">def set_transform(self, transform):
    artist.Artist.set_transform(self, transform)
    for t in self.all_artists():
        t.set_transform(transform)
</t>
<t tx="michael.20060619230818.31">def set_clip_box(self, clipbox):
    artist.Artist.set_clip_box(self, clipbox)
    for t in self.all_artists():
        t.set_clip_box(clipbox)
</t>
<t tx="michael.20060619230818.32">def all_artists(self):
    return self.artists
</t>
<t tx="michael.20060619230818.33">def add_artist(self, artist):
    self.artists.insert(0, artist)

add_artist.__call_completion__ = "add_artist(|)"
</t>
<t tx="michael.20060619230818.34">def set_font_factor(self, point_to_pixel, fig_point_to_pixel):
    """
    Change the fontsize, if the canvas is zoomed
    """
    font_factor = Lazy(point_to_pixel / fig_point_to_pixel)
    for t in filter(lambda t: isinstance(t, dtext.Text), self.artists):
        size = t.get_size()
        t.set_size(font_factor * t.get_size())
</t>
<t tx="michael.20060619230818.35">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    """
    returns a pair of boolean values:
    The first value means horizontal data_limits should be updated)
    The second value means vertical data_limits should be updated
    """
    raise NotImplementedError()
</t>
<t tx="michael.20060619230818.36">def overlaps(self, bbox):
    return bbox.overlaps(self.bbox)
</t>
<t tx="michael.20060619230818.37">def contains(self, x, y):
    return self.bbox.contains(x, y)
</t>
<t tx="michael.20060619230818.38">def get_bounds(self, renderer):
    raise NotImplementedError()
</t>
<t tx="michael.20060619230818.39">class Row(Widget):
    """
    This class represents a row within a chart

    @var top_sep:
    Top space between row content and the row's
    top edge in VSEP units.

    @var bottom_sep:
    Bottom space between row content and the row's
    bottom edge in VSEP units.
    """
	&lt;&lt; class Row declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.40">properties = { "edgecolor" : 'gray',
               "linewidth" : 1,
               "linestyle" : 'solid',
               "alpha" : 1.0,
               "antialiased" : True }

top_sep = 2
bottom_sep = 2
show_rowline = False
zorder = -100

</t>
<t tx="michael.20060619230818.41">def __init__(self, properties=None):
    Widget.__init__(self, properties)
    self.y = Lazy(0)
    self.height = Lazy(0)
    self.show_rowline = self.__class__.show_rowline

    #fetch line properties
    if self.show_rowline: self.set_gc(None, "row")
</t>
<t tx="michael.20060619230818.42">def update_height(self, height):
    self.height.set(max(self.height.get(), height))
</t>
<t tx="michael.20060619230818.43">def draw(self, renderer, data_box):
    data_box = self.get_transform().get_bbox1()
    if not self.get_visible() or not self.overlaps(data_box): return False

    all_artists = self.all_artists()
    if all_artists:
        set_helpers(self.bbox, self.bbox)
        for a in self.all_artists(): a.draw(renderer)

    if not self.show_rowline: return False
    def prop(name): return self.get_property(name)
    transform = self.get_transform()

    gc = renderer.new_gc()
    if self.get_clip_on():
        gc.set_clip_rectangle(self.clipbox.get_bounds())

    left, right = self.bbox.intervalx().get_bounds()
    self.set_gc(gc, "row")
    y = self.bottom - self.bottom_sep * VSEP
    y = y.get()
    draw_line(renderer, gc, left, y, right, y, transform)
    return bool(self.fobj)
</t>
<t tx="michael.20060619230818.44">def set_y(self, y):
    self.y = Lazy(y)
    self.bottom = self.y - self.height - self.top_sep * VSEP
    return self.next_y()
</t>
<t tx="michael.20060619230818.45">def full_height(self):
    return self.height + (self.top_sep + self.bottom_sep) * VSEP
</t>
<t tx="michael.20060619230818.46">def next_y(self):
    return self.y - self.full_height()
</t>
<t tx="michael.20060619230818.47">def reset_height(self):
    self.height.set(0)
</t>
<t tx="michael.20060619230818.48">def contains(self, x, y):
    return bool(self.fobj) and self.bbox.contains(x, y)
</t>
<t tx="michael.20060619230818.49">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    data_box = self.get_transform().get_bbox1()
    all_artists = self.all_artists()
    if all_artists:
        bbox = mtrans.unit_bbox()
        set_helpers(bbox, bbox)
        extent = lambda t: t.get_window_extent(renderer)
        bb_all = mtrans.bbox_all(map(extent, all_artists))
        bbox = mtrans.transform_bbox(self.get_transform(), bbox)
        height = (bb_all.ymax() - bbox.ymin()) / fig_point_to_pixel.get()
        self.update_height(height)

    Point = mtrans.Point
    Value = mtrans.Value

    t = self.y.val
    b = self.bottom - self.bottom_sep * VSEP
    b = b.val
    self.bbox = mtrans.Bbox(Point(data_box.ll().x(), b),
                            Point(data_box.ur().x(), t))

    return False, True
</t>
<t tx="michael.20060619230818.50">def get_bounds(self, renderer):
    return self.bbox
</t>
<t tx="michael.20060619230818.51">class Column(Widget):
	&lt;&lt; class Column declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.52">properties = { "edgecolor" : 'gray',
               "linewidth" : 1,
               "linestyle" : 'solid',
               "alpha" : 1.0,
               "antialiased" : True }

left_sep = 1
right_sep = 1
show_colline = False
zorder = -100

</t>
<t tx="michael.20060619230818.53">def __init__(self, properties=None):
    Widget.__init__(self, properties)
    self.x = Lazy(0)
    self.width = Lazy(0)
    self.show_colline = self.__class__.show_colline

    #fetch line properties
    if self.show_colline: self.set_gc(None, "col")
</t>
<t tx="michael.20060619230818.54">def update_width(self, width):
    self.width.set(max(self.width.get(), width))
</t>
<t tx="michael.20060619230818.55">def draw(self, renderer, data_box):
    data_box = self.get_transform().get_bbox1()
    if not self.get_visible() or not self.overlaps(data_box): return False

    all_artists = self.all_artists()
    if all_artists:
        set_helpers(self.bbox, self.bbox)
        for a in self.all_artists(): a.draw(renderer)

    if not self.show_colline: return
    def prop(name): return self.get_property(name)
    transform = self.get_transform()

    gc = renderer.new_gc()
    if self.get_clip_on():
        gc.set_clip_rectangle(self.clipbox.get_bounds())

    bottom, top = self.bbox.intervaly().get_bounds()
    self.set_gc(gc, "col")
    x = self.x + self.width + (self.left_sep + self.right_sep) * HSEP
    x = x.get()
    draw_line(renderer, gc, x, bottom, x, top, transform)
    return False
</t>
<t tx="michael.20060619230818.56">def set_x(self, x):
    self.x = Lazy(x)
    return self.next_x()
</t>
<t tx="michael.20060619230818.57">def full_width(self):
    return self.width + (self.left_sep + self.right_sep) * HSEP
</t>
<t tx="michael.20060619230818.58">def next_x(self):
    return self.x + self.full_width()
</t>
<t tx="michael.20060619230818.59">def reset_width(self):
    self.width.set(0)
</t>
<t tx="michael.20060619230818.60">def contains(self, x, y):
    return False
</t>
<t tx="michael.20060619230818.61">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    Point = mtrans.Point
    Value = mtrans.Value
    data_box = self.get_transform().get_bbox1()
    HSEP.set(VSEP.get())

    l = self.x.val
    r = self.x + self.width + (self.left_sep + self.right_sep) * HSEP
    r = r.val
    self.bbox = mtrans.Bbox(Point(l, data_box.ll().y()),
                            Point(r, data_box.ur().y()))
    return True, False
</t>
<t tx="michael.20060619230818.62">def get_bounds(self, renderer):
    return self.bbox
</t>
<t tx="michael.20060619230818.63">_two = Lazy(2)

class CellWidget(Widget):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.64">min_height = 0
min_width = 0
vert_sep = 2
horz_sep = 2

</t>
<t tx="michael.20060619230818.65">def __init__(self, row, col, fobj, properties=None):
    Widget.__init__(self, properties)
    self.row = row
    self.col = col
    self.fobj = fobj
</t>
<t tx="michael.20060619230818.66">def get_bounds(self, renderer):
    return self.bbox
</t>
<t tx="michael.20060619230818.67">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    #calculate cell bounding box
    Point = mtrans.Point
    Bbox = mtrans.Bbox
    HSEP.set(VSEP.get())
    left = self.col.x + self.col.left_sep * HSEP
    right = left + self.col.width
    top = self.row.y - self.row.top_sep * VSEP
    bottom = self.row.bottom
    self.bbox = Bbox(Point(left.val, bottom.val), Point(right.val, top.val))
    self.row.update_height(self.min_height)
    self.col.update_width(self.min_width)

    #get height and width
    set_helpers(self.bbox, self.bbox)
    extent = lambda t: t.get_window_extent(renderer)
    text_artists = filter(lambda t: isinstance(t, dtext.Text), self.artists)
    bb_all = mtrans.bbox_all(map(extent, text_artists))

    self.row.update_height(bb_all.height() / fig_point_to_pixel.get()\
                           + self.vert_sep * VSEP.get())
    self.col.update_width(bb_all.width() / fig_point_to_pixel.get() \
                          + self.horz_sep * HSEP.get())

    return True, True
</t>
<t tx="michael.20060619230818.68">def draw(self, renderer, data_box):
    data_box = self.get_transform().get_bbox1()
    if not self.get_visible() or not self.overlaps(data_box): return False
    set_helpers(self.bbox, self.bbox)
    #print "draw cell", self.artists[0].get_text(), self.bbox.get_bounds()
    for a in self.all_artists(): a.draw(renderer)
    return True
</t>
<t tx="michael.20060619230818.69">class TableWidget(Widget):
    """
    A table widget, that can have other widgets in its cells
    """

	@others

</t>
<t tx="michael.20060619230818.70">def __init__(self, rows, cols, properties=None):
    super(TableWidget, self).__init__(properties)
    self.cells = [ [ None ] * cols for r in range(rows) ]
</t>
<t tx="michael.20060619230818.71">def get_bounds(self, renderer):
    self.check_font_factor(renderer)
    return self.bbox
</t>
<t tx="michael.20060619230818.72">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    zero = mtrans.zero
    Point = mtrans.Point
    BBox = mtrans.Bbox

    widest_cells = self.widest_cells = [ None ] * len(self.cells[0])
    max_widths = [ 0 ] * len(widest_cells)

    highest_cells = self.highest_cells = [ ]

    zorder = sys.maxint
    for row in self.cells:
        max_height = 0
        highest_cell = None
        for c, cell in enumerate(row):
            cell.prepare_draw(renderer, point_to_pixel, fig_point_to_pixel)

            w = cell.bbox.width()
            h = cell.bbox.height 
            if w &gt; max_widths[c]:
                widest_cells[c] = cell
                max_widths[c] = w

            if h &gt; max_height:
                highest_cell = cell
                max_height = h

            zorder = min(zorder, cell.zorder)

        highest_cells.append(highest_cell)

    self.zorder = zorder - 1

    self.width = w = sum([c.width for c in self.widest_cells])
    self.height = h = sum([c.height for c in self.highest_cells])

    x = y = Lazy(0)
    self.bbox = BBox(Point(x.val, y.val), 
                     Point(x.val + w.val, y.val + h.val))

    self.prepare_draw = self.prepare_draw_stage2
    return True, True
</t>
<t tx="michael.20060619230818.73">def draw(self, renderer, data_box):
    data_box = self.get_transform().get_bbox1()
    if not self.get_visible() or not self.overlaps(data_box): return False

    self.check_font_factor(renderer)
    set_helpers(self.bbox, self.bbox)
    for a in self.all_artists(): a.draw(renderer)

    transform = self.get_transform()

    l = self.bbox.ll().x()
    r = self.bbox.ur().x()
    b = self.bbox.ll().y()
    t = self.bbox.ur().y()

    lf = l.get()
    rf = r.get()
    tf = t.get()
    bf = b.get()

    gc = renderer.new_gc()
    self.set_gc(gc, "rowlines")
    ry = t

    for c in self.highest_cells:
        ry -= c.height
        ryf = ry.get()
        draw_lines(renderer, gc, (lf, rf), (ryf, ryf), transform)

    rx = l
    for c in self.widest_cells:
        rxf = rx.get()
        draw_lines(renderer, gc, (rxf, rxf), (bf, tf), transform)
        rx += c.width

    return True

</t>
<t tx="michael.20060619230818.74">class TimeWidget(Widget):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.75">properties = {
    "inside.color" : "white",
    "valign" : 'center',
    "magnification" : 1.0 }

shape_height = 8
start = sys.maxint
end = 0
row = Row
</t>
<t tx="michael.20060619230818.76">def __init__(self, start, end, fobj, row=None, properties=None):
    Widget.__init__(self, properties)
    self.start = start
    self.end = end
    self.row = row or Row()
    self.fobj = fobj
    self.text_inside = ()
    self.shape = ()
</t>
<t tx="michael.20060619230818.77">def set_shape(self, shape, *args, **kwargs):
    """
    Sets the widgetes shape.

    @args: (shape, shape_arg1, ...)
    """
    self.shape_func = (shape, args, kwargs)

set_shape.__call_completion__ = "set_shape(|)"
</t>
<t tx="michael.20060619230818.78">def all_artists(self):
    return tuple(self.artists) + self.shape
</t>
<t tx="michael.20060619230818.79">def finalized_row(self):
    #now the row is fixed: it is time to get the shape
    factor = Lazy(self.shape_height)
    self.height = mtrans.Value(0)
    self.depth = mtrans.Value(0)

    bb_bottom = self.row.bottom
    dh = self.row.height - self.height

    valign = self.get_property("valign")
    if valign == "center":
        bb_bottom += dh / _two
    elif valign == "top":
        bb_bottom += dh

    bottom = bb_bottom + self.depth
    top = bottom + factor * VSEP
    vcenter = (top + bottom) / _two

    left = Lazy(self.start)
    right = Lazy(self.end)
    hcenter = (left + right) / _two

    globs = self.shape_func[0].func_globals
    old_globs = {}
    def set_glob(name, value):
        old_globs[name] = globs.get(name)
        globs[name] = value

    set_glob("LEFT", left)
    set_glob("RIGHT", right)
    set_glob("TOP", top)
    set_glob("BOTTOM", bottom)
    set_glob("HCENTER", hcenter)
    set_glob("VCENTER", vcenter)
    set_glob("FACTOR", factor)
    self.shape = self.shape_func[0](self.get_property,
                                    *self.shape_func[1],
                                    **self.shape_func[2])
    globs.update(old_globs)

    bb_top = bottom + self.height
    self.shape_bbox = mtrans.Bbox(mtrans.Point(left.val, bb_bottom.val),
                                  mtrans.Point(right.val, bb_top.val))

    for s in self.shape:
        s.set_figure(self.get_figure())
        s.set_clip_box(self.get_clip_box())
        s.set_transform(self.get_transform())

    del self.shape_func
</t>
<t tx="michael.20060619230818.80">def inside_text(self, txt, x=None, y=None,
                inside_properties="inside",
                **kwargs):
    """
    Adds a text decoration inside the widget.
    If x and y are not None, the text will be
    placed at that position, if the text is larger
    than the widget's width.
    """

    if not txt: return

    def prop(name): return self.get_property(name)
    inside = LazyText(HCENTER, VCENTER,
                      txt, prop(inside_properties + ".color"),
                      "center", "center",
                      fontproperties=self.get_font(inside_properties))

    if x is None:
        self.text_inside = ( inside, )
    else:
        kwargs = self._extend_text_properties(kwargs)
        self.text_inside = ( LazyText(x, y, txt, **kwargs), inside )

    self.artists.extend(self.text_inside)
    return self.text_inside

inside_text.__call_completion__ = """inside_text("|",
RIGHT + HSEP, VCENTER,
horizontalalignment="left",
verticalalignment="center",
fontproperties="right")"""
</t>
<t tx="michael.20060619230818.81">def get_bounds(self, renderer):
    show = self.fobj.name in ("Outer", "inner")

    transform = self.get_transform()
    extent = lambda t: t.get_window_extent(renderer)

    # calc shape bounding (in data coords)
    bb_shape = mtrans.bound_vertices(self.shape[0].get_verts())
    bb_shape_view = mtrans.transform_bbox(transform, bb_shape) # in view coords

    set_helpers(bb_shape, bb_shape)

    if self.text_inside:
        &lt;&lt; check if inside text fits into the shape &gt;&gt;

    bb_text = map(extent, filter(lambda t: t.get_visible(), self.artists))
    bb_text.append(bb_shape_view)

    #complete bounding box
    bb_all = mtrans.bbox_all(bb_text)

    inverse = mtrans.inverse_transform_bbox
    self.bbox = inverse(self.get_transform(), bb_all)

    return self.bbox
</t>
<t tx="michael.20060619230818.82">def overlaps(self, bbox):
    return bbox.overlaps(self.shape_bbox)
</t>
<t tx="michael.20060619230818.83">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.finalized_row()

    if not isinstance(self.artists, tuple):
        self.artists = tuple(self.artists)

    #calc bounding box
    trans = self.get_transform()
    bb_shape = mtrans.bound_vertices(self.shape[0].get_verts())
    bb_shape_view = mtrans.transform_bbox(trans, bb_shape)

    set_helpers(bb_shape, bb_shape)

    bottom = sys.maxint
    top = -sys.maxint

    for te in [ t for t in self.artists if isinstance(t, dtext.Text) ]:
        b, t = te.get_bottom_top(renderer)
        bottom = min(b, bottom)
        top = max(t, top)

    bb_all = bb_shape_view
    bb_all.intervaly().set_bounds(min(bb_all.ymin(), bottom),
                                  max(bb_all.ymax(), top))

    #calc height and depth
    pxl_height = bb_all.height()
    pxl_depth = bb_shape_view.ymin() - bb_all.ymin()

    self.depth.set(pxl_depth / fig_point_to_pixel.get())
    self.height.set(pxl_height / fig_point_to_pixel.get())
    self.row.update_height(self.height.get())
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)
    self.bbox = self.shape_bbox
    return True, True
</t>
<t tx="michael.20060619230818.84">def draw(self, renderer, data_box):
    if not self.get_visible() or not self.overlaps(data_box): return False

    transform = self.get_transform()
    bb_shape = mtrans.bound_vertices(self.shape[0].get_verts())
    bb_data = transform.get_bbox1()
    set_helpers(bb_shape, bb_data)

    bbox = mtrans.transform_bbox(transform, bb_shape.deepcopy())
    if not self.prepare_inside_text(renderer, bbox): return False

    for s in self.shape:
        s.draw(renderer)

    for t in self.artists:
        if t.get_visible() and t.draw(renderer):
            bb = t.get_window_extent()
            bbox.update(((bb.xmin(), bb.ymin()),
                         (bb.xmax(), bb.ymax())), False)

    self.bbox = mtrans.inverse_transform_bbox(transform, bbox)
    return True
</t>
<t tx="michael.20060619230818.85">def prepare_inside_text(self, renderer, bb_shape):
    if not self.text_inside: return True

    contains = bb_shape.contains

    al_text = self.text_inside[0]
    in_text = self.text_inside[-1]
    in_text.set_visible(True)

    inside = in_text.get_window_extent(renderer)
    mid = (inside.ymin() + inside.ymax()) / 2

    if contains(inside.xmin(), mid) and contains(inside.xmax(), mid):
        al_text.set_visible(False)
        in_text.set_visible(True)
    else:
        al_text.set_visible(True)
        in_text.set_visible(False)

    return True
</t>
<t tx="michael.20060619230818.86">class GanttWidget(TimeWidget):
    """
    A Widget for gantt charts

    @var shape_height:
    Specifies the height of the widget in VSEPS

    @var row:
    Specifies the row of the widget within the chart.
    """
</t>
<t tx="michael.20060619230818.87">class ResourceBarWidget(TimeWidget):
    """
    A widget for resource charts

    @var row:
    Specifies the row of the widget within the chart.
    """
	&lt;&lt; class ResourceBarWidget declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060619230818.88">load_factor = 12
zorder = -10

</t>
<t tx="michael.20060619230818.89">def __init__(self, task, row, start, end, load, offset, properties=None):
    props = { "valign" : "bottom" }
    if properties: props.update(properties)
    TimeWidget.__init__(self, start, end, task, row, props)

    self.zorder = -offset
    self.offset = offset
    self.load = load

    def shape(props):
        import shapes
        kwargs = make_properties(props, "bar")
        l = self.load_factor * font.fontManager.get_default_size()
        return (patches.Rectangle((LEFT, BOTTOM), 
                                  RIGHT - LEFT, round(l * load, 3),
                                  **kwargs),)

    self.set_shape(shape)
</t>
<t tx="michael.20060619230818.90">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    result = TimeWidget.prepare_draw(self, renderer, point_to_pixel,
                                     fig_point_to_pixel)

    l = self.load_factor * font.fontManager.get_default_size()
    self.row.update_height(l * (self.offset + self.load))
    self.row.update_height(l)
    self.depth.set(round(l * self.offset, 3))
    for t in self.text_inside:
        t.max_size = t._fontproperties.get_size()

    return result
</t>
<t tx="michael.20060619230818.91">__last_size = (0, 0)
def prepare_inside_text(self, renderer, bb_shape):
    if not self.text_inside: return True

    if bb_shape.width() / self.get_figure().get_dpi() &lt;= 0.08:
        for s in self.shape:
            s.draw(renderer)

        self.bbox = mtrans.inverse_transform_bbox(self.get_transform(),
                                                  bb_shape)
        return False

    view_box = self.get_transform().get_bbox2()

    width = min(view_box.xmax(), bb_shape.xmax())\
            - max(view_box.xmin(), bb_shape.xmin())

    height = min(view_box.ymax(), bb_shape.ymax())\
            - max(view_box.ymin(), bb_shape.ymin())


    if self.__last_size == (width, height): return True

    self.__last_size = (width, height)
    in_text = self.text_inside[-1]
    in_text.set_visible(True)
    in_text.set_size(in_text.max_size)
    in_text.set_rotation(0)
    tbbox = in_text.get_window_extent(renderer)

    sep = 0.07 * self.get_figure().get_dpi() # 0.1 inch
    width -= sep
    height -= sep

    wfactor = min(width / tbbox.width(), height / tbbox.height())

    if wfactor &lt; 1:
        hfactor = min(width / tbbox.height(), height / tbbox.width(), 1.0)
        if hfactor &gt; wfactor:
            wfactor = hfactor
            in_text.set_rotation(90)
        else:
            in_text.set_rotation(0)

        size = wfactor * float(in_text.max_size)
        in_text.set_visible(size &gt; 1)
        in_text.set_size(wfactor * float(in_text.max_size))

    return True
</t>
<t tx="michael.20060619230818.92">def get_bounds(self, renderer):
    self.bbox = mtrans.bound_vertices(self.shape[0].get_verts())
    return self.bbox
</t>
<t tx="michael.20060619232254">def get_object(self):
    return self.pseudo
</t>
<t tx="michael.20060619234514">def _get__all__(self):
    return dir(ftask.Task) \
           + ["up", "root", "me", "to_string", "calendar"] \
           + self.dict_children.keys()

__all__ = property(_get__all__)</t>
<t tx="michael.20060619235739">def __getattr__(self, name):
    if name in self.dict_children:
        return self.dict_children[name]

    return getattr(ftask.Task, name)
</t>
<t tx="michael.20060621114845">@first #! /usr/bin/python
@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;
&lt;&lt; Setting Globals &gt;&gt;

@others

if __name__ == "__main__":
    if _faces._PROFILING:
        import profile
        import pstats

        profile.run("main()", "profile_out")
        p = pstats.Stats('profile_out')
        p.strip_dirs().sort_stats('cumulative').print_stats(40)
    else:
        sys.exit(main())
</t>
<t tx="michael.20060621114845.1">import sys

try:
    if sys.frozen:
        import encodings
except AttributeError:
    import wxversion
    wxversion.select(['2.6', '2.8'])
    #wxPython 2.4 is not support since version 0.7.0

import wx.html
import os
import time
import locale

try:
    #threading can cause problems when reloaded,
    #causing nasty error messages at exit if generator module is used
    #importing it here will avoid a reload when refreshing a project
    import threading
except:
    pass


try:
    import gc
    collect_garbage = gc.collect
    #gc.set_debug(gc.DEBUG_LEAK)
except:
    def collect_garbage(): pass

from metapie.gui import controller, MetaApp, ResourceManager    
import faces.plocale
import os.path
import re
import faces as _faces

_faces.set_default_chart_font_size(8)
_faces.gui_controller = controller

import faces.observer as _observer
import faces.generator # see threading
from faces.gui.editor import PlanEditor, PlanEditorProxy
import faces.gui.repview
import faces.gui.chartview
import faces.gui.graphview
import faces.gui.utils as gutils
import metapie.navigator as navigator
import metapie.gui.session as session
import inspect
import linecache
import stat
import new
import types
import traceback
import warnings
import faces.utils
import ConfigParser
from wx.lib.fancytext import RenderToBitmap
</t>
<t tx="michael.20060621114845.2">_is_source_ = True

if not wx.USE_UNICODE:
    def null_gettext(): return lambda x: x
    faces.plocale.get_gettext = null_gettext

_ = faces.plocale.get_gettext()

current_directory = ""
_warning_registry = { }
_installation_path = faces.utils.get_installation_path()
_resource_path = faces.utils.get_resource_path()
_template_path = os.path.join(_resource_path, "templates")</t>
<t tx="michael.20060621114845.3">def title_of_path(path):
    return os.path.split(path)[1]
</t>
<t tx="michael.20060621114845.4">def is_project_file(path, main_path=None):
    path = os.path.abspath(path)
    path = os.path.normcase(path)

    if path == main_path: return True
    if not os.access(path, os.W_OK): return False

    if current_directory and path.startswith(current_directory):
        return True

    return False
</t>
<t tx="michael.20060621114845.5">def getsourcefile(obj):
    try:
        if isinstance(obj, str):
            obj = sys.modules.get(obj)

        return inspect.getabsfile(obj)
    except:
        pass

    return ""
</t>
<t tx="michael.20060621114845.6">def _generate_menu_wrapper(executer, obj):
    msg = wx.MessageBox
    frame = controller().GetTopWindow()

    to_execute = getattr(obj, "faces_execute", obj)

    if hasattr(obj, "faces_openfile"):
        fname = obj.faces_openfile
        def wrapper():
            dlg = wx.FileDialog(frame, _("Choose a file"),
                                os.path.split(fname)[0],
                                os.path.split(fname)[1],
                                _("All Files|*"), wx.OPEN)
            if dlg.ShowModal() == wx.ID_OK:
                path = dlg.GetPath()
                if executer.save_execute(to_execute, path):
                    obj.faces_openfile = path
                    msg(_("%s('%s') was executed successfully")\
                        % (obj.__name__, path),
                        _("Success"), style=wx.ICON_INFORMATION|wx.OK)
                collect_garbage()
            dlg.Destroy()

    elif hasattr(obj, "faces_savefile"):
        fname = obj.faces_savefile
        def wrapper():
            dlg = wx.FileDialog(frame, _("Choose a filename"),
                                os.path.split(fname)[0],
                                os.path.split(fname)[1],
                                _("All Files|*"), wx.SAVE)
            if dlg.ShowModal() == wx.ID_OK:
                path = dlg.GetPath()
                if executer.save_execute(to_execute, path):
                    obj.faces_savefile = path
                    msg(_("%s('%s') was executed successfully")\
                        % (obj.__name__, path),
                        _("Success"), style=wx.ICON_INFORMATION|wx.OK)
                collect_garbage()
            dlg.Destroy()

    elif hasattr(obj, "faces_savedir"):
        dname = obj.faces_savedir

        def wrapper():
            dlg = wx.DirDialog(frame, _("Select Directory to save to"), dname)
            if dlg.ShowModal() == wx.ID_OK:
                path = dlg.GetPath()
                if executer.save_execute(to_execute, path):
                    obj.faces_savedir = path
                    msg(_("%s('%s') was executed successfully")\
                        % (obj.__name__, path),
                        _("Success"), style=wx.ICON_INFORMATION|wx.OK)
                collect_garbage()
            dlg.Destroy()
    else:
        def wrapper():
            if executer.save_execute(to_execute):
                msg(_("%s() was executed successfully") % obj.__name__,
                    _("Success"), style=wx.ICON_INFORMATION|wx.OK)

    return wrapper
</t>
<t tx="michael.20060621114845.7">class PlanBuffer(navigator.Model):
	@others
</t>
<t tx="michael.20060621114845.8">def __init__(self, path, is_main_buffer=False):
    self.text = ""
    path = os.path.abspath(path)
    path = os.path.normcase(path)
    self.path = path
    self.editor_id = None
    self.mod_time = 0
    self.is_modified = None
    self.resources = {}
    self.calendars = {}
    self.editor = PlanEditor(self)
    self.is_main_buffer = is_main_buffer
    self.active_views = {}
    self.consider_backup = True

</t>
<t tx="michael.20060621114845.9">def close(self):
    #try:
    #    self.editor.Destroy()
    #    self.editor = None
    #except AttributeError: pass
    self.remove_backup_file()
</t>
<t tx="michael.20060621114845.10">def __del__(self):
    self.close()
</t>
<t tx="michael.20060621114845.12">def refresh(self):
    &lt;&lt; find path and consider backups &gt;&gt;

    mod_time = os.stat(path)[stat.ST_MTIME]
    if self.mod_time &lt; mod_time:
        f = file(path, "r")
        self.text = f.read()\
                    .replace("\r\n", "\n")\
                    .replace("\r", "\n")\
                    .replace("\t", " " * 8)
        f.close()
        &lt;&lt; fix efficiency misspelling &gt;&gt;

        self.mod_time = mod_time
        if self.is_main_buffer:
            _faces.set_chart_encoding(self.get_encoding())

        refresh_text = True
    else:
        refresh_text = False

    self.editor.refresh(refresh_text)
    if self.consider_backup and self.remove_backup_file(): self.save_buffer()
    self.consider_backup = False</t>
<t tx="michael.20060621114845.13">def __str__(self):
    return title_of_path(self.path)
</t>
<t tx="michael.20060621114845.14">def _right_click_(self, event, view):
    if not view: return

    module = controller().session.get_module(self.path)
    obj = getattr(module, view, None)
    if not obj: return

    def find_in_source(): self.find_in_source(obj)
    ctrl = controller()
    menu = ctrl.make_menu()
    menu.make_item(self, _("Find in Source"), find_in_source, "findsource16")

    button = event.GetButtonObj()
    pos = button.ScreenToClient(wx.GetMousePosition())
    button.PopupMenu(menu.wxobj, pos)
</t>
<t tx="michael.20060621114845.15">def register(self):
    ctrl = controller()
    ctrl.freeze()

    factory = lambda parent: PlanEditorProxy(self, parent)
    title = title_of_path(self.path)
    self.editor_id = ctrl.register_view(self, title, factory, "edit")
    ctrl.thaw()
</t>
<t tx="michael.20060621114845.16">def accept_sibling(self, sibling):
    if isinstance(sibling, PlanBuffer):
        if str(sibling) &lt; str(sibling):
            return navigator.SIBLING_ABOVE
        else:
            return navigator.SIBLING_BELOW

    return False
</t>
<t tx="michael.20060621114845.17">def get_encoding(self):
    line_end = 0
    for i in range(2):
        line_end = self.text.find("\n", line_end + 1)

    mo = re.search(r"coding[:=]\s*([-\w.]+)", self.text[:line_end])
    if mo: return mo.group(1)
    return "ascii"
</t>
<t tx="michael.20060621114845.18">def save(self):
    if self.path.startswith(_template_path): return self.menu_save_as()

    self.set_menus()
    ctrl = controller()
    ctrl.session.check_for_correction()
    ctrl.frame.SetCursor(wx.HOURGLASS_CURSOR)
    ctrl.status_bar.SetStatusText(_("Saving..."), 0)
    wx.CallAfter(self.__deferred_save)
    wx.CallAfter(ctrl.frame.SetCursor, wx.NullCursor)
    wx.CallAfter(ctrl.status_bar.SetStatusText, "", 0)
    wx.CallAfter(self.set_focus, True)
</t>
<t tx="michael.20060621114845.19">def get_backup_file(self):
    if self.path.startswith(_template_path): return ""
    ndir, nbase = os.path.split(self.path)
    return os.path.join(ndir, "#%s#" % nbase)
</t>
<t tx="michael.20060621114845.20">def remove_backup_file(self):
    try:
        os.unlink(self.get_backup_file())
        return True
    except OSError:
        pass
    return False
</t>
<t tx="michael.20060621114845.21">def save_backup(self):
    view = self.get_edit_view(False)
    if not view: return
    path = self.get_backup_file()
    if not path: return
    view.sync_text()
    f = file(path, "wb")
    f.write(self.text)
    f.close()
</t>
<t tx="michael.20060621114845.22">def __deferred_save(self):
    self.save_buffer()
    linecache.checkcache()        
    controller().session.execute_plan()
</t>
<t tx="michael.20060621114845.23">def save_buffer(self):
    self.editor.sync_text(True)
    f = file(self.path, "wb")
    f.write(self.text)
    f.close()
    self.remove_backup_file()
    mod_time = os.stat(self.path)[stat.ST_MTIME]
    self.mod_time = mod_time

</t>
<t tx="michael.20060621114845.24">def modified(self, is_modified=True):
    if self.is_modified != is_modified:
        self.is_modified = is_modified
        self.set_menus()
</t>
<t tx="michael.20060621114845.25">def menu_save_as(self):
    directory = current_directory
    if not directory or directory.startswith(_template_path):
        directory = os.getcwd()

    dlg = wx.FileDialog(controller().GetTopWindow(),
                        _("Choose a filename"),
                        directory,
                        "",
                        _("Faces Files (*.py)|*.py"),
                        wx.SAVE|wx.OVERWRITE_PROMPT)
    if dlg.ShowModal() == wx.ID_OK:
        try:
            str(dlg.GetPath())
        except UnicodeEncodeError:
            wx.MessageBox(_("Filenames may only contain ascii characters."),
                          _("Error"), style=wx.ICON_ERROR|wx.OK)
        else:
            root, ext = os.path.splitext(dlg.GetPath())
            if not root: return
            self.path = root + ".py"
            self.path = os.path.abspath(self.path)
            self.path = os.path.normcase(self.path)

            view = self.get_edit_view(False)
            if view: view.sync_text()

            ctrl = controller()
            ctrl.remove_model(self)
            ctrl.add_model(self)
            ctrl.session.add_recent_file(self.path)
            self.set_menus()
            self.save()

    dlg.Destroy()
</t>
<t tx="michael.20060621114845.26">def set_focus(self, create_view=False):
    view = self.get_edit_view(create_view)
    if view: view.SetFocus()
</t>
<t tx="michael.20060621114845.27">def set_menus(self):
    ctrl = controller()

    top = ctrl.get_top_menu()
    file_menu = top.make_menu(_("&amp;File"))

    menu = lambda *args, **kw: \
           file_menu.make_item(self, *args, **kw)

    toolbar = ctrl.get_toolbar()
    toolbar.make_tool(self, "save", self.save,
                      "filesave22").enable(bool(self.is_modified))
    toolbar.make_tool(self, "saveas", self.menu_save_as,
                      "filesaveas22").enable(True)

    menu(_("&amp;Save\tCTRL-S"), self.save, "filesave16",
         pos=30).enable(bool(self.is_modified))
    menu(_("&amp;Save as..."), self.menu_save_as, "filesaveas16",
         pos=40).enable(True)
</t>
<t tx="michael.20060621114845.28">def get_edit_view(self, create_view=True):
    ctrl = controller()
    if create_view:
        view = ctrl.create_view(self.editor_id)
    else:
        view = ctrl.get_active_view_by_id(self.editor_id)

    return view
</t>
<t tx="michael.20060621114845.31">def show_object(self, caller, fobj, attrib=None):
    model = self._find_model(fobj)
    model._show_object(caller, fobj, attrib)

__show_object_called = False
def _show_object(self, caller, fobj, attrib=None):
    if self.__show_object_called: return
    self.__show_object_called = True

    try:
        edit_view = None
        views = controller().get_all_views()
        for v in views:
            if v is caller: continue

            if isinstance(v, PlanEditorProxy):
                edit_view = v
                continue

            try:
                v.show_object(fobj, attrib, caller)
            except AttributeError:
                pass

        if edit_view:
            if edit_view.model() is not self:
                edit_view = self.get_edit_view(True)

            edit_view.show_object(fobj, attrib, caller)

    finally:
        self.__show_object_called = False

def _find_model(self, fobj):
    """
    find the model of a task object
    """
    try:
        path = inspect.getabsfile(getattr(fobj, "_function", None))
    except TypeError:
        try:
            path = inspect.getabsfile(fobj)
        except TypeError:
            return self

    path = os.path.normcase(path)
    if path != self.path:
        for m in controller().get_planbuffers():
            if m.path == path:
                return m

    return self        </t>
<t tx="michael.20060621114845.33">def goto_source(self, line):
    self.get_edit_view(True).goto_line(line)
</t>
<t tx="michael.20060621114845.34">def find_in_source(self, obj):
    self.get_edit_view(True).find_in_source(obj)
</t>
<t tx="michael.20060621114845.35">def set_observer(self, observer):
    #observer is a directory of all observers of the model
    #the keys consist of a tuple of
    #(observer.__type_name__, observer.__type_image__)
    #the values are a list of tuples of (observer_title, observe_class)

    active_views = self.active_views
    all_observers = reduce(lambda x, y: x + y, observer.values(), [])
    new_views = dict(map(lambda v: (v[0], -1), all_observers))

    # unregister all observers which are not
    # in the plan file anymore
    ctrl = controller()
    for view, id_ in active_views.iteritems():
        if not new_views.has_key(view):
            ctrl.unregister_view(id_)

    self.active_views = new_views
    keys = observer.keys()
    keys.sort()
    pos = 1
    for k in keys:
        v = observer[k]
        factory = _observer.factories.get(k[0])
        if factory:
            pos = self.__set_views(k[0], factory, v, pos)
</t>
<t tx="michael.20060621114845.36">def __set_views(self, name, create_factory, new_views, pos):
    ctrl = controller()
    active_views = self.active_views

    new_views.sort()
    for t, v in new_views:
        factory = create_factory(t, v, self)
        id_ = ctrl.register_view(self, t, factory, v.__type_image__, pos=pos)
        active_views[t] = id_
        view = ctrl.get_active_view_by_id(id_)
        if view: view.replace_data(v)
        pos += 1

    return pos
</t>
<t tx="michael.20060621114845.37">class _Executer:
	&lt;&lt; class _Executer declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060621114845.38">menus_owner = "mown"

</t>
<t tx="michael.20060621114845.39">def __init__(self):
    self.main_buffer = None
    self.evaluations = {}
    self.loaded_modules = {}
    self.tmp_files_to_remove = []
</t>
<t tx="michael.20060621114845.40">def get_module(self, path):
    for module in self.loaded_modules.values():
        try:
            if module._faces_source_file == path:
                return module
        except AttributeError: pass
        except KeyError: pass        

    return None

</t>
<t tx="michael.20060621114845.41">def remove_modules(self):
    for m in self.loaded_modules.keys():
        &lt;&lt; remove module &gt;&gt;

    self.evaluations.clear()
    self.loaded_modules.clear()

</t>
<t tx="michael.20060621114845.42">def clear_cache(self):
    _faces.task.clear_cache()
    for v in _observer.clear_cache_funcs.itervalues(): v()
    for p in self.tmp_files_to_remove:
        try:
            os.unlink(p)
        except OSError:
            pass

    self.tmp_files_to_remove = []
</t>
<t tx="michael.20060621114845.43">def execute_plan(self):
    ctrl = controller()
    ctrl.progress_start(_("calculate project"), 8)

    _warning_registry.clear()
    self.clear_logs()
    self.clear_cache()

    ctrl.progress_update(1)
    collect_garbage()

    self.save_execute(self.__execute_module)
    ctrl.freeze()
    try:
        ctrl.progress_update(6)
        self.__refresh_active_buffer_list()
        self.__refresh_view_list()        
    finally:
        ctrl.thaw()

    ctrl.progress_update(7)
    self.remove_empty_logview()

    ctrl.progress_update(8)
    ctrl.progress_end()

    logger = ctrl.get_active_view_by_id(ctrl.session.logger_id)
    if logger:
        focus = logger
    else:
        focus = self.main_buffer.get_edit_view(True)

    focus.SetFocus()</t>
<t tx="michael.20060621114845.44">def save_execute(self, func, *args, **kwargs):
    try:
        return func(*args, **kwargs)
    except SyntaxError, e:
        sys.stderr.write('%s %s File "%s", line %i\n'
                         % (e.__class__.__name__,
                            e.msg, e.filename, e.lineno))
    except Exception, e:
        self.traceback(e, sys.exc_info()[2])

    return None</t>
<t tx="michael.20060621114845.45">def __refresh_active_buffer_list(self):
    ctrl = controller()

    &lt;&lt; get all loaded source files &gt;&gt;
    for m in ctrl.get_planbuffers():
        if m.path in files:
            del files[m.path]
        else:
            #remove obsolete PlanBuffer
            ctrl.remove_model(m)

    &lt;&lt; add new plan buffers &gt;&gt;
</t>
<t tx="michael.20060621114845.46">def __refresh_view_list(self):
    ctrl = controller()
    &lt;&lt; init collections &gt;&gt;
    &lt;&lt; define is_valid_module &gt;&gt;

    public_attribs = lambda obj: filter(lambda n: n[0] != "_", dir(obj))
    getabsfile = inspect.getabsfile

    for module in filter(is_valid_module, self.loaded_modules.values()):
        &lt;&lt; import a possible gui part of the module &gt;&gt;
        path = module._faces_source_file

        for k in public_attribs(module):
            v = getattr(module, k)
            &lt;&lt; check if k, v is an observer &gt;&gt;
            &lt;&lt; check if k, v is an project evaluation &gt;&gt;
            &lt;&lt; check if k, v is a resource &gt;&gt;
            &lt;&lt; check if k, v is a calendar &gt;&gt;
            &lt;&lt; check if k, v has menu &gt;&gt;

    self.evaluations.clear()
    for v in evaluations.itervalues():
        self.evaluations.update(v)

    &lt;&lt; assign collections to models &gt;&gt;
    &lt;&lt; create Toolmenu &gt;&gt;
</t>
<t tx="michael.20060621114845.47">def __execute_module(self):
    global current_directory

    path = self.main_buffer.path
    (current_directory, filename) = os.path.split(path)

    &lt;&lt; check filename &gt;&gt;
    &lt;&lt; remove modules that have to be reloaded &gt;&gt;

    actual_modules = {}
    actual_modules.update(sys.modules)

    &lt;&lt; init main_module &gt;&gt;

    tmp_path = sys.path[0]
    sys.path[0] = current_directory
    try:
        &lt;&lt; fetch code and execute it &gt;&gt;
        &lt;&lt; find imported modules &gt;&gt;

        self.loaded_modules["__faces_main__"] =\
            sys.modules["__faces_main__"] = main_module
    finally:
        sys.path[0] = tmp_path
        controller().progress_update(5)
        if not "__faces_main__" in self.loaded_modules:
            self.loaded_modules["__faces_main__"] =\
                sys.modules["__faces_main__"] = main_module    

    return True
</t>
<t tx="michael.20060621114845.48">class ShellView(session.ShellView):
	@others
</t>
<t tx="michael.20060621114845.49">def __init__(self, parent, locals=None):
    session.ShellView.__init__(self, parent, locals)
    wx.EVT_SET_FOCUS(self, self._on_get_focus)
</t>
<t tx="michael.20060621114845.50">def _on_get_focus(self, event):
    top = controller().get_top_menu()
    edit_menu = top.make_menu(_("&amp;Edit"), pos=100)
    menu = lambda *args, **kw: edit_menu.make_item(self, *args, **kw)
    menu(_("&amp;Undo\tCTRL-Z"), self.Undo, "undo16", pos=100)
    menu(_("&amp;Redo\tCTRL-R"), self.Redo, "redo16", pos=200)
    menu(_("Cut\tCTRL-X"), self.Cut, "editcut16", pos=300)
    menu(_("&amp;Copy\tCTRL-C"), self.Copy, "editcopy16", pos=400)
    menu(_("&amp;Paste\tCTRL-V"), self.Paste, "editpaste16", pos=500)
    event.Skip()
</t>
<t tx="michael.20060621114845.51">class LoggerView(session.MessageLogger):
	@others
</t>
<t tx="michael.20060621114845.52">def __init__(self, parent):
    session.MessageLogger.__init__(self, parent)
    wx.EVT_SET_FOCUS(self, self._on_get_focus)
</t>
<t tx="michael.20060621114845.53">def _on_get_focus(self, event):
    top = controller().get_top_menu()
    edit_menu = top.make_menu(_("&amp;Edit"), pos=100)
    menu = lambda *args, **kw: edit_menu.make_item(self, *args, **kw)
    menu(_("&amp;Copy\tCTRL-C"), self.Copy, "editcopy16", pos=400)
    event.Skip()
</t>
<t tx="michael.20060621114845.54">class Session(session.Session, _Executer):
	&lt;&lt; class Session declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060621114845.55">LOGGER = LoggerView

</t>
<t tx="michael.20060621114845.56">def __init__(self):
    session.Session.__init__(self)
    _Executer.__init__(self)

    def open_shell(parent):
        try:
            dict = sys.modules["__faces_main__"].__dict__
        except KeyError:
            dict = globals()

        return ShellView(parent, dict)

    self.SHELL_FACTORY = open_shell
    self.help = None

    config = controller().config
    try:
        self.recent_files = config.get("DEFAULT", "recent_files").split(",")
        self.recent_files = map(str.strip, self.recent_files)
        self.recent_files = filter(bool, self.recent_files)
    except ConfigParser.NoOptionError:
        self.recent_files = []
</t>
<t tx="michael.20060621114845.57">def end_session(self):
    self.clear_cache()
    controller().config.set("DEFAULT", "recent_files",
                            ",".join(self.recent_files))
</t>
<t tx="michael.20060621114845.58">def get_help(self):
    if not self.help:
        wx.FileSystem.AddHandler(wx.ZipFSHandler())
        self.help = wx.html.HtmlHelpController()
        self.help.AddBook(os.path.join(_resource_path,
                                       "help", "faces.zip"), True)
    return self.help
</t>
<t tx="michael.20060621114845.59">def jump_to_file(self, path, line):
    path = os.path.normcase(path)
    for m in controller().get_planbuffers():
        if m.path == path:
            m.goto_source(line)
</t>
<t tx="michael.20060621114845.60">def set_menus(self):
    top = controller().get_top_menu()

    wx.App.SetMacHelpMenuTitleName(_("&amp;Help"))
    help_menu = top.make_menu(_("&amp;Help"), pos=sys.maxint, id=wx.ID_HELP)
    menu = lambda *args, **kw: help_menu.make_item(self, *args, **kw)
    menu(_("&amp;Content and Index"), self.menu_help)
    menu(_("&amp;Send Project..."), self.menu_send_project)

    menu(_("&amp;Howtos..."), self.menu_howtos)
    item = menu(_("&amp;About"), controller().show_splash, id=wx.ID_ABOUT)
    wx.App.SetMacAboutMenuItemId(item.id)

    if check_memory: menu(_("Check Memory"), check_memory)

    file_menu = top.make_menu(_("&amp;File"))

    menu = lambda *args, **kw: file_menu.make_item(self, *args, **kw)
    menu(_("&amp;New..."), self.menu_new, "filenew16",
         help=_("New faces file"), pos=0)
    menu(_("&amp;Open..."), self.menu_open, "fileopen16",
         help=_("Open faces file"), pos=10)

    self.recent_menu = file_menu.make_menu(\
        _("&amp;Recent Files"), help=_("Open recently used files"), pos=15)

    self.update_recent_menu()
    self.close_menu = menu(_("&amp;Close"), self.menu_close,
                           "fileclose16",
                           pos=20)

    menu(_("&amp;Save\tCTRL-S"), 1, "filesave16", pos=30).enable(False)
    menu(_("&amp;Save as..."), 2, "filesaveas16", pos=40).enable(False)
    menu(_("Recalculate\tF5"), self.menu_recalc, "rebuild16", pos=50,
         help=_("Recalculate Project"))
    self.close_menu.enable(False)

    toolbar = controller().get_toolbar()

    toolbar.make_tool(self, "new", self.menu_new, "filenew22",
                      short=_("New Project"))

    toolbar.make_tool(self, "open", self.menu_open, "fileopen22",
                      short=_("Open Project"),
                      long="open file")

    toolbar.make_tool(self, "close", self.menu_close,
                      "fileclose22",
                      short=_("Close Project"),
                      long="close file")

    toolbar.make_tool(self, "save", 1, "filesave22",
                      short=_("save"), long="save file").enable(False)

    toolbar.make_tool(self, "saveas", 2, "filesaveas22",
                      short=_("save as")).enable(False)

    toolbar.make_tool(self, "recalculate", self.menu_recalc, "rebuild22",
                      short=("Recalculate"),
                      long=_("Recalculate Project"))

    toolbar.realize()
</t>
<t tx="michael.20060621114845.61">def add_recent_file(self, path):
    path = os.path.abspath(path)
    path = os.path.normcase(path)

    try:
        self.recent_files.remove(path)
    except ValueError:
        pass

    self.recent_files.insert(0, path)
    del self.recent_files[8:]
    self.update_recent_menu()
</t>
<t tx="michael.20060621114845.62">__recent_owner = object()
def update_recent_menu(self):
    file_menu = controller().get_top_menu().make_menu(_("&amp;File"))
    self.recent_menu = file_menu.make_menu(\
        _("&amp;Recent Files"), help=_("Open recently used files"), pos=15)

    self.recent_menu.make_item(None, "dumy", None) #dummy to avoid the deletion of the menu
    self.recent_menu.remove_by_owner(self.__recent_owner)
    def make_open_file(f):
        def open_file(): self.open_file(f)
        return open_file

    for f in self.recent_files:
        self.recent_menu.make_item(self.__recent_owner, f,
                                   make_open_file(f))

    self.recent_menu.remove_by_owner(None)
</t>
<t tx="michael.20060621114845.63">def register(self):
    session.Session.register(self)
    self.set_menus()
</t>
<t tx="michael.20060621114845.64">def menu_recalc(self):
    if not self.main_buffer: return
    view = self.main_buffer.get_edit_view(False)
    if view: view.sync_text()

    self.check_for_correction()
    self.execute_plan()</t>
<t tx="michael.20060621114845.65">def menu_help(self):
    #import webbrowser
    #webbrowser.open("http://faces.homeip.net/book/index.html")
    self.get_help().DisplayContents()
</t>
<t tx="michael.20060621114845.66">def menu_send_project(self):
    def get_text(module):
        if not isinstance(module, PlanBuffer): return None
        view = module.get_edit_view(False)
        if view: view.sync_text()
        return (module.path, module.text)

    models = controller().id_to_model.values()
    projects = filter(bool, map(get_text, models))
    if not projects: return
    sender = gutils.ProjectSender()
    sender.add_recipient("mreithinger@web.de",
                         "Faces Project Files",
                         projects)
    sender.send()
    controller().session.tmp_files_to_remove.append(sender.path)
</t>
<t tx="michael.20060621114845.67">def menu_howtos(self):
    dlg = wx.FileDialog(controller().GetTopWindow(),
                        _("Choose a howto file"),
                        faces.utils.get_howtos_path(),
                        "",
                        _("Faces Files (*.py)|*.py"),
                        wx.OPEN)
    if dlg.ShowModal() == wx.ID_OK:
        self.open_file(dlg.GetPath())
    dlg.Destroy()
</t>
<t tx="michael.20060621114845.68">def menu_new(self):
    templates = filter(lambda f: f.endswith(".py"),
                       os.listdir(_template_path))
    dlg = wx.SingleChoiceDialog(controller().GetTopWindow(),
                                _("The following templates are available:"),
                                _("Choose Template"),
                                templates)
    if dlg.ShowModal() == wx.ID_OK:
        template = dlg.GetStringSelection()
        self.open_file(os.path.join(_template_path, template), False)
    dlg.Destroy()
</t>
<t tx="michael.20060621114845.69">def menu_open(self):
    dlg = wx.FileDialog(controller().GetTopWindow(),
                        _("Choose a file"),
                        current_directory or os.getcwd(),
                        "",
                        _("Faces Files (*.py)|*.py"),
                        wx.OPEN)
    if dlg.ShowModal() == wx.ID_OK:
        self.open_file(dlg.GetPath())
    dlg.Destroy()
</t>
<t tx="michael.20060621114845.70">def menu_close(self):
    if not self.check_modified_buffers(): return False
    self.close_menu.enable(False)
    self.main_buffer = None
    for m in controller().get_planbuffers():
        m.close()
        controller().remove_model(m)

    self.remove_modules()
    self.clear_logs()
    return True
</t>
<t tx="michael.20060621114845.71">def open_file(self, path, add_recent=True):
    if not self.menu_close(): return
    self.close_menu.enable(True)
    self.main_buffer = PlanBuffer(path, True)
    self.main_buffer.refresh()

    dirname = os.path.dirname(path)
    if dirname:
        os.chdir(dirname)

    controller().add_model(self.main_buffer)
    self.execute_plan()
    self.main_buffer.set_focus(True)
    if add_recent: self.add_recent_file(self.main_buffer.path)
</t>
<t tx="michael.20060621114845.72">def check_modified_buffers(self):
    for m in controller().get_planbuffers():
        if m.is_modified:
            answer = wx.MessageBox(_("The file %s was modified."
                                     " Should it be saved?") % m.path,
                                   _("Close Buffer"),
                                   wx.YES_NO|wx.CANCEL|wx.ICON_QUESTION)
            if answer == wx.YES:
                m.save_buffer()
            elif answer == wx.CANCEL:
                return False
            else:
                m.close()

    return True
</t>
<t tx="michael.20060621114845.73">def showwarning(message, category, filename, lineno, file=None):
    if _warning_registry.has_key((filename, lineno)):
        return

    _warning_registry[(filename, lineno)] = True
    print &gt;&gt; sys.stderr, warnings.formatwarning(message, category, filename, lineno)
</t>
<t tx="michael.20060621114845.74">def check_installation():
    import time
    try:
        time.strptime("1.1.2005 10:30", "%d.%m.%Y %H:%M")
    except Exception, e:
        print &gt;&gt; sys.stderr, "Error in installation(time.strptime):"
        print &gt;&gt; sys.stderr, e
</t>
<t tx="michael.20060621114845.75">if _faces._DEBUGGING:
    def check_memory():
        collect_garbage()
        objs = gc.get_objects()
        print
        print "--------------------------------------------------------------"
        print "views"
        print "--------------------------------------------------------------"
        for v in filter(lambda o: isinstance(o, navigator.View), objs):
            print v._nav_title, v.__class__.__name__
        print "--------------------------------------------------------------"

        print
        print "--------------------------------------------------------------"
        print "observers"
        print "--------------------------------------------------------------"
        for v in filter(lambda o: isinstance(o, _observer.Observer), objs):
            print v.__type_name__, v.__class__.__name__
        print "--------------------------------------------------------------"

        import matplotlib.axes as axes 
        print
        print "--------------------------------------------------------------"
        print "axes"
        print "--------------------------------------------------------------"
        for v in filter(lambda o: isinstance(o, axes.Axes), objs):
            refs = gc.get_referrers(v)
            print v.__class__.__name__, len(refs)

        print "--------------------------------------------------------------"

        import faces.charting.widgets as widgets
        print
        print "--------------------------------------------------------------"
        print "widgets"
        print "--------------------------------------------------------------"
        for v in filter(lambda o: isinstance(o, widgets.Widget), objs):
            refs = gc.get_referrers(v)
            print v.__class__.__name__, len(refs)
        print "--------------------------------------------------------------"
else:
    check_memory = None
</t>
<t tx="michael.20060621114845.76">splash_text = """&lt;font family="swiss" size="9"&gt;
Support &lt;font style="slant"&gt;faces&lt;/font&gt; and send your
project files to mreithinger@web.de.

To improve the quality of &lt;font style="slant"&gt;faces&lt;/font&gt;, we need more
real-world test data. Support the &lt;font style="slant"&gt;faces&lt;/font&gt; development
team and provide your project for use as test data.

You can use the Menu &lt;font family="modern" weight="bold"&gt;Help-&gt;Send Project&lt;/font&gt;
for your convenience.&lt;/font&gt;
"""

version_text = '&lt;font family="swiss" size="7"&gt;'\
               'faces version %s. Copyright (c) '\
               '2005,2006,2007 by Reithinger GmbH&lt;/font&gt;' % str(_faces.__version__)


class FacesApp(MetaApp):
	@others</t>
<t tx="michael.20060621114845.77">def OnInit(self):
    if MetaApp.OnInit(self):
        self.frame.Bind(wx.EVT_CLOSE, self._on_frame_close)
        self.frame.Bind(wx.EVT_MENU_OPEN, self._on_menu_open)
        self.status_bar.SetFieldsCount(3)
        self.status_bar.SetStatusWidths([-1, 20, 200])
        self.gauge = wx.Gauge(self.status_bar, -1, 10)
        self.gauge.Hide()
        self.show_splash(True)
        return True

    return False

</t>
<t tx="michael.20060621114845.78">def show_splash(self, timeout=False):
    splash = ResourceManager.load_bitmap("splash1")

    text = RenderToBitmap(splash_text)
    dc = wx.MemoryDC()
    dc.SelectObject(splash)
    dc.DrawBitmap(text, 14, 100, True)

    version = RenderToBitmap(version_text)
    y = splash.GetHeight() - version.GetHeight() - 10
    dc.DrawBitmap(version, 14, y, True)

    dc.SelectObject(wx.NullBitmap)

    flags = wx.SPLASH_CENTRE_ON_SCREEN
    if timeout:
        flags |= wx.SPLASH_TIMEOUT
    else:
        flags |= wx.SPLASH_NO_TIMEOUT

    splash = wx.SplashScreen(splash, flags, 8000, self.frame, 
                             style=wx.STAY_ON_TOP|wx.FRAME_NO_TASKBAR)

    self.Yield(True)
</t>
<t tx="michael.20060621114845.79">def _on_frame_close(self, event):
    if event.CanVeto() and not self.session.check_modified_buffers():
        event.Veto()
    else:
        event.Skip()
        self.frame.Hide() #avoid flickering in Windows
        self.frame.Destroy()
</t>
<t tx="michael.20060621114845.80">def is_processing(self):
    try:
        self.gauge_title
        return True
    except AttributeError:
        return False
</t>
<t tx="michael.20060621114845.81">def progress_start(self, title, maximum, message=""):
    self.gauge_title = title
    self.frame.SetStatusText(title, 0)
    w, h = self.status_bar.GetTextExtent(title + "X")
    rect = self.status_bar.GetFieldRect(0)
    self.gauge.SetDimensions(rect.x + w, rect.y,
                             rect.width - w, rect.height)
    self.gauge.SetRange(maximum)
    self.gauge.Show()
    #self.frame.Enable(False)
    self.Yield(True)

</t>
<t tx="michael.20060621114845.82">def progress_update(self, value, message=""):
    try:
        self.frame.SetStatusText(self.gauge_title, 0)
        self.gauge.SetValue(value)
        self.Yield(True)
    except AttributeError:
        pass
</t>
<t tx="michael.20060621114845.83">def progress_end(self):
    try:
        self.frame.SetStatusText("", 0)
        self.gauge.Hide()
        self.Yield(True)
        del self.gauge_title
    except AttributeError:
        pass

    #self.frame.Enable()
    self.WakeUpIdle()
</t>
<t tx="michael.20060621114845.84">def main():
    sys.setcheckinterval(10000)
    lang = os.environ.get("LANG", "")
    try:
        locale.setlocale(locale.LC_ALL, lang)
    except locale.Error, err:
        print &gt;&gt; sys.stderr, err
        if wx.Platform == '__WXMSW__':
            locale.setlocale(locale.LC_ALL, "")
        else:
            locale.setlocale(locale.LC_ALL, "C")

    if not _faces._PROFILING:
        try:
            import psyco
        except ImportError:
            pass
        else:
            psyco.profile()
            #psyco.log()
            psyco.cannotcompile(re.compile)

    ResourceManager.resource_path.append(_resource_path)

    app = FacesApp(False)
    app.config = ConfigParser.SafeConfigParser()
    app.config.read(os.path.expanduser("~/.faces-cfg"))

    app.freeze()
    faces.utils.do_yield = app.Yield
    faces.utils.progress_start = app.progress_start
    faces.utils.progress_update = app.progress_update
    faces.utils.progress_end = app.progress_end

    app.get_toolbar().wxobj.SetToolBitmapSize((24, 24))
    app.set_title("faces")

    icon = wx.IconFromBitmap(ResourceManager.load_bitmap("gantt"))
    app.frame.SetIcon(icon)

    app.session = Session()
    app.add_model(app.session)
    app.session.install_logger()

    if _faces._DEBUGGING:
        sys.stdout = sys.__stdout__

    warnings.showwarning = showwarning
    warnings.filterwarnings("always")
    try:
        # used in python &lt;= 2.3
        warnings.filterwarnings("ignore", category=OverflowWarning)
    except NameError: pass
    warnings.filterwarnings("ignore", category=DeprecationWarning)

    check_installation()
    app.thaw()

    if len(sys.argv) &gt; 1:
        try:
            app.session.open_file(sys.argv[1])
        except:
            pass

    app.MainLoop()
    app.session.end_session()

    try:
        outf = file(os.path.expanduser("~/.faces-cfg"), "w")
        app.config.write(outf)
    except IOError:
        pass

    return 0

</t>
<t tx="michael.20060621120211.1">try:
    if issubclass(v, _observer.Observer) and v.visible:
        observer.setdefault(path, {})\
            .setdefault((v.__type_name__,
                         v.__type_image__), [])\
            .append((k, v))
except TypeError: pass</t>
<t tx="michael.20060621120211.2">if isinstance(v, _faces.task._ProjectBase):
    evaluations.setdefault(path, {})[k] = v
    continue

try:
    #by convention evaluations are attributes of the top task function
    if not v.task_func: continue # if v is a task function it has the task_func attribute
    for n in public_attribs(v):
        p = getattr(v, n)
        if isinstance(p, _faces.task._ProjectBase):
            evaluations.setdefault(path, {})["%s.%s" % (k, n)] = p
    continue
except AttributeError: pass


</t>
<t tx="michael.20060621120211.3">if isinstance(v, (_faces.Resource,
                  _faces.resource._MetaResource)):
    resources.setdefault(path, {})[k] = v
    continue</t>
<t tx="michael.20060621120211.4">if hasattr(v, "faces_menu"):
    functions.append(v)</t>
<t tx="michael.20060621120211.5">for m in ctrl.get_planbuffers():
    m.evaluations = evaluations.get(m.path, {})
    m.resources = resources.get(m.path, {})
    m.calendars = calendars.get(m.path, {})
    m.set_observer(observer.get(m.path, {}))
    m.refresh() # refresh edit view</t>
<t tx="michael.20060621120211.6">top = ctrl.get_top_menu()
top.remove_by_owner(self.menus_owner)

for f in functions:
    menu_path = f.faces_menu
    menu_path = menu_path.split("/")

    menu = top.make_menu(_("&amp;Tools"), pos=9980)
    for m in menu_path[:-1]:
        menu = menu.make_menu(m)

    menu.make_item(self.menus_owner, menu_path[-1],
                   _generate_menu_wrapper(self, f),
                   bitmap=getattr(f, "faces_menu_icon", None))</t>
<t tx="michael.20060621120211.7">resources = {}
calendars = {}
observer = {}
evaluations = {}
functions = []</t>
<t tx="michael.20060621123928">def _restore_globals(self):
    self._function.func_globals.clear()
    self._function.func_globals.update(self._globals)
    del self._globals
</t>
<t tx="michael.20060621125711">@language python
&lt;&lt; Copyright &gt;&gt;

"""
In this package you find will the library to all report and chart objects
"""

_is_source_ = True</t>
<t tx="michael.20060621125853">@language python
"""
Line connectors between two widgets.
"""
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_colorConverter = colors.colorConverter

@others
</t>
<t tx="michael.20060621125853.1">import widgets
import matplotlib.transforms as mtrans
import matplotlib.colors as colors
import math
from tools import *



</t>
<t tx="michael.20060621125853.2">def get_arrow(cos, sin, tx, ty, width, height):
    h = Lazy(height)
    wm = Lazy(-width * 0.5)
    wp = Lazy(width * 0.5)

    arrow = [ (h, wm), (0, 0), (h, wp) ]

    m11 = HSEP * cos
    m12 = -HSEP * sin
    m21 = VSEP * sin
    m22 = VSEP * cos

    def multplus(vector):
        return (m11 * vector[0] + m12 * vector[1] + tx,
                m21 * vector[0] + m22 * vector[1] + ty)

    return map(multplus, arrow)
</t>
<t tx="michael.20060621125853.3">class ConnectorPath(object):
    """
    Base class for path calculation.
    """
	@others

</t>
<t tx="michael.20060621125853.4">def calc_start_end(cls, src, dest):
    x_ends = cls.calc_x_ends(src, dest)
    return min(x_ends), max(x_ends)

calc_start_end = classmethod(calc_start_end)</t>
<t tx="michael.20060621125853.5">def get_lines(cls, src, dest, transform):
    src_end, dest_end = cls.calc_x_ends(src, dest)

    def nearest_x(to_find, verts):
        return float(min(map(lambda v: (abs(float(v[0]) - to_find), v[0]),
                             verts))[1])
    so = src_end
    do = dest_end
    src_end = nearest_x(src_end, src.shape[0].get_verts())
    dest_end = nearest_x(dest_end, dest.shape[0].get_verts())

    return cls.get_edges((src_end, src.row.y.get(), src),
                         (dest_end, dest.row.y.get(), dest))

get_lines = classmethod(get_lines)</t>
<t tx="michael.20060621125853.6">def point_near(cls, point_widget, wanted_y):
    """find all possible connector ends for a given x, y"""
    x, y, widget = point_widget

    bb_shape = mtrans.bound_vertices(widget.shape[0].get_verts())
    set_helpers(bb_shape, bb_shape)
    verts = widget.shape[0].get_verts()
    wy = wanted_y.get()

    def dist_point(point):
        #freeze points
        px = float(point[0])
        py = float(point[1])
        dx = abs(px - x) / HSEP.get()
        dy = abs(py - wy) / VSEP.get()
        return (dx + dy, (point[0], point[1]))

    return min([ dist_point(p) for p in verts ])[1]

point_near = classmethod(point_near)</t>
<t tx="michael.20060621125853.7">def find_y_pos(cls, src, dest):
    if src[1] &lt; dest[1]: return TOP, BOTTOM
    if src[1] &gt; dest[1]: return BOTTOM, TOP
    return VCENTER, VCENTER

find_y_pos = classmethod(find_y_pos)</t>
<t tx="michael.20060621125853.8">def get_edges(cls, src, dest):
    src_y, dest_y = cls.find_y_pos(src, dest)
    return (cls.point_near(src, src_y), cls.point_near(dest, dest_y))

get_edges = classmethod(get_edges)</t>
<t tx="michael.20060621125853.9">class StartEndPath(ConnectorPath):
	@others

</t>
<t tx="michael.20060621125853.10">def calc_x_ends(src, dest):
    return src.start, dest.end

calc_x_ends = staticmethod(calc_x_ends)</t>
<t tx="michael.20060621125853.11">def get_edges(cls, src, dest):
    src_y, dest_y = cls.find_y_pos(src, dest)

    if src[0] == dest[0]:
        return (cls.point_near(src, src_y),
                cls.point_near(dest, dest_y))

    if dest[0] &lt; src[0]:
        s = cls.point_near(src, VCENTER)
        d = cls.point_near(dest, dest_y)
        return (s, (d[0], s[1]), d)

    sp = cls.point_near(src, src_y)
    dp = cls.point_near(dest, dest_y)

    # src[0] &gt; dest[0]
    row = src[2].row
    if src[1] &lt; dest[1]:
        next_floor = row.y + VSEP * row.top_sep / 2
    else:
        next_floor = row.y - row.height - row.bottom_sep / 2 * VSEP

    return (sp, (sp[0], next_floor), (dp[0], next_floor), (dp))

get_edges = classmethod(get_edges)</t>
<t tx="michael.20060621125853.12">class StartStartPath(ConnectorPath):
	@others

</t>
<t tx="michael.20060621125853.13">def calc_x_ends(src, dest):
    return src.start, dest.start

calc_x_ends = staticmethod(calc_x_ends)</t>
<t tx="michael.20060621125853.14">def get_edges(cls, src, dest):
    src_y, dest_y = cls.find_y_pos(src, dest)

    if src[0] == dest[0]:
        src = cls.point_near(src, src_y)
        dest = cls.point_near(dest, dest_y)
        return (src, dest)

    if dest[0] &lt; src[0]:
        src = cls.point_near(src, VCENTER)
        dest = cls.point_near(dest, dest_y)
        return (src, (dest[0], src[1]), dest)

    src = cls.point_near(src, src_y)
    dest = cls.point_near(dest, VCENTER)

    # src[0] &gt; dest[0]
    return (src, (src[0], dest[1]), dest)

get_edges = classmethod(get_edges)</t>
<t tx="michael.20060621125853.15">class EndStartPath(ConnectorPath):
	@others
</t>
<t tx="michael.20060621125853.16">def calc_x_ends(src, dest):
    return src.end, dest.start

calc_x_ends = staticmethod(calc_x_ends)
</t>
<t tx="michael.20060621125853.17">def get_edges(cls, src, dest):
    src_y, dest_y = cls.find_y_pos(src, dest)

    if src[0] == dest[0]:
        return (cls.point_near(src, src_y),
                cls.point_near(dest, dest_y))

    if src[0] &lt; dest[0]:
        s = cls.point_near(src, VCENTER)
        d = cls.point_near(dest, dest_y)
        return (s, (d[0], s[1]), d)

    s = cls.point_near(src, src_y)
    d = cls.point_near(dest, dest_y)

    # src[0] &gt; dest[0]
    row = src[2].row
    if src[1] &lt; dest[1]:
        next_floor = row.y + VSEP * row.top_sep / 2
    else:
        next_floor = row.y - row.height - row.bottom_sep / 2 * VSEP

    return (s, (s[0], next_floor), (d[0], next_floor), d)

get_edges = classmethod(get_edges)</t>
<t tx="michael.20060621125853.18">class EndEndPath(ConnectorPath):
	@others
</t>
<t tx="michael.20060621125853.19">def calc_x_ends(src, dest):
    return src.end, dest.end

calc_x_ends = staticmethod(calc_x_ends)
</t>
<t tx="michael.20060621125853.20">def get_edges(cls, src, dest):
    src_y, dest_y = cls.find_y_pos(src, dest)

    if src[0] == dest[0]:
        src = cls.point_near(src, src_y)
        dest = cls.point_near(dest, dest_y)
        return (src, dest)

    if src[0] &lt; dest[0]:
        src = cls.point_near(src, VCENTER)
        dest = cls.point_near(dest, dest_y)
        return (src, (dest[0], src[1]), dest)

    src = cls.point_near(src, src_y)
    dest = cls.point_near(dest, VCENTER)

    # src[0] &gt; dest[0]
    return (src, (src[0], dest[1]), dest)

get_edges = classmethod(get_edges)</t>
<t tx="michael.20060621125853.21">class ShortestPath(ConnectorPath):
	@others
</t>
<t tx="michael.20060621125853.22">def calc_x_ends(src, dest):
    if src.start &lt;= dest.end and dest.start &lt;= src.end:
        start = (min(src.end, dest.end) + max(src.start, dest.start)) / 2
        return start, start

    if src.start &gt; dest.end: return src.start, dest.end
    return src.end, dest.start

calc_x_ends = staticmethod(calc_x_ends)</t>
<t tx="michael.20060621125853.23">class GanttConnector(widgets.Widget):
    """
    A connecor path between two gantt widgets.
    """

	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060621125853.24">properties = {
    "width" : 3,
    "height" : 3,
    "edgecolor" : "darkslategray",
    "facecolor" : "darkslategray",
    "open" : False
    }

zorder = -2

</t>
<t tx="michael.20060621125853.25">def __init__(self, src, dest, path, properties=None):
    widgets.Widget.__init__(self, properties)
    self.src = src
    self.dest = dest
    self.set_path(path)
</t>
<t tx="michael.20060621125853.26">def set_path(self, path):
    self.path = path
    self.start, self.end = path.calc_start_end(self.src, self.dest)
</t>
<t tx="michael.20060621125853.27">def set_property(self, name, value):
    if name.find("connector") &lt; 0:
        # a convinience hack
        name = "connector." + name

    widgets.Widget.set_property(self, name, value)
</t>
<t tx="michael.20060621125853.28">def get_bounds(self, renderer):
    return self.bbox
</t>
<t tx="michael.20060621125853.29">def contains(self, x, y):
    return False
</t>
<t tx="michael.20060621125853.30">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    #fetch all properties
    self.get_patch("connector")
    self.get_patch("connector.end")
    self.get_property("connector.end.open")
    self.get_property("connector.end.width")
    self.get_property("connector.end.height")
    self.get_property("connector.end.facecolor")

    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    transform = self.get_transform()
    lines = self.path.get_lines(self.src, self.dest, transform)

    self.xs = map(lambda e: e[0], lines)
    self.ys = map(lambda e: e[1], lines)

    self.edx = (self.xs[-2] - self.xs[-1]) / HSEP
    self.edy = (self.ys[-2] - self.ys[-1]) / VSEP
    self.LL = self.edx * self.edx + self.edy * self.edy
    self.cos = Lazy(1)
    self.sin = Lazy(0)

    prop = self.get_property

    awidth = prop("connector.end.width")
    aheight = prop("connector.end.height")

    self.arrow = get_arrow(self.cos, self.sin,
                           self.xs[-1], self.ys[-1],
                           awidth, aheight)

    Point = mtrans.Point
    Value = mtrans.Value
    Bbox = mtrans.Bbox

    to_float = lambda v: (float(v), v)
    xs = map(to_float, self.xs)
    ys = map(to_float, self.ys)

    left = min(xs)[1] - (awidth * 0.5) * HSEP
    right = max(xs)[1] + (awidth * 0.5) * HSEP
    bottom = min(ys)[1]
    top = max(ys)[1]
    self.bbox = Bbox(Point(left.val, bottom.val),
                     Point(right.val, top.val))
    return True, True
</t>
<t tx="michael.20060621125853.31">def draw(self, renderer, data_box):
    if not self.get_visible() or not self.overlaps(data_box): return False
    transform = self.get_transform()

    gc = renderer.new_gc()
    if self.get_clip_on():
        gc.set_clip_rectangle(self.clipbox.get_bounds())

    self.set_gc(gc, "connector")
    draw_lines(renderer, gc, self.xs, self.ys, transform)

    l = math.sqrt(float(self.LL)) or 1.0
    self.cos.set(float(self.edx) / l)
    self.sin.set(float(self.edy) / l)

    self.set_gc(gc, "connector.end")
    if self.get_property("connector.end.open"):
        draw_lines(renderer, gc,
                   map(lambda a: a[0], self.arrow),
                   map(lambda a: a[1], self.arrow),
                   transform)
    else:
        face = self.get_property("connector.end.facecolor")
        face = _colorConverter.to_rgb(face)
        renderer.draw_polygon(gc, face, transform.seq_xy_tups(self.arrow))

    return False
</t>
<t tx="michael.20060621125853.32">class WBKConnector(widgets.Widget):
    """
    A connector of widgets inside a workbreakdown chart
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060621125853.33">properties = {
    "connector.linewidth" : 1,
    "connector.edgecolor" : "black",
    }

zorder = -2

</t>
<t tx="michael.20060621125853.34">def __init__(self, src, dest, properties=None):
    widgets.Widget.__init__(self, properties)
    self.src = src
    self.dest = dest

    #fetch all properties
    self.get_patch("connector")
</t>
<t tx="michael.20060621125853.35">def get_bounds(self, renderer):
    return self.bbox
</t>
<t tx="michael.20060621125853.36">def contains(self, x, y):
    return False
</t>
<t tx="michael.20060621125853.37">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    HSEP.set(VSEP.get())
    Point = mtrans.Point
    BBox = mtrans.Bbox

    src_box = self.src.bbox
    dst_box = self.dest.bbox

    if self.src.row.y.get() &gt; self.dest.row.y.get():
        self.bbox = BBox(Point(src_box.ur().x(), dst_box.ll().y()),
                         Point(dst_box.ll().x(), src_box.ur().y()))
    else:
        self.bbox = BBox(Point(src_box.ur().x(), src_box.ll().y()),
                         Point(dst_box.ll().x(), dst_box.ur().y()))

    hor_middle = float(self.src.col.x + self.src.col.full_width()\
                       - self.src.col.right_sep * HSEP.get() / 2)
    src_middle = (src_box.ymin() + src_box.ymax()) / 2
    dst_middle = (dst_box.ymin() + dst_box.ymax()) / 2

    self.xs = (src_box.xmax(), hor_middle, hor_middle, dst_box.xmin())
    self.ys = (src_middle, src_middle, dst_middle, dst_middle)
    return True, True
</t>
<t tx="michael.20060621125853.38">def draw(self, renderer, data_box):
    if not self.get_visible() or not self.overlaps(data_box): return False
    transform = self.get_transform()

    gc = renderer.new_gc()
    if self.get_clip_on():
        gc.set_clip_rectangle(self.clipbox.get_bounds())

    self.set_gc(gc, "connector")
    draw_lines(renderer, gc, self.xs, self.ys, transform)
    return False
</t>
<t tx="michael.20060621130232">@
gantt widgets can have the different shapes in this modules.

For all shapes:
the first item of the returned shape list, has to be a patch, that defines, the connection points


@code
@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

__all__ = ("bar", "brace", "combibar", "diamond", "circle", "wedge", "house")
_is_source_ = True

@others

symbols = ("diamond", "circle", "wedge", "house")

</t>
<t tx="michael.20060621130232.1">from patches import *
from tools import *
import widgets


</t>
<t tx="michael.20060621130232.2">def bar(props, name, complete=0):
    kwargs = make_properties(props, name)
    bar = Polygon(((LEFT, BOTTOM),
                   (LEFT, VCENTER),
                   (LEFT, TOP),
                   (HCENTER, TOP),
                   (RIGHT, TOP),
                   (RIGHT, VCENTER),
                   (RIGHT, BOTTOM),
                   (HCENTER, BOTTOM)), **kwargs)
    if complete:
        kwargs = make_properties(props, "%s.complete" % name)
        complete /= 100.0
        complete = Rectangle((LEFT, BOTTOM + VSEP * FACTOR / 4),
                             (RIGHT - LEFT) * complete,
                             VSEP * FACTOR / 2,
                             **kwargs)
        return (bar, complete)

    return (bar,)
</t>
<t tx="michael.20060621130232.3">def brace(props, name):
    kwargs = make_properties(props, name)
    HALF = FACTOR / 2
    return (Polygon([(LEFT, TOP),
                     (RIGHT, TOP),
                     (RIGHT, BOTTOM),
                     (RIGHT - HALF * HSEP, BOTTOM + HALF * VSEP),
                     (LEFT + HALF * HSEP, BOTTOM + HALF * VSEP),
                     (LEFT, BOTTOM)], **kwargs),)
</t>
<t tx="michael.20060621130232.4">def combibar(props, name, left, right, complete):
    left = left(props, name + ".start", VCENTER, LEFT)
    right = right(props, name + ".end", VCENTER, RIGHT)

    half_height = props(name + ".bar.height") * VSEP / 2
    top = VCENTER + half_height
    bottom = VCENTER - half_height

    def left_vert(vert):
        x, y = float(vert[0]), float(vert[1])
        return x &lt; LEFT.get() or y &gt; top.get() or y &lt; bottom.get()

    def right_vert(vert):
        x, y = float(vert[0]), float(vert[1])
        return x &gt; RIGHT.get() or y &gt; top.get() or y &lt; bottom.get()

    outline_verts = filter(left_vert, left[0].get_verts())\
                    + [(HCENTER, top), (HCENTER, bottom)] \
                    + filter(right_vert, right[0].get_verts())

    outline = Polygon(outline_verts)
    outline.set_visible(False)

    kwargs = make_properties(props, name + ".bar")
    bar = Polygon([(LEFT, top), (RIGHT, top),
                   (RIGHT, bottom), (LEFT, bottom)], **kwargs)

    #only take the visible part of the symbols
    sleft = left[int(len(left) &gt; 1)]
    sright = right[int(len(right) &gt; 1)]

    if complete:
        kwargs = make_properties(props, name + ".complete")
        half_height = props(name + ".complete.height") * VSEP / 2
        top = VCENTER + half_height
        bottom = VCENTER - half_height
        right = LEFT + (RIGHT - LEFT) * complete / 100
        complete = Polygon([(LEFT, top), (right, top),
                            (right, bottom), (LEFT, bottom)], **kwargs)

        return (outline, bar, complete, sleft, sright)

    return (outline, bar, sleft, sright)
</t>
<t tx="michael.20060621130232.5">def diamond(props, name="", vc=None, hc=None):
    """
    A diamond symbol, that can be be used as an argument,
    for a widgets set_shape method or for a combined shape
    like combibar.

    @args:
    """
    if name: name = ".%s" % name
    vc = vc or VCENTER
    hc = hc or HCENTER
    kwargs = make_properties(props, "diamond" + name)
    mag = props("diamond" + name + ".magnification")
    HALF = mag * FACTOR / 2
    return (Polygon([(hc - HALF * HSEP, vc),
                     (hc, vc - HALF * VSEP),
                     (hc + HALF * HSEP, vc),
                     (hc, vc + HALF * VSEP)], **kwargs),)
</t>
<t tx="michael.20060621130232.6">def circle(props, name="", vc=None, hc=None):
    if name: name = ".%s" % name
    vc = vc or VCENTER
    hc = hc or HCENTER
    kwargs = make_properties(props, "circle" + name)
    mag = props("circle" + name + ".magnification")

    HALF = mag * FACTOR / 2

    shape = (Polygon([(hc - HALF * HSEP, vc),
                      (hc, vc - HALF * VSEP),
                      (hc + HALF * HSEP, vc),
                      (hc, vc + HALF * VSEP)]),
             Circle((hc, vc), HALF*VSEP, **kwargs))
    shape[0].set_visible(False)
    return shape
</t>
<t tx="michael.20060621130232.7">def wedge(props, name="", vc=None, hc=None):
    if name: name = ".%s" % name
    vc = vc or VCENTER
    hc = hc or HCENTER
    kwargs = make_properties(props, "wedge" + name)
    mag = props("wedge" + name + ".magnification")

    HALF = mag * FACTOR / 2

    if props("wedge" + name + ".up", True):
        base = VCENTER - HALF * VSEP
        head = VCENTER + HALF * VSEP
    else:
        base = VCENTER + HALF * VSEP
        head = VCENTER - HALF * VSEP

    return (Polygon([(hc - HALF * HSEP, base),
                     (hc, base),
                     (hc + HALF * HSEP, base),
                     (hc + HALF * HSEP / 2, vc),
                     (hc, head),
                     (hc - HALF * HSEP / 2, vc)], **kwargs),)
</t>
<t tx="michael.20060621130232.8">def house(props, name="", vc=None, hc=None):
    if name: name = ".%s" % name
    vc = vc or VCENTER
    hc = hc or HCENTER
    kwargs = make_properties(props, "house" + name)
    mag = props("house" + name + ".magnification")

    HALF = mag * FACTOR / 2

    if props("house" + name + ".up", True):
        base = VCENTER - HALF * VSEP
        head = VCENTER + HALF * VSEP
    else:
        base = VCENTER + HALF * VSEP
        head = VCENTER - HALF * VSEP

    return (Polygon([(hc - HALF * HSEP, base),
                     (hc, base),
                     (hc + HALF * HSEP, base),
                     (hc + HALF * HSEP, vc),
                     (hc, head),
                     (hc - HALF * HSEP, vc)], **kwargs),)
</t>
<t tx="michael.20060621131531">@ filters out modules which are definitly not faces modules
@code
buffer_paths = [ m.path for m in ctrl.get_planbuffers() ]

def is_valid_module(module):
    try:
        if not module._faces_source_file: return False
    except AttributeError:
        return False

    try:
        return not module._is_source_
    except AttributeError:
        return module._faces_source_file in buffer_paths</t>
<t tx="michael.20060621134201">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;


_is_source = True
_FIELD_BULLET = re.compile('^\s*@(\w+)( [^{}:\n]+)?:( +|$)', re.MULTILINE)
_ESCAPE = re.compile('[A-Z]+{([^}]+)}')

@others
</t>
<t tx="michael.20060621134201.1">import re
import inspect
import textwrap



</t>
<t tx="michael.20060621134201.2">def _get_indentdation(line):
    return len(line) - len(line.lstrip())
</t>
<t tx="michael.20060621134201.3">def unescape(txt):
    return _ESCAPE.sub(r"\1", txt)
</t>
<t tx="michael.20060621134201.4">class DocParser(object):
	@others
</t>
<t tx="michael.20060621134201.5">def __init__(self, text):
    self.clear()
    self.description = self.parse_description(text)
    self.parse_fields(text)
</t>
<t tx="michael.20060621134201.6">def clear(self):
    self.description = ""
    self.order = {}
    self.attribs = {}
    self.types = {}
    self.params = {}
    self.args = None
</t>
<t tx="michael.20060621134201.7">def parse_fields(self, txt):
    field = { "var" : self.attribs,
              "param": self.params,
              "type" : self.types }

    docs = txt.split("\n")

    for i in range(len(docs)):
        line = docs[i]
        mo = _FIELD_BULLET.search(line)
        if mo:
            type_ = mo.group(1)
            name = mo.group(2)
            indent = _get_indentdation(line)
            for j in range(i + 1, len(docs)):
                if _get_indentdation(docs[j]) &lt; indent \
                       or _FIELD_BULLET.search(docs[j]):
                    break

            dlines = map(lambda l: l[indent:], docs[i + 1:j])
            dlines.insert(0, line[mo.end():].strip())

            desc = unescape("\n".join(dlines))
            try:
                if name:
                    name = name.strip()
                    field[type_].setdefault(name.strip(),
                                            textwrap.dedent(desc).strip())
                    self.order.setdefault(name, i)
                else:
                    field[type_] = textwrap.dedent(desc).strip()
            except KeyError: pass

            i = j

    self.args = field.get("args", None)
</t>
<t tx="michael.20060621134201.8">def parse_methods(self, instance):
    ismf = lambda o: inspect.isfunction(o) or inspect.ismethod(0)
    for name, val in inspect.getmembers(instance, ismf):
        self.methods[name] = self.parse_description(val.__doc__ or "")
</t>
<t tx="michael.20060621134201.9">def parse_description(self, desc):
    mo = _FIELD_BULLET.search(desc)
    desc = bool(mo) and desc[:mo.start()] or desc
    return textwrap.dedent(desc).strip()
</t>
<t tx="michael.20060621134201.10">class DocBase(object):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060621134201.11">min_width = 40

</t>
<t tx="michael.20060621134201.12">def argspec(self, obj):
    args = inspect.getargspec(obj)
    try:
        if args[0][0] == "self": del args[0][0]
    except IndexError:
        pass

    return inspect.formatargspec(*args)
</t>
<t tx="michael.20060621134201.13">class ClassDoc(DocBase):
	@others
</t>
<t tx="michael.20060621134201.14">def __init__(self, instance):
    try:
        doc = str(instance.__doc__ or "")
    except AttributeError:
        doc = ""

    parser = DocParser(doc)

    self.description = parser.description
    self.order = parser.order
    self.attribs = parser.attribs
    self.params = parser.params
    self.init_args = "()"

    args = parser.args

    parser.params = {}
    if inspect.isclass(instance):
        cls = instance
    else:
        cls = instance.__class__

    for c in inspect.getmro(cls):
        try:
            doc = str(c.__doc__ or "")
        except AttributeError:
            doc = ""

        parser.parse_fields(doc)

    self.parse_methods(instance)
    self.init_args = args is None and self.init_args or args
</t>
<t tx="michael.20060621134201.15">def get_doc(self, field):
    desc = self.attribs.get(field)
    if desc:
        desc = textwrap.fill(desc, self.min_width)
        return len(field) + 1, "%s:\n%s" % (field, desc)

    desc = self.methods.get(field)
    if desc:
        header = field + self.args[field]
        desc = textwrap.fill(desc, max(self.min_width, len(header) + 1))
        return len(header) + 1, "%s:\n%s" % (header, desc)

    return ()
</t>
<t tx="michael.20060621134201.16">def constructor(self, name):
    header = name + self.init_args
    desc = textwrap.fill(self.description,
                         max(self.min_width, len(header) + 1))
    return len(header) + 1, "%s:\n%s" % (header, desc)
</t>
<t tx="michael.20060621134201.17">def parse_methods(self, instance):
    self.methods = {}
    self.args = {}
    for name, val in inspect.getmembers(instance, inspect.ismethod):
        if val.__doc__:
            parser = DocParser(str(val.__doc__))
            self.methods[name] = parser.description
            if parser.args:
                self.args[name] = parser.args
                continue

            self.args[name] = self.argspec(val)

        if name == "__init__":
            self.init_args = self.argspec(val)
</t>
<t tx="michael.20060621134201.18">class FunctionDoc(DocBase):
	@others
</t>
<t tx="michael.20060621134201.19">def __init__(self, func):
    doc = str(func.__doc__ or "")

    if inspect.ismethod(func) and not doc:
        for c in inspect.getmro(func.im_class):
            attr = getattr(c, func.__name__, func)
            if attr.__doc__:
                doc = attr.__doc__
                break

    parser = DocParser(doc)
    self.description = parser.description
    self.args = parser.args is None and self.argspec(func) or parser.args
</t>
<t tx="michael.20060621134201.20">def constructor(self, name):
    header = name + self.args
    desc = textwrap.fill(self.description,
                         max(self.min_width, len(header) + 1))
    return len(header) + 1, "%s:\n%s" % (header, desc)
</t>
<t tx="michael.20060621134220">def get_doc(self, field):
    return ()
</t>
<t tx="michael.20060621173535">__last_expression = None
def make_button(self, button, expression):
    if expression == self.__last_expression: return
    self.__last_expression = expression
    if not button: return

    editors = self.get_editors()
    if not editors: 
        button.hide()
        return

    try:
        attribs = self.code_item.editor.get_attribs(self.code_item)
    except AttributeError:
        attribs = ()

    if expression:
        applies = lambda ne: ne[1].apply(expression, self.code_item)
    else:        
        applies = lambda ne: ne[1].apply(expression, self.code_item) \
                             and ne[1].attrib_name not in attribs
    editors = filter(applies, editors.iteritems())

    if not editors: 
        button.hide()
        return

    button.set_bitmap(expression and "edit16" or "new16")

    if expression:
        item_editor = editors[0][1]
        def show_popup(editor):
            item_editor.activate(self)
    else:
        def show_popup(editor):
            menu = controller().make_menu()
            create_editor_menu(menu, self, editors)
            button.PopupMenu(menu.wxobj, (0, button.GetSize().height))
            editor.SetFocus()

    button.action = show_popup
    button.Show()</t>
<t tx="michael.20060621180747">if 'wxMac' in wx.PlatformInfo:
    #a dummy context button to disable
    class ContextButton(wx.PyPanel):
        def __init__(self, editor):
            wx.PyPanel.__init__(self, editor)
            self.Hide()

        def set_bitmap(self, bmp_name): pass
        def hide(self): pass
        def move(self, x, y): pass
        def IsShown(self): return False
        def Show(self): pass

else:
    class ContextButton(wx.PyPanel):
        action = None
        @others



</t>
<t tx="michael.20060621182829">def move_context_button(self):
    if self.context_button.IsShown():
        line = self.GetCurrentLine()
        pos = self.GetLineEndPosition(line)
        pos = self.PointFromPosition(pos)
        w, h = self.context_button.GetSize()
        th = self.TextHeight(line)
        self.context_button.move(pos.x + 10, pos.y + (th - h) / 2)</t>
<t tx="michael.20060621183003">def set_bitmap(self, bmp_name):
    bmp = ResourceManager.load_bitmap(bmp_name)
    self.button.SetBitmapLabel(bmp)
    self.button.SetSize(self.button.GetBestSize())
    self.SetClientSize(self.button.GetSize())
    self.Refresh(False)</t>
<t tx="michael.20060621183054">def __init__(self, editor):
    wx.PyPanel.__init__(self, editor)
    self.button = buttons.GenBitmapButton(self, -1, None)
    def on_enter(evt): self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
    def on_action(evt): self.action and self.action(editor) or editor.SetFocus()
    self.button.Bind(wx.EVT_ENTER_WINDOW, on_enter)
    self.button.Bind(wx.EVT_BUTTON, on_action)


</t>
<t tx="michael.20060621203738">def hide(self):
    self.Hide()
    self.action = None</t>
<t tx="michael.20060622082846">@language python
&lt;&lt; Copyright &gt;&gt;
"""
This module contains the base class for all observer objects
"""
&lt;&lt; Imports &gt;&gt;
_is_source_ = True
@others
factories = { }
clear_cache_funcs = {}
</t>
<t tx="michael.20060622082846.1"></t>
<t tx="michael.20060622082846.2">class Observer(object):
    """
    Base Class for all charts and reports.

    @var visible: Specifies if the observer is visible
           at the navigation bar inside the gui.

    @var link_view: syncronizes the marked objects in all views.

    """
	&lt;&lt; declarations &gt;&gt;

    @others

</t>
<t tx="michael.20060622082846.3">__type_name__ = None
__type_image__ = None
visible = True
link_view = True

__attrib_completions__ = { "visible" : 'visible = False',
                           "link_view" : "link_view = False" }


</t>
<t tx="michael.20060622085024"></t>
<t tx="michael.20060622085024.1">def _import_(name):
    mod = __import__(name)
    components = name.split('.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod
</t>
<t tx="michael.20060622090146.1">try:
    gui_module = _import_(module.faces_gui_module)
    self.loaded_modules[module.faces_gui_module] = gui_module
except AttributeError: pass
</t>
<t tx="michael.20060622090146.2">try:
    module_name = str(os.path.splitext(filename)[0])
except UnicodeEncodeError:
    print &gt;&gt; sys.stderr, \
          u'filename "%s" contains non ascii chars' % unicode(filename)
    return True</t>
<t tx="michael.20060622092032"></t>
<t tx="michael.20060622092054">def get_expression_range(self, line=None, with_end=False):
    """
    returns the start and end pos of the expression at line
    Note: the expression can go over several lines
    """
    line = line or self.GetCurrentLine()
    indent = self.GetLineIndentation
    length = self.LineLength
    text = self.GetLine
    takewhile = itertools.takewhile

    &lt;&lt; find start of expression &gt;&gt;
    &lt;&lt; find end of expression &gt;&gt;

    return self.GetLineIndentPosition(start_line), \
           self.GetLineEndPosition(end_line) + bool(with_end)

</t>
<t tx="michael.20060622093346">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A collection of functions for editing tasks and their attributes
"""
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others</t>
<t tx="michael.20060622093402">import context
import faces.plocale
import datetime
import faces.pcalendar as pcalendar
import faces.task as ftask
import metapie.dbtransient as db
import metapie.gui.views as views
import classifiers
import editor
from attribedit import *
</t>
<t tx="michael.20060622093608">class ItemEditor(object):
    """
    Define the Interface for Editor to 
    manipulate code_items.
    """
    attrib_name = ""

    def apply(self, expression):
        """
        returns true if the editor applies for the expression
        """
        return False


    def activate(self, code_item, context):
        """
        activates the editor.
        """

</t>
<t tx="michael.20060622093827">class ScenarioAttributeEditor(ScenarioAttributeEditor):
    evaluator = TaskEvaluator

</t>
<t tx="michael.20060622095823">tregistry = context.CTask.editors
pregistry = context.CProjectDeclaration.editors

std_attributes = _("Standard/%s")
cal_attributes = _("Calendar/%s")

tregistry[std_attributes % "title..."] = AttributeEditor("title", String, _("Title"))
tregistry[std_attributes % "start..."] = ScenarioAttributeEditor("start", RefDate, datetime.datetime.now())
tregistry[std_attributes % "end..."] = ScenarioAttributeEditor("end", RefDate, datetime.datetime.now())
tregistry[std_attributes % "duration..."] = ScenarioAttributeEditor("duration", Duration, "1d")
tregistry[std_attributes % "effort..."] = ScenarioAttributeEditor("effort", Delta, "1d")
tregistry[std_attributes % "todo..."] = AttributeEditor("todo", Delta, "1d")
tregistry[std_attributes % "done..."] = AttributeEditor("done", Delta, "1d")

tregistry[std_attributes % "length..."] = ScenarioAttributeEditor("length", Delta, "1d")
tregistry[std_attributes % "balance..."] = AttributeEditor("balance", Balance)
tregistry[std_attributes % "notes..."] = AttributeEditor("notes", MultiText)
tregistry[std_attributes % "load..."] = ScenarioAttributeEditor("load", Float, 1.0)
tregistry[std_attributes % "efficiency..."] = ScenarioAttributeEditor("efficiency", Float, 1.0)
tregistry[std_attributes % "max_load..."] = ScenarioAttributeEditor("max_load", Float, 1.0)
tregistry[std_attributes % "priority..."] = AttributeEditor("priority", Int, 500)
tregistry[std_attributes % "complete..."] = AttributeEditor("complete", Int, 100)
tregistry[std_attributes % "milestone..."] = AttributeEditor("milestone", Boolean, True)
tregistry[std_attributes % "resource..."] = AttributeEditor("resource", ResourceSet)

tregistry[cal_attributes % "vacation..."] = AttributeEditor("vacation", DateTimeRanges)
tregistry[cal_attributes % "extra_work..."] = AttributeEditor("extra_work", DateTimeRanges)
tregistry[cal_attributes % "now..."] = AttributeEditor("now", Date, datetime.datetime.now())
tregistry[cal_attributes % "working_days..."] = AttributeEditor("working_days", WorkingTimes,
                                                            [("mon,tue,wed,thu,fri", "08:00-12:00", "13:00-17:00")])
tregistry[cal_attributes % "minimum_time_unit..."] = AttributeEditor("minimum_time_unit", Int, 
                                                                 pcalendar.DEFAULT_MINIMUM_TIME_UNIT)
tregistry[cal_attributes % "working_days_per_week..."] = AttributeEditor("working_days_per_week", Int,
                                                                     pcalendar.DEFAULT_WORKING_DAYS_PER_WEEK)
tregistry[cal_attributes % "working_days_per_month..."] = AttributeEditor("working_days_per_month", Int,
                                                                      pcalendar.DEFAULT_WORKING_DAYS_PER_MONTH)
tregistry[cal_attributes % "working_days_per_year..."] = AttributeEditor("working_days_per_year", Int,
                                                                     pcalendar.DEFAULT_WORKING_DAYS_PER_YEAR)
tregistry[cal_attributes % "working_hours_per_day..."] = AttributeEditor("working_hours_per_day", Int,
                                                                     pcalendar.DEFAULT_WORKING_HOURS_PER_DAY)

pregistry.update(tregistry)

tregistry[_("Task/Create Subtask...(1000)")] = SubTaskCreator()
tregistry[_("Task/Rename...(1010)")] = TaskRenamer()
tregistry[_("Task/Remove...(1012)")] = TaskRemover()
tregistry[_("Task/Insert Sibling After...(1020)")] = TaskSiblingCreator()
tregistry[_("Task/Insert Sibling Before...(1030)")] = TaskSiblingBeforeCreator()
tregistry[_("Task/Indent(1040)")] = TaskIndenter()
tregistry[_("Task/Unindent(1050)")] = TaskUnindenter()
tregistry[_("Task/Show References...(1100)")] = TaskReferencePrinter()


pregistry[_("Project/Create Project...(1000)")] = ProjectTaskCreator()
pregistry[_("Project/Create Task...(1001)")] = SubTaskCreator()
pregistry[_("Project/Rename...(1010)")] = ProjectTaskRenamer()
pregistry[_("Project/Remove...(1012)")] = EvaluationRemover()
pregistry[_("Project/Show References...(1100)")] = EvaluationReferencePrinter()

del pregistry
del tregistry
del std_attributes
del cal_attributes

</t>
<t tx="michael.20060622103212">def find_parent_line(self, line_no):
    """
    returns the parent line of line
    """

    find = self.FindText
    line = self.LineFromPosition
    end = self.GetLineEndPosition
    text = self.GetTextRange
    indent = self.GetLineIndentation

    child_indent = indent(line_no)
    pos = self.PositionFromLine(line_no)
    pos = find(pos, 0, ":")
    while pos &gt;= 0:
        &lt;&lt; check if pos ident is smaller &gt;&gt;
        &lt;&lt; check if pos is not in a string or comment &gt;&gt;
        &lt;&lt; check if pos is at the end of an expression &gt;&gt;
    else:
        raise ValueError("no parent line")

    return line(pos)
</t>
<t tx="michael.20060622105356">try:    
    min_line = self.find_parent_line(line)
except ValueError:
    block_indent = 0
    min_line = -1
else:
    block_indent = indent(min_line + 1)

is_sub_block = lambda l: indent(l) &gt; block_indent
lines = tuple(takewhile(is_sub_block, xrange(line, min_line, -1)))
start_line = lines and lines[-1] - 1 or line

</t>
<t tx="michael.20060622105356.1">def is_child(l):
    cindent = indent(l)
    return cindent &gt; block_indent or cindent == length(l) - 1

def has_content(l):
    return indent(l) &lt; length(l) - 1

lines = filter(has_content, 
               takewhile(is_child, xrange(line + 1, self.GetLineCount())))

end_line = lines and lines[-1] or line
</t>
<t tx="michael.20060622105715">def get_expression(self, line=None):
    start, end = self.get_expression_range(line)
    return self.GetTextRangeUTF8(start, end).strip()

</t>
<t tx="michael.20060622112139">style = self.GetStyleAt(pos)
if style in  (wx.stc.STC_P_TRIPLEDOUBLE,
              wx.stc.STC_P_TRIPLE,
              wx.stc.STC_P_STRING,
              wx.stc.STC_P_COMMENTLINE,
              wx.stc.STC_P_COMMENTBLOCK):
    pos = find(pos - 1, 0, ":")
    continue</t>
<t tx="michael.20060622112139.1">rest_text = text(pos, end(line(pos))).split()
try:
    if not rest_text[1].startswith("#"): 
        pos = find(pos - 1, 0, ":")
        continue
except IndexError: pass
break</t>
<t tx="michael.20060622234836"></t>
<t tx="michael.20060623001958">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A library of classes that, can be used for edit dialogs
"""
&lt;&lt; Imports &gt;&gt;

_is_source_ = True

@others</t>
<t tx="michael.20060623001958.1">import wx
import metapie.gui.views as views
from metapie.gui import controller
from faces.gui.patches import PatchedDialog</t>
<t tx="michael.20060623001958.2">if wx.Platform == '__WXGTK__':
    &lt;&lt; gtk patched dialog &gt;&gt;
else:
    &lt;&lt; original dialog &gt;&gt;</t>
<t tx="michael.20060623001958.3">class PatchedDialog(wx.Dialog):
    def __init__(self, *args, **kwargs):
        kwargs["style"] = kwargs.get("style", wx.DEFAULT_DIALOG_STYLE)\
                          &amp; ~wx.CLOSE_BOX 
        wx.Dialog.__init__(self, *args, **kwargs)
        self.SetSizer(wx.BoxSizer(wx.HORIZONTAL))

    #a real ShowModal will break the popup controls under gtk
    def simulate_modal(self, focused, call_after=None):
        self.focused = focused
        self.call_after = call_after
        controller().frame.Enable(False)
        self.Bind(wx.EVT_CLOSE, self._on_close)
        self.Show()
        self.SetFocus()


    def _on_close(self, event=None):
        if event: event.Skip()

        focused = self.focused
        def after_close():
            controller().frame.Enable()
            if focused: focused.SetFocus()

        wx.CallAfter(after_close)


    def EndModal(self, id):
        if self.call_after: self.call_after()
        self._on_close()
        self.Destroy()


</t>
<t tx="michael.20060623001958.4">class PatchedDialog(wx.Dialog):
    def __init__(self, *args, **kwargs):
        wx.Dialog.__init__(self, *args, **kwargs)
        self.SetSizer(wx.BoxSizer(wx.HORIZONTAL))


    def simulate_modal(self, focused, call_after=None):
        self.ShowModal()
        if call_after: call_after()
        if focused: focused.SetFocus()
        self.Destroy()

</t>
<t tx="michael.20060623001958.7"></t>
<t tx="michael.20060623002701">class MainView(views.FormView):
    border = 5

    format_buttons = """
btn_ok{r}|btn_refresh{r}|btn_cancel{r}
"""

    @others
</t>
<t tx="michael.20060623152229">def __init__(self, parent, style=0):
    views.FormView.__init__(self, parent, style)
    parent.keep_alive = self # ensure that the view lives as long as the parent
    sizer = parent.GetSizer()
    sizer.Add(self, border=self.border, flag=wx.ALL|wx.EXPAND, proportion=1)</t>
<t tx="michael.20060623152229.1">def button_cancel(self):
    self.GetParent().EndModal(wx.ID_CANCEL)
    self.rollback()
    try:
        self.imodel.cancel()
    except AttributeError:
        pass
</t>
<t tx="michael.20060623152229.2">def button_ok(self):
    if self.save():
        self.GetParent().EndModal(wx.ID_OK)
        self.imodel.realize()</t>
<t tx="michael.20060623152229.3">def layout(self):
    views.FormView.layout(self)
    parent = self.GetParent()
    w, h = parent.GetClientSize()
    wm, hm = self.GetSizer().CalcMin()
    wm += 2 * self.border
    hm += 2 * self.border
    parent.SetClientSize((max(w, wm, 360), max(h, hm)))
    parent.SetMinSize((wm, hm))</t>
<t tx="michael.20060623154040"></t>
<t tx="michael.20060623154040.1"></t>
<t tx="michael.20060623154040.2">raise RecursionError("you have to specify a "\
                     "start or an end at %s" % self.path)</t>
<t tx="michael.20060623154957"></t>
<t tx="michael.20060623154957.1"></t>
<t tx="michael.20060623154957.2"></t>
<t tx="michael.20060623154957.3"></t>
<t tx="michael.20060623154957.4"></t>
<t tx="michael.20060623154957.5"></t>
<t tx="michael.20060623160939">opname = opcode.opname
opmap = opcode.opmap
jumps = opcode.hasjrel + opcode.hasjabs
HAVE_ARGUMENT = opcode.HAVE_ARGUMENT
co = func.func_code
local_names = co.co_varnames
all_names = list(co.co_names)
global_names = set()
</t>
<t tx="michael.20060623160939.1">def list_to_dict(l):
    return dict([(t[1], t[0]) for t in enumerate(l)])

def is_local(name):
    return name[0] == "_" and name != "__constraint__"</t>
<t tx="michael.20060623160939.3"># all_name_map maps names to the all_names index
# (same like all_names.index())
all_name_map = list_to_dict(all_names)
if not all_name_map.has_key("me"):
    all_name_map["me"] = len(all_names)
    all_names.append("me")

#&lt;python 2.5&gt;
for ln in local_names:
    if not all_name_map.has_key(ln):
        all_name_map[ln] = len(all_names)
        all_names.append(ln)
#&lt;/python 2.5&gt;

new_local_names = filter(is_local, local_names)
new_local_name_map = list_to_dict(new_local_names)

me_arg = _int_to_arg(all_name_map["me"])
old_lnotab = map(ord, co.co_lnotab)
new_lnotab = []
tab_pos = 0
try:
    next_tab_point = old_lnotab[0]
except IndexError:
    next_tab_point = None

last_tab_point = 0
code = map(ord, co.co_code)
new_code = []
has_labels = False
n = len(code)
i = 0</t>
<t tx="michael.20060623160939.4">increment = len(new_code) - last_tab_point
new_lnotab.extend((increment, old_lnotab[tab_pos + 1]))
tab_pos += 2
try:
    next_tab_point = i + old_lnotab[tab_pos]
    last_tab_point = len(new_code)
except IndexError:
    next_tab_point = -1</t>
<t tx="michael.20060623160939.5">arg0 = code[i]
arg1 = code[i+1]
oparg = arg0 + arg1 * 256</t>
<t tx="michael.20060623160939.6">name = local_names[oparg]
if not is_local(name):
    new_code.append(opmap["LOAD_GLOBAL"])
    new_code.extend(me_arg)
    op = opmap["STORE_ATTR"]
    arg0, arg1 = _int_to_arg(all_name_map[name])
else:
    arg0, arg1 = _int_to_arg(new_local_name_map[name])</t>
<t tx="michael.20060623160939.7">name = local_names[oparg]
if not is_local(name):
    new_code.append(opmap["LOAD_GLOBAL"])
    new_code.extend(me_arg)
    op = opmap["LOAD_ATTR"]
    arg0, arg1 = _int_to_arg(all_name_map[name])
else:
    arg0, arg1 = _int_to_arg(new_local_name_map[name])</t>
<t tx="michael.20060623160939.8">new_code = "".join(map(chr, new_code))
new_lnotab = "".join(map(chr, new_lnotab))
new_co = new.code(co.co_argcount,
                  len(new_local_names),
                  max(co.co_stacksize, 2),
                  co.co_flags,
                  new_code,
                  co.co_consts,
                  tuple(all_names),
                  tuple(new_local_names),
                  co.co_filename,
                  co.co_name,
                  co.co_firstlineno,
                  new_lnotab,
                  co.co_freevars,
                  co.co_cellvars)


func =  new.function(new_co,
                     func.func_globals,
                     func.func_name,
                     func.func_defaults,
                     func.func_closure)
func.global_names = tuple([all_names[index] for index in global_names])
return func</t>
<t tx="michael.20060623161820">hasjrel = opcode.hasjrel
hasjabs = opcode.hasjabs
HAVE_ARGUMENT = opcode.HAVE_ARGUMENT</t>
<t tx="michael.20060623161820.1">labels = {}
old_new_map = {} # map old code offset to new code offset
n = len(old_code)
i = 0
j = 0</t>
<t tx="michael.20060623161820.2">label = -1
if op in hasjrel:
    label = i + oparg
elif op in hasjabs:
    label = oparg
if label &gt;= 0:
    labels[i] = label</t>
<t tx="michael.20060623163022"></t>
<t tx="michael.20060626130019">class TaskEvaluator(object):
    def __init__(self, expression, context):
        &lt;&lt; define path variables &gt;&gt;
        &lt;&lt; define wmax and wmin &gt;&gt;

        vars = { "up" : up,
                 "root" : root,
                 "me" : me,
                 "max" : wmax,
                 "min" : wmin  }

        try:
            editor = context.code_item.editor
            self.attributes = editor.eval_expression(expression, vars, context)
        except Exception, e:
            self.error = e
</t>
<t tx="michael.20060626130414">class PathWrapper(object):
    def __init__(self, code_item, path_str):
        self._path_str = path_str
        self._code_item = code_item


    def _get_up(self):
        new_item = self._code_item.get_parent()
        new_path = "%s.up" % (self._path_str)
        return PathWrapper(new_item, new_path)

    up = property(_get_up)

    def _get_root(self):
        return PathWrapper(get_code_root(self._code_item), "root")

    root = property(_get_root)


    def __getattr__(self, name):
        child = filter(lambda c: c.name == name, self._code_item.get_children())
        if child:
            return PathWrapper(child[0], "%s.%s" % (self._path_str, name))

        return ValueWrapper(AttributeWrapper(self._path_str, name), 
                            ["%s.%s" % (self._path_str, name)])


    def __str__(self):
        return self._path_str
</t>
<t tx="michael.20060626130823">class ValueWrapper(ftask._ValueWrapper):
    def _vw(self, operand, *args):
        refs = reduce(lambda a, b: a + b, map(ftask._ref, args), [])
        vals = map(ftask._val, args)
        vals.insert(0, operand)
        return ValueWrapper(tuple(vals), refs)


    def _cmp(self, operand, *args):
        refs = reduce(lambda a, b: a + b, map(ftask._ref, args), [])
        vals = map(str, args)
        result = operand(*vals)
        map(lambda a: _sref(a, refs), args)
        return result


</t>
<t tx="michael.20060626133545">@language python
&lt;&lt; Copyright &gt;&gt;
"""
This module contains all classes and functions for the project plan calendar
"""
&lt;&lt; Imports &gt;&gt;
@others

if __name__ == '__main__':
    cal = Calendar()

    start = EndDate("10.1.2005")
    print "start", start.strftime(), type(start)

    delay = Minutes("4H")
    print "delay", delay, delay.strftime()

    print "Start", cal.StartDate is StartDate
    print "base", cal.StartDate.__bases__[0] == StartDate.__bases__[0]
    print "type", type(start)

    print "convert start"
    start2 = cal.StartDate(start)
    print "convert end"

    start3 = cal.StartDate("10.1.2005")
    print "start2", start2.strftime(), type(start2)
</t>
<t tx="michael.20060626133545.1">from string import *
import datetime
import time
import re
import locale
import bisect
import sys

TIME_RANGE_PATTERN = re.compile("(\\d+):(\\d+)\\s*-\\s*(\\d+):(\\d+)")
TIME_DELTA_PATTERN = re.compile("([-+]?\\d+(\\.\\d+)?)([dwmyMH])")

DEFAULT_MINIMUM_TIME_UNIT = 15
DEFAULT_WORKING_DAYS_PER_WEEK  = 5
DEFAULT_WORKING_DAYS_PER_MONTH = 20
DEFAULT_WORKING_DAYS_PER_YEAR = 200
DEFAULT_WORKING_HOURS_PER_DAY = 8

DEFAULT_WORKING_TIMES = ( (8 * 60, 12 * 60 ),
                          (13 * 60, 17 * 60 ) )
DEFAULT_WORKING_DAYS = { 0 : DEFAULT_WORKING_TIMES,
                         1 : DEFAULT_WORKING_TIMES,
                         2 : DEFAULT_WORKING_TIMES,
                         3 : DEFAULT_WORKING_TIMES,
                         4 : DEFAULT_WORKING_TIMES,
                         5 : (),
                         6 : () }

</t>
<t tx="michael.20060626133545.2">def to_time_range(src):
    """
    converts a string to a timerange, i.e
    (from, to)
    from, to are ints, specifing the minutes since midnight
    """

    if not src: return ()

    mo = TIME_RANGE_PATTERN.match(src)
    if not mo:
        raise ValueError("%s is no time range" % src)

    from_time = int(mo.group(1)) * 60 + int(mo.group(2))
    to_time   = int(mo.group(3)) * 60 + int(mo.group(4))
    return from_time, to_time
</t>
<t tx="michael.20060626133545.3">def to_datetime(src):
    """
    a tolerant conversion function to convert different strings
    to a datetime.dateime
    """

    #to get the original value for wrappers
    new = getattr(src, "_value", src)
    while new is not src:
        src = new
        new = getattr(src, "_value", src)

    if isinstance(src, _WorkingDateBase):
        src = src.to_datetime()

    if isinstance(src, datetime.datetime):
        return src

    src = str(src)

    formats = [ "%x %H:%M",
                "%x",
                "%Y-%m-%d %H:%M",
                "%y-%m-%d %H:%M",
                "%d.%m.%Y %H:%M",
                "%d.%m.%y %H:%M",
                "%Y%m%d %H:%M",
                "%d/%m/%y %H:%M",
                "%d/%m/%Y %H:%M",
                "%d/%m/%Y",
                "%d/%m/%y",
                "%Y-%m-%d",
                "%y-%m-%d",
                "%d.%m.%Y",
                "%d.%m.%y",
                "%Y%m%d" ]
    for f in formats:
        try:
            conv = time.strptime(src, f)
            return datetime.datetime(*conv[0:-3])
        except Exception, e:
            pass

    raise TypeError("'%s' (%s) is not a datetime" % (src, str(type(src))))
</t>
<t tx="michael.20060626133545.4">def _to_days(src):
    """
    converts a string of the day abreviations mon, tue, wed,
    thu, fri, sat, sun to a dir with correct weekday indices.
    For Example
    convert_to_days('mon, tue, thu') results in
    { 0:1, 1:1, 3:1 }
    """

    tokens = src.split(",")
    result = { }
    for t in tokens:
        try:
            index =  { "mon" : 0,
                       "tue" : 1,
                       "wed" : 2,
                       "thu" : 3,
                       "fri" : 4,
                       "sat" : 5,
                       "sun" : 6 } [ lower(t.strip()) ]
            result[index] = 1
        except:
            raise ValueError("%s is not a day" % (t))

    return result
</t>
<t tx="michael.20060626133545.5">def _add_to_time_spans(src, to_add, is_free):
    if not isinstance(to_add, (tuple, list)):
        to_add = (to_add,)

    tmp = []
    for start, end, f in src:
        tmp.append((start, True, f))
        tmp.append((end, False, f))

    for v in to_add:
        if isinstance(v, (tuple, list)):
            start = to_datetime(v[0])
            end = to_datetime(v[1])
        else:
            start = to_datetime(v)
            end = start.replace(hour=0, minute=0) + datetime.timedelta(1)

        tmp.append((start, start &lt;= end, is_free))
        tmp.append((end, start &gt; end, is_free))

    tmp.sort()

    # 0: date
    # 1: is_start
    # 2: is_free
    sequence = []
    free_count = 0
    work_count = 0
    last = None
    for date, is_start, is_free in tmp:
        if is_start:
            if is_free:
                if not free_count and not work_count:
                    last = date

                free_count += 1
            else:
                if not work_count:
                    if free_count: sequence.append((last, date, True))
                    last = date
                work_count += 1
        else:
            if is_free:
                assert(free_count &gt; 0)
                free_count -= 1
                if not free_count and not work_count:
                    sequence.append((last, date, True))
            else:
                assert(work_count &gt; 0)
                work_count -= 1
                if not work_count: sequence.append((last, date, False))
                if free_count: last = date

    return tuple(sequence)
</t>
<t tx="michael.20060626133545.6">def to_timedelta(src, cal=None, is_duration=False):
    """
    converts a string to a datetime.timedelta. If cal is specified
    it will be used for getting the working times. if is_duration=True
    working times will not be considered. Valid units are
    d for Days
    w for Weeks
    m for Months
    y for Years
    H for Hours
    M for Minutes
    """

    cal = cal or _default_calendar
    if isinstance(src, datetime.timedelta):
        return datetime.timedelta(src.days, seconds=src.seconds, calendar=cal)

    if isinstance(src, (long, int, float)):
        src = "%sM" % str(src)

    if not isinstance(src, basestring):
        raise ValueError("%s is not a duration" % (repr(src)))

    src = src.strip()

    if is_duration:
        d_p_w = 7
        d_p_m = 30
        d_p_y = 360
        d_w_h = 24
    else:
        d_p_w = cal.working_days_per_week
        d_p_m = cal.working_days_per_month
        d_p_y = cal.working_days_per_year
        d_w_h = cal.working_hours_per_day

    def convert_minutes(minutes):
        minutes = int(minutes)
        hours   = minutes / 60
        minutes = minutes % 60
        days    = hours / d_w_h
        hours   = hours % d_w_h
        return [ days, 0, 0, 0, minutes, hours ]

    def convert_days(value):
        days = int(value)
        value -= days
        value *= d_w_h
        hours = int(value)
        value -= hours
        value *= 60
        minutes = round(value)
        return [ days, 0, 0, 0, minutes, hours ]

    sum_args = [ 0, 0, 0, 0, 0, 0 ]

    split = src.split(" ")
    for s in split:
        mo = TIME_DELTA_PATTERN.match(s)
        if not mo:
            raise ValueError(src +
                             " is not a valid duration: valid"
                             " units are: d w m y M H")

        unit = mo.group(3)
        val = float(mo.group(1))

        if unit == 'd':
            args = convert_days(val)
        elif unit == 'w':
            args = convert_days(val * d_p_w)
        elif unit == 'm':
            args = convert_days(val * d_p_m)
        elif unit == 'y':
            args = convert_days(val * d_p_y)
        elif unit == 'M':
            args = convert_minutes(val)
        elif unit == 'H':
            args = convert_minutes(val * 60)

        sum_args = [ a + b for a, b in zip(sum_args, args) ]

    sum_args = tuple(sum_args)
    return datetime.timedelta(*sum_args)
</t>
<t tx="michael.20060626133545.7">def timedelta_to_str(delta, format, cal=None, is_duration=False):
    cal = cal or _default_calendar
    if is_duration:
        d_p_w = 7
        d_p_m = 30
        d_p_y = 365
        d_w_h = 24
    else:
        d_p_w = cal.working_days_per_week
        d_p_m = cal.working_days_per_month
        d_p_y = cal.working_days_per_year
        d_w_h = cal.working_hours_per_day

    has_years = format.find("%y") &gt; -1
    has_minutes = format.find("%M") &gt; -1
    has_hours = format.find("%H") &gt; -1 or has_minutes
    has_days = format.find("%d") &gt; -1
    has_weeks = format.find("%w") &gt; -1
    has_months = format.find("%m") &gt; -1

    result = format
    days = delta.days

    d_r = (days, format)
    minutes = delta.seconds / 60

    def rebase(d_r, cond1, cond2, letter, divisor):
        #rebase the days
        if not cond1: return d_r

        days, result = d_r

        if cond2:
            val = days / divisor
            if not val:
                result = re.sub("{[^{]*?%" + letter + "[^}]*?}", "", result)

            result = result.replace("%" + letter, str(val))
            days %= divisor
        else:
            result = result.replace("%" + letter,
                                    locale.format("%.2f",
                                                  (float(days) / divisor)))

        return (days, result)

    d_r = rebase(d_r, has_years, has_months or has_weeks or has_days, "y", d_p_y)
    d_r = rebase(d_r, has_months, has_weeks or has_days, "m", d_p_m)
    d_r = rebase(d_r, has_weeks, has_days, "w", d_p_w)
    days, result = d_r

    if not has_days:
        minutes += days * d_w_h * 60
        days = 0

    if has_hours:
        if not days:
            result = re.sub("{[^{]*?%d[^}]*?}", "", result)

        result = result.replace("%d", str(days))
    else:
        result = result.replace("%d",
                                "%.2f" % (days + float(minutes)
                                        / (d_w_h * 60)))

    if has_hours:
        if has_minutes:
            val = minutes / 60
            if not val:
                result = re.sub("{[^{]*?%H[^}]*?}", "", result)

            result = result.replace("%H", str(val))
            minutes %= 60
        else:
            result = result.replace("%H", "%.2f" % (float(minutes) / 60))

    if not minutes:
        result = re.sub("{[^{]*?%M[^}]*?}", "", result)

    result = result.replace("%M", str(minutes))

    result = result.replace("{", "")
    result = result.replace("}", "")
    return result.strip()
</t>
<t tx="michael.20060626133545.8">class _CalendarItem(int):
	&lt;&lt; class _CalendarItem declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060626133545.9">__slots__ = ()
calender = None


</t>
<t tx="michael.20060626133545.10">def __new__(cls, val):
    try:
        return int.__new__(cls, val)
    except OverflowError:
        return int.__new__(cls, sys.maxint)
</t>
<t tx="michael.20060626133545.11">def round(self, round_up=True):
    m_t_u = self.calendar.minimum_time_unit

    minutes = int(self)
    base = (minutes / m_t_u) * m_t_u
    minutes %= m_t_u

    round_up = round_up and minutes &gt; 0 or minutes &gt; m_t_u / 2
    if round_up: base += m_t_u
    return self.__class__(base)
</t>
<t tx="michael.20060626133545.12">class _Minutes(_CalendarItem):
	&lt;&lt; class _Minutes declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060626133545.13">__slots__ = ()
STR_FORMAT = "{%dd}{ %HH}{ %MM}"


</t>
<t tx="michael.20060626133545.14">def __new__(cls, src=0, is_duration=False):
    """
    converts a timedelta in working minutes.
    """
    if isinstance(src, cls) or type(src) is int:
        return _CalendarItem.__new__(cls, src)

    cal = cls.calendar
    if not isinstance(src, datetime.timedelta):
        src = to_timedelta(src, cal, is_duration)

    d_w_h = is_duration and 24 or cal.working_hours_per_day
    src = src.days * d_w_h * 60 + src.seconds / 60
    return _CalendarItem.__new__(cls, src)
</t>
<t tx="michael.20060626133545.15">def __cmp__(self, other):
    return cmp(int(self), int(self.__class__(other)))
</t>
<t tx="michael.20060626133545.16">def __add__(self, other):
    try:
        return self.__class__(int(self) + int(self.__class__(other)))
    except:
        return NotImplemented
</t>
<t tx="michael.20060626133545.17">def __sub__(self, other):
    try:
        return self.__class__(int(self) - int(self.__class__(other)))
    except:
        return NotImplemented
</t>
<t tx="michael.20060626133545.18">def strftime(self, format=None, is_duration=False):
    td = self.to_timedelta(is_duration)
    return timedelta_to_str(td, format or self.STR_FORMAT,
                            self.calendar, is_duration)</t>
<t tx="michael.20060626133545.19">class _WorkingDateBase(_CalendarItem):
    """
    A daytetime which has only valid values within the
    workingtimes of a specific calendar
    """
	&lt;&lt; class _WorkingDateBase declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060626133545.20">timetuple = True
STR_FORMAT = "%x %H:%M"
_minutes = _Minutes
__slots__ = ()


</t>
<t tx="michael.20060626133545.21">def __new__(cls, src):
    #cls.__bases__[0] is the base of
    #the calendar specific StartDate and EndDate

    if isinstance(src, cls.__bases__[0]) or type(src) in (int, float):
        return _CalendarItem.__new__(cls, src)

    src = cls.calendar.from_datetime(to_datetime(src))
    return _CalendarItem.__new__(cls, src)
</t>
<t tx="michael.20060626133545.22">def __repr__(self):
    return self.strftime()
</t>
<t tx="michael.20060626133545.23">def to_datetime(self):
    return self.to_starttime()
</t>
<t tx="michael.20060626133545.24">def to_starttime(self):
    return self.calendar.to_starttime(self)
</t>
<t tx="michael.20060626133545.25">def to_endtime(self):
    return self.calendar.to_endtime(self)
</t>
<t tx="michael.20060626133545.26">def __cmp__(self, other):
    return cmp(int(self), int(self.__class__(other)))
</t>
<t tx="michael.20060626133545.27">def __add__(self, other):
    try:
        return self.__class__(int(self) + int(self._minutes(other)))
    except ValueError, e:
        raise e
    except:
        return NotImplemented
</t>
<t tx="michael.20060626133545.28">def __sub__(self, other):
    if isinstance(other, (datetime.timedelta, str, _Minutes)):
        try:
            other = self._minutes(other)
        except:
            pass

    if isinstance(other, self._minutes):
        return self.__class__(int(self) - int(other))

    try:
        return self._minutes(int(self) - int(self.__class__(other)))
    except:
        return NotImplemented
</t>
<t tx="michael.20060626133545.29">def strftime(self, format=None):
    return strftime(self.to_datetime(), format or self.STR_FORMAT)
</t>
<t tx="michael.20060626133545.30">class Calendar(object):
    """
    A calendar to specify working times and vacations.
    The calendars epoch start at 1.1.1979
    """
	&lt;&lt; declarations &gt;&gt;
	@others


_default_calendar = Calendar()

WorkingDate = _default_calendar.WorkingDate
StartDate = _default_calendar.StartDate
EndDate = _default_calendar.EndDate
Minutes = _default_calendar.Minutes
</t>
<t tx="michael.20060626133545.31"># january the first must be a monday
EPOCH = datetime.datetime(1979, 1, 1)
minimum_time_unit = DEFAULT_MINIMUM_TIME_UNIT
working_days_per_week = DEFAULT_WORKING_DAYS_PER_WEEK
working_days_per_month = DEFAULT_WORKING_DAYS_PER_MONTH
working_days_per_year = DEFAULT_WORKING_DAYS_PER_YEAR
working_hours_per_day = DEFAULT_WORKING_HOURS_PER_DAY
now = EPOCH


</t>
<t tx="michael.20060626133545.32">def __init__(self):
    self.time_spans = ()
    self._dt_num_can = ()
    self._num_dt_can = ()
    self.working_times = { }
    self._recalc_working_time()
    self._make_classes()
</t>
<t tx="michael.20060626133545.33">def set_working_days(self, day_range, trange, *further_tranges):
    """
    Sets the working days of an calendar
    day_range is a string of day abbreviations like 'mon, tue'
    trange and further_tranges is a time range string like
    '8:00-10:00'
    """
    time_ranges = [ trange ] + list(further_tranges)
    time_ranges = filter(bool, map(to_time_range, time_ranges))
    days = _to_days(day_range)

    for k in days.keys():
        self.working_times[k] = time_ranges

    self._recalc_working_time()
    self._build_mapping()
</t>
<t tx="michael.20060626133545.34">def set_vacation(self, value):
    """
    Sets vacation time.
    value is either a datetime literal or
    a sequence of items that can be
    a datetime literals and or pair of datetime literals
    """
    self.time_spans = _add_to_time_spans(self.time_spans, value, True)
    self._build_mapping()
</t>
<t tx="michael.20060626133545.35">def set_extra_work(self, value):
    """
    Sets extra working time
    value is either a datetime literal or
    a sequence of items that can be
    a datetime literals and or pair of datetime literals
    """
    self.time_spans = _add_to_time_spans(self.time_spans, value, False)
    self._build_mapping()
</t>
<t tx="michael.20060626133545.36">def _build_mapping(self):
    self._dt_num_can = self._num_dt_can = ()
    dt_num_can = []
    num_dt_can = []

    delta = self.Minutes()
    for start, end, is_free in self.time_spans:
        cstart = self.StartDate(start)
        cend = self.EndDate(end)
        nstart = cstart + delta

        if not is_free:
            d = end - start
            d = d.days * 24 * 60 + d.seconds / 60
            nend = nstart + d
        else:
            nend = nstart

        delta += (nend - nstart) - (cend - cstart)
        dt_num_can.append((start, end, nstart, nend, cend))
        num_dt_can.append((nstart, nend, start, end, cend))

    self._dt_num_can = tuple(dt_num_can)
    self._num_dt_can = tuple(num_dt_can)
</t>
<t tx="michael.20060626133545.37">def from_datetime(self, value):
    assert(isinstance(value, datetime.datetime))

    delta = value - self.EPOCH
    days = delta.days
    minutes = delta.seconds / 60

    #calculate the weektime
    weeks = days / 7
    wtime = self.week_time * weeks

    #calculate the daytime
    days %= 7
    dtime = sum(self.day_times[:days])

    #calculate the minute time
    slots = self.working_times.get(days, DEFAULT_WORKING_DAYS[days])
    mtime = 0
    for start, end in slots:
        if minutes &gt; end:
            mtime += end - start
        else:
            if minutes &gt; start:
                mtime += minutes - start
            break

    result = wtime + dtime + mtime

    #map exceptional timespans
    dt_num_can = self._dt_num_can
    pos = bisect.bisect(dt_num_can, (value,)) - 1
    if pos &gt;= 0:
        start, end, nstart, nend, cend = dt_num_can[pos]
        if value &lt; end:
            if nstart &lt; nend:
                delta = value - start
                delta = delta.days * 24 * 60 + delta.seconds / 60
                result = nstart + delta
            else:
                result = nstart
        else:
            result += (nend - cend) # == (result - cend) + nend

    return result
</t>
<t tx="michael.20060626133545.38">def split_time(self, value):
    #map exceptional timespans
    num_dt_can = self._num_dt_can
    pos = bisect.bisect(num_dt_can, (value, sys.maxint)) - 1
    if pos &gt;= 0:
        nstart, nend, start, end, cend = num_dt_can[pos]
        if value &lt; nend:
            value = start + datetime.timedelta(minutes=value - nstart)
            delta = value - self.EPOCH
            return delta.days / 7, delta.days % 7, delta.seconds / 60, -1
        else:
            value += (cend - nend) # (value - nend + cend)

    #calculate the weeks since the epoch
    weeks = value / self.week_time 
    value %= self.week_time

    #calculate the remaining days
    days = 0
    for day_time in self.day_times:
        if value &lt; day_time: break
        value -= day_time
        days += 1

    #calculate the remaining minutes
    minutes = 0
    slots = self.working_times.get(days, DEFAULT_WORKING_DAYS[days])
    index = 0
    for start, end in slots:
        delta = end - start
        if delta &gt; value:
            minutes = start + value
            break
        else:
            value -= delta

        index += 1

    return weeks, days, minutes, index
</t>
<t tx="michael.20060626133545.39">def to_starttime(self, value):
    weeks, days, minutes, index = self.split_time(value)
    return self.EPOCH + datetime.timedelta(weeks=weeks,
                                           days=days,
                                           minutes=minutes)
</t>
<t tx="michael.20060626133545.40">def to_endtime(self, value):
    return self.to_starttime(value - 1) + datetime.timedelta(minutes=1)
</t>
<t tx="michael.20060626133545.41">def get_working_times(self, day):
    return self.working_times.get(day, DEFAULT_WORKING_DAYS[day])
</t>
<t tx="michael.20060626133545.42">def _recalc_working_time(self):
    def slot_sum_time(day):
        slots = self.working_times.get(day, DEFAULT_WORKING_DAYS[day])
        return sum(map(lambda slot: slot[1] - slot[0], slots))

    self.day_times = map(slot_sum_time, range(0, 7))
    self.week_time = sum(self.day_times)
</t>
<t tx="michael.20060626133545.43">def _make_classes(self):
    #ensure that the clases are instance specific
    class minutes(_Minutes):
        calendar = self
        __slots__ = ()

    class db(_WorkingDateBase):
        calendar = self
        _minutes = minutes
        __slots__ = ()

    class wdt(db): __slots__ = ()
    class edt(db):
        __slots__ = ()

        def to_datetime(self):
            return self.to_endtime()

    self.Minutes, self.StartDate, self.EndDate = minutes, wdt, edt
    self.WorkingDate = self.StartDate
</t>
<t tx="michael.20060626133839">def to_timedelta(self, is_duration=False):
    d_w_h = is_duration and 24 or self.calendar.working_hours_per_day
    minutes = int(self)
    hours = minutes / 60
    minutes = minutes % 60
    days = hours / d_w_h
    hours = hours % d_w_h
    return datetime.timedelta(days, hours=hours, minutes=minutes)</t>
<t tx="michael.20060626184639">def traceback(self, exc, tb, string_replacement=("&lt;string&gt;", 1)):
    tb = traceback.extract_tb(tb)
    tb.reverse()

    print &gt;&gt; sys.stderr, "%s: %s" % (exc.__class__.__name__, str(exc))
    for t in tb:
        filename, line = t[:2]
        if filename == "&lt;string&gt;":
            filename, line = string_replacement

        if is_project_file(filename, self.main_buffer.path)\
               or _faces._DEBUGGING:
            print &gt;&gt; sys.stderr, '\tFile "%s", line %i' % (filename, line)
</t>
<t tx="michael.20060627100623"></t>
<t tx="michael.20060627124836">class RefDate(db.Model):
    """
    A date that can refer to other tasks
    """
    fixed = db.DateTime(none=True)

    @others</t>
<t tx="michael.20060627124836.1">class Predecessor(db.Model):
    path = db.Text()
    relative = db.Boolean(default=False)
    lag = db.Text()
    ptype = db.Enumerate({ "end" : "end" , "start" : "start" },
                         default="end")
    all_paths = []

    @others

db.Relation("refdate_predecessor",
            db.End(Predecessor, "preds", multi='*'),
            db.End(RefDate))</t>
<t tx="michael.20060627125048">class RefDateView(views.FormView):
    __model__ = RefDate
    __view_name__ = "default"
    vgap = 0
    format = _("""
fixed
(0,3)
[Predecessors:]
predecessors&gt;
(0,3)
delete
""")

    @others
</t>
<t tx="michael.20060627125048.1">class PredecessorGrid(grid.EditGrid, views.GridView):
    __model__ = Predecessor
    columns = (("path(auto_tree)", _("Path")),
               (Predecessor.relative, _("Relative")),
               (Predecessor.lag, _("Lag")),
               (Predecessor.ptype, _("Type")))
    resize_col = 0


    def create_paths(self, code_item):
        root = get_code_root(code_item)
        self.all_paths = all_paths = [ "root" ]

        def add_path(item, prefix):
            if item.name[0] == "_": return
            prefix = "%s.%s" % (prefix, item.name)
            all_paths.append(prefix)
            map(lambda c: add_path(c, prefix), item.get_children())

        map(lambda c: add_path(c, "root"), root.get_children())

        length = all_paths and max(map(len, all_paths)) or 1
        self.set_width(0, "N" * length + "XXX")



    def prepare(self, attribute):
        if attribute == "path":
            self.path.fill_tree(self.all_paths)





</t>
<t tx="michael.20060627125439">def __init__(self, code_item, attrib, value):
    super(RefDate, self).__init__()
    self.code_item = code_item
    self.item_path = editor.get_code_item_path(code_item)

    &lt;&lt; define path_argument &gt;&gt;

    def is_predecessor(obj):
        return isinstance(obj, AttributeWrapper) and obj.attrib in ("start", "end")

    def parse_value(value):
        if isinstance(value, tuple):
            operand = value[0]
            if operand == max:
                map(parse_value, value[1:])
                return
            &lt;&lt; add predecessor with lag &gt;&gt;

        if is_predecessor(value):
            &lt;&lt; add predecessor without lag &gt;&gt;

        if isinstance(value, (basestring, datetime.datetime)):
            &lt;&lt; set fixed date &gt;&gt;

    self.fixed = None            
    parse_value(ftask._val(value))


</t>
<t tx="michael.20060627150618">def create_controls(self):
    self.predecessors = self.get_control("preds(PredecessorGrid)")
    self.delete = self.predecessors.get_delete_button(self)</t>
<t tx="michael.20060627150618.1">def prepare(self):
    self.grow_col(0)
    self.grow_row(3)</t>
<t tx="michael.20060627150618.2">def constitute(self, imodel):
    super(RefDateView, self).constitute(imodel)
    self.predecessors.create_paths(imodel.code_item)
    self.layout()
</t>
<t tx="michael.20060627153216">class AttributeWrapper(object):
    def __init__(self, path, attrib):
        self.path = path
        self.attrib = attrib

    def __str__(self):
        return "%s.%s" % (str(self.path), self.attrib)</t>
<t tx="michael.20060627153941">me = PathWrapper(context.code_item, "me")
up = me.up
root = me.root
up._path_str = "up"
root._path_str = "root"</t>
<t tx="michael.20060627153941.1">def to_value_wrapper(a):
    if isinstance(a, ValueWrapper):
        return a

    return ValueWrapper(a, [])

def wmax(*args):
    args = map(to_value_wrapper, args)
    first = args[0]
    return first._vw(max, *args)

def wmin(*args):
    args = map(to_value_wrapper, args)
    first = args[0]
    return first._vw(min, *args)</t>
<t tx="michael.20060627172634">sign = { operator.add : "+", operator.sub : "-" }.get(value[0])
if not sign: return

pred = None
lag = None
for v in value[1:]:
    if is_predecessor(v):
        pred = v
    elif isinstance(v, basestring):
        lag = v

if pred:
    self.preds.insert(Predecessor(lag=sign+lag, 
                                  ptype=pred.attrib,
                                  **path_argument(pred.path)))

return</t>
<t tx="michael.20060627172805">self.preds.insert(Predecessor(value=value.attrib,
                              **path_argument(value.path)))
return</t>
<t tx="michael.20060627172805.1">try:
    self.fixed = pcalendar.to_datetime(value)
except ValueError:
    pass
return</t>
<t tx="michael.20060628145509">def button_refresh(self):
    if self.save():
        self.GetParent().EndModal(wx.ID_OK)
        self.imodel.realize()
        controller().session.menu_recalc()</t>
<t tx="michael.20060628145509.1">def get_stock_control(self, parent, name):
    if name == "btn_refresh":
        parent.btn_refresh = wx.Button(parent, wx.ID_REFRESH)
        parent.btn_refresh.Bind(wx.EVT_BUTTON, lambda ev: self.button_refresh())
        parent.btn_refresh.SetDefault()
        self.set_default_item(parent.btn_refresh)
        return parent.btn_refresh

    ctrl = super(MainView, self).get_stock_control(parent, name)
    if name == "btn_ok" and not hasattr(parent, "btn_refresh"):
        ctrl.SetDefault()
        self.set_default_item(ctrl)

    return ctrl</t>
<t tx="michael.20060628221243">def check_constraints(self):
    error = db.ConstraintError()    
    if not self.path:
        error.message["path"] = _("you have to sperciy a path")

    if self.lag: 
        lag = self.lag.replace("+", "").replace("-", "")

        try:
            val = pcalendar.to_timedelta(self.lag)
        except Exception:
            error.message["lag"] = _("not a valid time delta")

    if error.message:
        raise error</t>
<t tx="michael.20060628221722">def __str__(self):
    preds = [ p.to_string(self.item_path) for p in self.preds ]
    if self.fixed:
        preds.append(self.fixed.strftime('"%x %H:%M"'))

    if len(preds) &gt; 1:
        return "max(%s)" % ", ".join(preds)
    else:
        return "".join(preds)</t>
<t tx="michael.20060628221746">def to_string(self, item_path):
    path = self.path
    if self.relative:
        path = ftask.create_relative_path(item_path, path)

    result = "%s.%s" % (path, self.ptype)
    if self.lag:
        if self.lag[0] in ("+", "-"):
            result += ' %s "%s"' % (self.lag[0], self.lag[1:])
        else:
            result += ' + "%s"' % self.lag

    return result</t>
<t tx="michael.20060628231054">def replace_expression(self, text, start_line=None, with_end=False, move_cursor=True):
    self.BeginUndoAction()

    start, end = self.get_expression_range(start_line, with_end)
    start_line = self.LineFromPosition(start)
    start_indent = self.GetLineIndentation(start_line)

    if start &lt; end:
        self.SetTargetStart(start)
        self.SetTargetEnd(end)
        self.ReplaceTarget(text)
    else:
        self.InsertText(start, text)

    if move_cursor: self.GotoPos(start + len(text))

    lines = text.split("\n")
    &lt;&lt; auto indent text &gt;&gt;
    self.EndUndoAction()
    self.check_code_updates(start_line, line)
</t>
<t tx="michael.20060629005237">try:
    module = sys.modules[m]
except KeyError: continue

try:
    module.faces_clean_up()
except AttributeError: pass

del sys.modules[m]</t>
<t tx="michael.20060703170652">self.__change_count += 1
if self.__change_count &gt;= 50:
    self.model.save_backup()
    self.__change_count = 0</t>
<t tx="michael.20060703173400"></t>
<t tx="michael.20060703173400.1"></t>
<t tx="michael.20060703173400.2"></t>
<t tx="michael.20060703173400.3"></t>
<t tx="michael.20060703173400.4"></t>
<t tx="michael.20060703173400.5"></t>
<t tx="michael.20060703173916">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A special axes for faces charts
"""
&lt;&lt; Imports &gt;&gt;
@others
</t>
<t tx="michael.20060703173916.1">import matplotlib.axes as axes
import matplotlib.artist as artist
import matplotlib.transforms as mtrans
import matplotlib.ticker as ticker
import matplotlib._image as mimage
import matplotlib.font_manager as font
import widgets
import sys
import tools
import patches
import renderer as prend
import math


</t>
<t tx="michael.20060703173916.3">def _cint(val): return int(math.ceil(val))
</t>
<t tx="michael.20060703173916.4">def cut_canvas(axes, reset=False):
    try:
        bbox = axes.content_bbox
    except AttributeError:
        bbox = axes.bbox

    try:
        if not reset and axes._last_viewbounds != bbox.get_bounds():
            #when the size has changed, don't scale
            old_bbox = mtrans.lbwh_to_bbox(*axes._last_viewbounds)
            trans = mtrans.get_bbox_transform(axes.viewLim, old_bbox)
            data_box = mtrans.inverse_transform_bbox(trans, bbox)
            xmin = axes.viewLim.xmin()
            ymax = axes.viewLim.ymax()

            if not axes._sharey: 
                axes.set_ylim(ymax - data_box.height(), ymax, emit=True)

            if not axes._sharex: 
                axes.set_xlim(xmin, xmin + data_box.width(), emit=True)
    except AttributeError:
        pass

    axes._last_viewbounds = bbox.get_bounds()
</t>
<t tx="michael.20060703173916.5">


class _WidgetCollection(artist.Artist):
	&lt;&lt; class _WidgetCollection declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060703173916.6"># a dummy to avoid a complete rewrite of axes draw
zorder = -1

</t>
<t tx="michael.20060703173916.7">def __init__(self, draw_forward):
    artist.Artist.__init__(self)
    self.draw_forward = draw_forward
</t>
<t tx="michael.20060703173916.8">def draw(self, renderer):
    if self.get_visible():
        self.draw_forward(renderer)
</t>
<t tx="michael.20060703173916.9">            #time_it(self.draw_forward, renderer)



def _get_margin(name, kwargs):
    margin = kwargs.get(name + "_margin")
    if margin is not None:
        del kwargs[name + "_margin"]
    else:
        margin = mtrans.Value(0)

    return margin
</t>
<t tx="michael.20060703173916.10">class MarginAxes(axes.Axes):
    """
    An axes with a title bar inside the axes
    """
	@others
</t>
<t tx="michael.20060703173916.11">def __init__(self, *args, **kwargs):
    self.top_margin = _get_margin("top", kwargs)
    self.bottom_margin = _get_margin("bottom", kwargs)
    self.left_margin = _get_margin("left", kwargs)
    self.right_margin = _get_margin("right", kwargs)
    axes.Axes.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060703173916.12">def build_margin_transform(self, left=True, bottom=True,
                           right=True, top=True):
    Bbox = mtrans.Bbox
    Point = mtrans.Point
    get_bbox_transform = mtrans.get_bbox_transform

    if left:
        left_margin = self.left_margin * self.fig_point_to_pixel
        left = self.bbox.ll().x() + left_margin
    else:
        left = self.bbox.ll().x()

    if right:
        right_margin = self.right_margin * self.fig_point_to_pixel
        right = self.bbox.ur().x() - right_margin
    else:
        right = self.bbox.ur().x()

    if top:
        top_margin = self.top_margin * self.fig_point_to_pixel
        top = self.bbox.ur().y() - top_margin
    else:
        top = self.bbox.ur().y()

    if bottom:
        bottom_margin = self.bottom_margin * self.fig_point_to_pixel
        bottom = self.bbox.ll().y() + bottom_margin
    else:
        bottom = self.bbox.ll().y()

    bbox = Bbox(Point(left, bottom), Point(right, top))

    transform = get_bbox_transform(self.viewLim, bbox)
    transform.set_funcx(self.transData.get_funcx())
    transform.set_funcy(self.transData.get_funcy())
    return transform
</t>
<t tx="michael.20060703173916.13">def _set_lim_and_transforms(self):
    axes.Axes._set_lim_and_transforms(self)
    self.fig_point_to_pixel = self.get_figure().dpi / mtrans.Value(72)

    self.org_transData = self.transData
    self.org_transAxes = self.transAxes

    self.transData = self.build_margin_transform()
    self.content_bbox = self.transData.get_bbox2()
    #self.content_bbox is self.bbox reduced by the margins

    self.transAxes = mtrans.get_bbox_transform(mtrans.unit_bbox(),
                                               self.content_bbox)
</t>
<t tx="michael.20060703173916.14">def in_axes(self, xwin, ywin):
    return self.content_bbox.contains(xwin, ywin)
</t>
<t tx="michael.20060703173916.15">def cla(self):
    axes.Axes.cla(self)
    self.axesPatch.set_transform(self.org_transAxes)
</t>
<t tx="michael.20060703173916.16">def draw(self, renderer, inframe=False):
    axes.Axes.draw(self, renderer, inframe)
    if self.axison and self._frameon:
        fill = self.axesPatch.get_fill()
        self.axesPatch.set_fill(False)
        self.axesPatch.draw(renderer)
        self.axesPatch.set_fill(fill)
</t>
<t tx="michael.20060703173916.17">class WidgetAxes(MarginAxes):
    """
    An axes which is optimized to display widgets.
    If widgets are not inside the current view they will not
    be drawn.
    """
	@others
</t>
<t tx="michael.20060703173916.18">def __init__(self, *args, **kwargs):
    self._first_draw = True
    self._fobj_map = {}
    self.widgets = []
    self._visible_widgets = []
    self.widget_artist = _WidgetCollection(self._draw_widgets)
    MarginAxes.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060703173916.19">def cla(self):
    MarginAxes.cla(self)

    self.dataLim.intervalx().set_bounds(sys.maxint, -sys.maxint)
    self.dataLim.intervaly().set_bounds(sys.maxint, -sys.maxint)
    self._fobj_map.clear()
    self.widgets = []
    self.marker = patches.Rectangle((0,0), 0, 0)
    self.marker.widget = None
    self.marker.set_visible(False)
    self.add_artist(self.marker)
    self.marker.set_clip_box(self.content_bbox)
    self.xaxis.set_major_locator(ticker.NullLocator())
    self.xaxis.set_minor_locator(ticker.NullLocator())
    self.yaxis.set_major_locator(ticker.NullLocator())
    self.yaxis.set_minor_locator(ticker.NullLocator())
    self.reset_limits()
    self.add_collection(self.widget_artist)
</t>
<t tx="michael.20060703173916.20">def check_limits(self, cut=True):
    """
    Changes the viewLimits to reasonable values
    """
    if cut: cut_canvas(self)
</t>
<t tx="michael.20060703173916.21">def reset_limits(self, cut=True):
    """
    Sets the data width and data size to the default values.
    e.g. reset the y axis to display the fonts in the original size
    """
    self.check_limits(cut)
    vmin, vmax = self.get_ylim()
    height = self.content_bbox.height() / self.fig_point_to_pixel.get()
    self.set_ylim(vmax - height, vmax, emit=True)
</t>
<t tx="michael.20060703173916.22">def _get_renderer(self):
    if not self._cachedRenderer:
        Renderer = prend.PatchedRendererAgg
        self._cachedRenderer = Renderer(10, 10, self.get_figure().dpi)

    return self._cachedRenderer
</t>
<t tx="michael.20060703173916.23">def add_widget(self, widget):
    if widget.fobj:
        idendity = widget.fobj._idendity_()
        self._fobj_map.setdefault(idendity, []).append(widget)

    self.widgets.append(widget)
    widget.axes = self
    widget.set_figure(self.figure)
    widget.set_clip_box(self.content_bbox)
    widget.set_transform(self.transData)

    tools.HSEP.set(5)
    horz, vert = widget.prepare_draw(self._get_renderer(),
                                     self.point_to_pixel,
                                     self.fig_point_to_pixel)
    #update data lim
    if horz:
        set_bounds = self.dataLim.intervalx().set_bounds
        set_bounds(min(widget.bbox.xmin(), self.dataLim.xmin()),
                   max(widget.bbox.xmax(), self.dataLim.xmax()))


    if vert:
        set_bounds = self.dataLim.intervaly().set_bounds
        extra = tools.VSEP.get() * 4
        set_bounds(min(widget.bbox.ymin() - extra, self.dataLim.ymin()), 0)

</t>
<t tx="michael.20060703173916.24">def mark_widget(self, widget=None):
    ow = self.marker.widget
    self.marker.widget = widget
    if not widget: self.marker.set_visible(False)
    return ow != widget
</t>
<t tx="michael.20060703173916.25">def find_widget(self, fobj):
    if fobj is str:
        return self._fobj_map.get(fobj)

    idendity = fobj._idendity_()
    widgets = self._fobj_map.get(idendity, ())

    #first try to find visible widgets 
    identicals = filter(lambda w: w.fobj is fobj, widgets)
    for w in identicals:
        if w in self._visible_widgets: return w

    if identicals: return identicals[0]

    for w in widgets:
        if w in self._visible_widgets: return w

    return widgets and widgets[0] or None
</t>
<t tx="michael.20060703173916.26">def widget_at(self, x, y):
    self._calc_hsep()
    found = filter(lambda w: w.contains(x, y), self._visible_widgets)
    if found: return found[-1]
    return None
</t>
<t tx="michael.20060703173916.27">def set_focused_on(self):
    self.marker.update(self.focused_props)
</t>
<t tx="michael.20060703173916.28">def set_focused_off(self):
    self.marker.update(self.marker_props)
</t>
<t tx="michael.20060703173916.29">def set_marker(self, focused_props, normal_props):
    self.focused_props = focused_props
    self.marker_props = normal_props
    self.marker.update(normal_props)
</t>
<t tx="michael.20060703173916.30">def widget_x_visible(self, widget):
    self._calc_hsep()
    bbox = widget.get_bounds(self._get_renderer())
    xmin, xmax = self.get_xlim()
    width = xmax - xmin
    wxmin, wxmax = bbox.intervalx().get_bounds()
    wwidth = wxmax - wxmin

    vwidth = min(wwidth, width)

    if wxmax &lt;= xmin + vwidth:
        xmin = wxmax - vwidth
        xmax = xmin + width

    if wxmin &gt;= xmax - vwidth:
        xmax = wxmin + vwidth
        xmin = xmax - width

    self.set_xlim(xmin, xmax)
</t>
<t tx="michael.20060703173916.31">def widget_y_visible(self, widget):
    ymin, ymax = self.get_ylim()
    height = ymax - ymin
    wymin, wymax = widget.bbox.intervaly().get_bounds()
    if wymax &lt;= ymin + height / 2:
        ymin = wymax - height / 2
        ymax = ymin + height

    if wymin &gt;= ymax - height / 2:
        ymax = wymin + height / 2
        ymin = ymax - height

    self.set_ylim(ymin, ymax)
</t>
<t tx="michael.20060703173916.32">def zoomx(self, numsteps):
    MarginAxes.zoomx(self, numsteps)
    if self.marker.get_visible():
        self.widget_x_visible(self.marker.widget)
        self.widget_y_visible(self.marker.widget)
</t>
<t tx="michael.20060703173916.33">def zoomy(self, numsteps):
    MarginAxes.zoomy(self, numsteps)

    if self.marker.get_visible():
        self.widget_x_visible(self.marker.widget)
        self.widget_y_visible(self.marker.widget)

</t>
<t tx="michael.20060703173916.34">def _calc_hsep(self):
    trans = self.transData
    vsep = tools.VSEP.get() * self.point_to_pixel.get()
    origin = trans.inverse_xy_tup((0, 0))
    seps = trans.inverse_xy_tup((vsep, vsep))
    tools.HSEP.set(seps[0] - origin[0])
</t>
<t tx="michael.20060703173916.35">def _draw_widgets(self, renderer):
    trans = self.transData
    data_box = mtrans.inverse_transform_bbox(trans, self.content_bbox)
    self._calc_hsep()

    if self._speed_cache:
        l, b, w, h = self._speed_bbox.get_bounds()
        l, b = self.transData.xy_tup((l, b))
        renderer.draw_image(l, b, self._speed_cache, self.content_bbox)

        for w in self.widgets:
            if isinstance(w, (widgets.Row, widgets.Column)):
                w.draw(renderer, data_box)

        self._visible_widgets = self.widgets
    else:
        self._visible_widgets = [ w for w in self.widgets
                                  if w.draw(renderer, data_box) ]

    #print "widgets drawn", len(self._visible_widgets)
    if self.marker.widget:
        if self.marker.widget.overlaps(data_box):
            bbox = self.marker.widget.bbox
            self.marker.set_bounds(*bbox.get_bounds())
            self.marker.set_visible(True)
        else:
            self.marker.set_visible(False)
</t>
<t tx="michael.20060703173916.36">def clear_speed_cache(self):
    self._speed_cache = None
</t>
<t tx="michael.20060703173916.37">_speed_cache = None
def speed_up(self, max_size):
    self._speed_cache = None

    if not self.widgets: return

    self._calc_hsep()
    renderer = self._get_renderer()
    all_data = self.dataLim.deepcopy()

    xmin = ymin = sys.maxint
    xmax = ymax = -sys.maxint

    for w in self.widgets:
        bounds = w.get_bounds(renderer)
        xmin = min(xmin, bounds.xmin())
        xmax = max(xmax, bounds.xmax())
        ymin = min(ymin, bounds.ymin())
        ymax = max(ymax, bounds.ymax())

    all_data.intervalx().set_bounds(xmin, xmax)
    all_data.intervaly().set_bounds(ymin, ymax)

    all_view = mtrans.transform_bbox(self.transData, all_data)

    # increase view because of rounding mistakes
    xmin, xmax = all_view.intervalx().get_bounds()
    ymin, ymax = all_view.intervaly().get_bounds()
    all_view.intervalx().set_bounds(xmin - 1, xmax + 1) 
    all_view.intervaly().set_bounds(ymin - 1, ymax + 1)

    if all_view.width() * all_view.height() * 4 &gt; max_size:
        return

    #adjust all_data to increased all_view
    all_data = mtrans.inverse_transform_bbox(self.transData, all_view)

    Renderer = prend.SpeedupRenderer
    cache = Renderer(_cint(all_view.width()), _cint(all_view.height()),
                     self.get_figure().dpi)


    render_bbox = mtrans.lbwh_to_bbox(0, 0, all_view.width(), all_view.height())
    all_trans = mtrans.get_bbox_transform(all_data, render_bbox)

    for w in self.widgets:
        if isinstance(w, (widgets.Row, widgets.Column)): continue
        w.set_transform(all_trans)
        w.set_clip_box(render_bbox)
        w.draw(cache, all_data)
        w.set_transform(self.transData)
        w.set_clip_box(self.content_bbox)

    self._speed_cache = mimage.frombuffer(cache.buffer_rgba(0, 0),
                                          cache.width, cache.height, 1)
    if self._speed_cache:
        self._speed_cache.flipud_out()
        self._speed_bbox = all_data
</t>
<t tx="michael.20060703173916.38">def draw(self, renderer, inframe=False):
    if self._first_draw:
        self._first_draw = False
        widgets = map(lambda w: (w[1].zorder, w[0], w[1]),
                      enumerate(self.widgets))
        widgets.sort()
        self.widgets = map(lambda ziw: ziw[2], widgets)

    MarginAxes.draw(self, renderer, inframe)
</t>
<t tx="michael.20060703173916.39">def _set_lim_and_transforms(self):
    Bbox = mtrans.Bbox
    Point = mtrans.Point

    MarginAxes._set_lim_and_transforms(self)
    dtop = self.viewLim.ur().y()
    dbottom = self.viewLim.ll().y()

    vtop = self.content_bbox.ur().y()
    vbottom = self.content_bbox.ll().y()
    self.point_to_pixel = (vtop - vbottom) / (dtop - dbottom)
    cut_canvas(self, True)
</t>
<t tx="michael.20060703173916.40">class PointAxes(WidgetAxes):
    """
    An axes which scales x, y proportional to points
    """
	@others
</t>
<t tx="michael.20060703173916.41">def __init__(self, *args, **kwargs):
    WidgetAxes.__init__(self, *args, **kwargs)
    self.zoomx = self.zoomy
</t>
<t tx="michael.20060703173916.42">def cla(self):
    WidgetAxes.cla(self)
    self.dataLim.intervalx().set_bounds(0, 0)
    self.dataLim.intervaly().set_bounds(0, 0)
</t>
<t tx="michael.20060703173916.43">__last_size = (0, 0)
def check_limits(self, cut=True):
    WidgetAxes.check_limits(self, cut)
    size = (self.viewLim.width(), self.viewLim.height())
    if size != self.__last_size:
        prop = self.content_bbox.width() / self.content_bbox.height()
        pwidth = size[1] * prop
        if pwidth != size[0]:
            #we have to correct x
            size = (pwidth, size[1])
            xmin = self.viewLim.xmin()
            self.set_xlim(xmin, xmin + pwidth)

        self.__last_size = size
</t>
<t tx="michael.20060703173916.44">def autoscale_view(self, cut=True):
    if not self._autoscaleon: return
    self.check_limits(cut)

    width = self.dataLim.width()
    height = self.dataLim.height()

    prop = self.content_bbox.width() / self.content_bbox.height()
    pwidth = height * prop

    xmin = self.dataLim.xmin()
    ymax = self.dataLim.ymax()

    if pwidth &gt; width:
        self.set_xlim(xmin, xmin + pwidth)
        self.set_ylim(ymax - height, ymax)
    else:
        self.set_xlim(xmin, xmin + width)
        self.set_ylim(ymax - width / prop, ymax)

    self.__last_size = (self.viewLim.width(), self.viewLim.height())
</t>
<t tx="michael.20060703173916.45">class TimeAxes(object):
	&lt;&lt; class TimeAxes declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060703173916.46">time_axis = None
time_scale = None


</t>
<t tx="michael.20060703173916.47">def set_time_axis(self, time_axis):
    try:
        self.collections.remove(self.time_axis)
    except ValueError:
        pass

    self.time_axis = time_axis
    self.add_collection(self.time_axis)
    axis_transform = self.build_margin_transform(top=False)
    self.time_axis.set_transform(axis_transform)
    self.time_axis.set_clip_box(axis_transform.get_bbox2())
    self.update_time_axis()
</t>
<t tx="michael.20060703173916.48">def xaxis_timescale(self, time_scale):
    self.time_scale = time_scale
    self.xaxis.set_major_locator(ticker.NullLocator())
    self.xaxis.set_minor_locator(ticker.NullLocator())
</t>
<t tx="michael.20060703173916.49">def set_time_lim(self, xmin=None, xmax=None, emit=False):
    xmin = xmin and self.time_scale.to_num(xmin)
    xmax = xmax and self.time_scale.to_num(xmax)
    self.set_xlim(xmin=xmin, xmax=xmax, emit=emit)
</t>
<t tx="michael.20060703173916.50">def get_time_lim(self):
    xmin, xmax = self.get_xlim()
    xmin = self.time_scale.to_num(int(xmin))
    xmax = self.time_scale.to_num(int(xmax))
    return xmin.to_datetime(), xmax.to_datetime()
</t>
<t tx="michael.20060703173916.51">def format_coord(self, x, y):
    'return a format string formatting the x, y coord'

    if self.time_scale:
        xs = self.time_scale.to_num(int(x)).strftime()
    else:
        xs = self.format_xdata(x)

    ys = self.format_ydata(y)
    return  'x=%s, y=%s'%(xs,ys)
</t>
<t tx="michael.20060703173916.52">def update_time_axis(self):
    ah = self.time_axis \
         and self.time_axis.get_visible() \
         and self.time_axis.calc_height() or 0

    self.top_margin.set(ah)
</t>
<t tx="michael.20060703173916.53">def unshare(self):
    self._sharex = None
    self._sharey = None
</t>
<t tx="michael.20060703173916.54">class TimePlotAxes(TimeAxes, MarginAxes):
	&lt;&lt; class TimePlotAxes declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060703173916.55">first_draw = True

</t>
<t tx="michael.20060703173916.56">def __init__(self, *args, **kwargs):
    MarginAxes.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060703173916.57">def draw(self, renderer, inframe=False):
    if self.first_draw:
        self.first_draw = False
        for a in self.lines: a.set_clip_box(self.content_bbox)
        for a in self.texts: a.set_clip_box(self.content_bbox)
        for a in self.patches: a.set_clip_box(self.content_bbox)
        for a in self.artists: a.set_clip_box(self.content_bbox)

    MarginAxes.draw(self, renderer, inframe)
    cut_canvas(self, True)
</t>
<t tx="michael.20060703173916.58">class TimeWidgetAxes(TimeAxes, WidgetAxes):
    """
    An axes wich displays widgets horizontal in time. (e.g. GanttCharts)
    """
	&lt;&lt; class TimeWidgetAxes declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060703173916.59">auto_scale_y = False

</t>
<t tx="michael.20060703173916.60">def __init__(self, *args, **kwargs):
    WidgetAxes.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20060703173916.61">def set_auto_scale_y(self, do_scale=True):
    self.auto_scale_y = do_scale
</t>
<t tx="michael.20060703173916.62">def check_limits(self, cut=True):
    WidgetAxes.check_limits(self, cut)

    vmin, vmax = self.viewLim.intervaly().get_bounds()
    if vmax &gt; 0:
        self.viewLim.intervaly().set_bounds((vmin - vmax), 0)
</t>
<t tx="michael.20060703173916.63">def autoscale_view(self, cut=True):
    if not self._autoscaleon: return
    self.check_limits(cut)

    all_data = self.dataLim.deepcopy()
    reduced = self.content_bbox.deepcopy()
    renderer = self._get_renderer()

    if self.auto_scale_y:
        ymin, ymax = self.dataLim.intervaly().get_bounds()
        self.set_ylim(ymin, ymax)
    else:
        self.reset_limits()

    xmin, xmax = self.dataLim.intervalx().get_bounds()
    self.set_xlim(xmin, xmax, emit=False)
    self._calc_hsep()

    #Notice: it is not correct to just get the bounds
    #in the actual data coords an set the view limits
    #This is because text on the left or right bound
    #has always the same pixel width. This means the text witdh
    #in data coord changes when the data coord scale changes.

    #find out the bounds in actual data coords
    for w in self.widgets:
        bounds = w.get_bounds(renderer)
        xmin = min(xmin, bounds.xmin())
        xmax = max(xmax, bounds.xmax())

    all_data.intervalx().set_bounds(xmin, xmax)

    #the complete bound in pixel coords
    all_view = mtrans.transform_bbox(self.transData, all_data)
    add_space = 0.08 * self.get_figure().get_dpi() #2mm margin left an right

    left_offset = self.content_bbox.xmin() - all_view.xmin() + add_space
    right_offset = all_view.xmax() - self.content_bbox.xmax() + add_space
    width = self.content_bbox.width()

    if left_offset &gt; width / 4: left_offset = width / 4
    if right_offset &gt; width / 4: right_offset = width / 4

    # scale down the pixel bounds
    xmin1 = self.content_bbox.xmin() + left_offset
    xmax1 = self.content_bbox.xmax() - right_offset
    reduced.intervalx().set_bounds(xmin1, xmax1)

    # create a new transformation from scaled down pixel coords to limits
    trans = mtrans.get_bbox_transform(reduced, self.viewLim)
    data_box = mtrans.transform_bbox(trans, self.content_bbox)
    self.set_xlim(data_box.xmin(), data_box.xmax(), emit=True)
    cut_canvas(self, True)
</t>
<t tx="michael.20060703173916.64">def widget_at(self, x, y):
    return WidgetAxes.widget_at(self, x, y)
</t>
<t tx="michael.20060703181442">
inside_ext = map(extent, self.text_inside)
contains = bb_shape_view.contains

inside = inside_ext[-1]
inside_text = self.text_inside[-1]
outside_text = self.text_inside[0] 

mid = (inside.ymin() + inside.ymax()) / 2
if contains(inside.xmin(), mid) and contains(inside.xmax(), mid):
    outside_text.set_visible(False)
    inside_text.set_visible(True)
else:
    outside_text.set_visible(True)
    inside_text.set_visible(False)</t>
<t tx="michael.20060703191028">main_module = new.module(module_name)
main_module.__file__ = path
main_module._faces_source_file = path
main_module.__name__ = "__faces_main__"
</t>
<t tx="michael.20060703191028.1">text = self.main_buffer.text
controller().progress_update(2)
code = compile(text, path, "exec")
controller().progress_update(3)
exec code in main_module.__dict__
controller().progress_update(4)</t>
<t tx="michael.20060703211129">new_modules = filter(lambda m: m[0] not in actual_modules and m[1],\
                     sys.modules.iteritems())
new_modules = dict(new_modules)                    

def set_module_data(module):
    source_file = getsourcefile(module)
    if source_file:
        module._faces_source_file = source_file
        try:
            module._faces_modtime = os.stat(source_file)[stat.ST_MTIME]
        except OSError:
            module._faces_modtime = 0

map(set_module_data, new_modules.values())
self.loaded_modules.update(new_modules)

</t>
<t tx="michael.20060703211129.1">for name, module in self.loaded_modules.iteritems():
    try:
        mod_time = os.stat(module._faces_source_file)[stat.ST_MTIME]
        if mod_time &lt;= module._faces_modtime: continue
    except AttributeError: continue
    except OSError: continue

    try:
        module.faces_gui_cleanup()
    except AttributeError: pass

    try:
        del sys.modules[name]
    except KeyError: pass</t>
<t tx="michael.20060703212350">for f in files.keys():
    try:
        ctrl.add_model(PlanBuffer(f), False)
    except OSError:
        pass</t>
<t tx="michael.20060703212350.1">def get_source_file(module):
    try:
        path = module._faces_source_file
    except AttributeError:
        return ""

    try:
        module._is_source_
        return ""
    except AttributeError:
        pass

    if is_project_file(path, self.main_buffer.path):
        return path

    return ""

files = filter(bool, map(get_source_file, self.loaded_modules.values()))
files = dict(map(lambda f: (f, False), files))</t>
<t tx="michael.20060703233047">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;
_is_source_ = True
@others
</t>
<t tx="michael.20060703233047.1">import wx
import wx.grid
import metapie.navigator as navigator
from metapie.gui import controller
import taskfuncs
import faces.observer
import faces.plocale
import faces.report
import faces.gui.editor.context as context
import matplotlib.colors as colors
import matplotlib.font_manager as font
import weakref
import faces.charting.tools as chart_tools
import metapie.dbtransient as db
import metapie.gui.views as views
import csv
try:
    import Cheetah.Template as CHTemplate
    import webbrowser
    import os.path
    import tempfile
    import faces.utils as utils
    _cheetah_is_installed = True
except ImportError:
    _cheetah_is_installed = False


</t>
<t tx="michael.20060703233047.2">def convert_color(color):
    color = colors.colorConverter.to_rgb(color)
    return map(lambda i: int(i * 255), color)
</t>
<t tx="michael.20060703233047.3">def _report_factory(title, data, model):
    return lambda parent: ReportView(parent, data, model, title)</t>
<t tx="michael.20060703233047.4">
faces.observer.factories["report"] = _report_factory


_ = faces.plocale.get_gettext()


_LEFT = 1
_RIGHT = 2
_TOP = 4
_BOTTOM = 8
_DEFAULT = _RIGHT + _BOTTOM

_align_map = { faces.report.Cell.LEFT : wx.ALIGN_LEFT,
               faces.report.Cell.RIGHT : wx.ALIGN_RIGHT,
               faces.report.Cell.CENTER : wx.ALIGN_CENTER }


class _ErrorReport(faces.report.Report):
	&lt;&lt; class _ErrorReport declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060703233047.5">data = ("Error in Report",)

</t>
<t tx="michael.20060703233047.6">def make_report(self, data):
    for s in data:
        yield faces.report.Cell(s)
</t>
<t tx="michael.20060703233047.7">

class CellRenderer(wx.grid.PyGridCellRenderer):
	@others
</t>
<t tx="michael.20060703233047.8">def __init__(self, report_view):
    wx.grid.PyGridCellRenderer.__init__(self)
    self.default = wx.grid.GridCellStringRenderer()
    self.report_view = report_view
</t>
<t tx="michael.20060703233047.9">def Draw(self, grid, attr, dc, rect, row, col, isSelected):
    self.default.Draw(grid, attr, dc, rect, row, col, isSelected)
    dc.SetPen(wx.BLACK_PEN)

    border_val = getattr(attr, "border_val", _DEFAULT)
    if border_val &amp; _LEFT: 
        dc.DrawLine(rect.left, rect.top, rect.left, rect.bottom + 1)

    if border_val &amp; _TOP: 
        dc.DrawLine(rect.left, rect.top, rect.right + 1, rect.top)

    if border_val &amp; _RIGHT: 
        dc.DrawLine(rect.right, rect.top, rect.right, rect.bottom + 1)

    if border_val &amp; _BOTTOM: 
        dc.DrawLine(rect.left, rect.bottom, rect.right + 1, rect.bottom)
</t>
<t tx="michael.20060703233047.10">def GetBestSize(self, grid, attr, dc, row, col):
    return self.default.GetBestSize(grid, attr, dc, row, col)
</t>
<t tx="michael.20060703233047.11">def Clone(self):
    return CellRenderer(self.report_view)
</t>
<t tx="michael.20060703233047.12">


class ReportView(wx.Panel, navigator.View):
	@others
</t>
<t tx="michael.20060703233047.13">def __init__(self, parent, report, model, title):
    wx.Panel.__init__(self, parent, -1, style=wx.SUNKEN_BORDER)
    self.grid = None
    self.code_info = {}
    self.task_info = {}
    self.model = model
    self.link_view = True
    self.replace_data(report)
    self.make_menu()
</t>
<t tx="michael.20060703233047.14">def make_menu(self, popup=False, task=None):
    def find_in_source():
        self.model.find_in_source(self.report.__class__)

    ctrl = controller()
    if popup:
        report_menu = ctrl.make_menu()
    else:
        top = ctrl.get_top_menu()
        report_menu = top.make_menu(_("&amp;Report"), pos=300)

    menu = lambda *args, **kw: report_menu.make_item(self, *args, **kw)

    if _cheetah_is_installed:
        menu(_("Print Report..."), self.menu_print_report, "print16", pos=100)

    menu(_("Export to CSV..."), self.menu_export_csv, "export16", pos=101)
    if not popup:
        def nav(func):
            def function(): self.navigate(func)
            return function

        menu(_("Move Left\tCTRL-ALT-LEFT"), nav("MoveCursorLeft"), "left16", pos=10)
        menu(_("Move Right\tCTRL-ALT-RIGHT"), nav("MoveCursorRight"),
             "right16", pos=20)
        menu(_("Move Up\tCTRL-ALT-UP"), nav("MoveCursorUp"), "up16", pos=30)
        menu(_("Move Down\tCTRL-ALT-DOWN"), nav("MoveCursorDown"), "down16", pos=40)

    menu = lambda *args, **kw: report_menu.make_item(self, *args, **kw)
    menu(_("Find in Source"), find_in_source, "findsource16", pos=110)
    self.link_menu = menu(_("&amp;Link Report"), self.change_link,
                          check_item=True, pos=120)
    self.link_menu.check(self.link_view)

    if popup and task:
        taskfuncs.make_menu_task_clipboard(ctrl, task, report_menu, 500)
        code_item = task._function.code_item
        action_filter = ("add", "edit", "extra")
        context.CTask(code_item).make_browser_menu(report_menu, action_filter)

    return report_menu
</t>
<t tx="michael.20060703233047.15">def navigate(self, function):
    method = getattr(self.grid, function)
    method(False)
</t>
<t tx="michael.20060703233047.16">def set_grid_notifications(self):
    grid = self.grid
    wx.grid.EVT_GRID_SELECT_CELL(grid, self.OnCellSelect)
    wx.grid.EVT_GRID_CELL_RIGHT_CLICK(grid, self.OnRightDown)
    wx.grid.EVT_GRID_CELL_LEFT_CLICK(grid, self.OnLeftDown)
</t>
<t tx="michael.20060703233047.17">def change_link(self):
    self.link_view = not self.link_view
    self.link_menu.check(self.link_view)
</t>
<t tx="michael.20060703233047.18">def OnLeftDown(self, event):
    event.Skip()
    self.grid.SetFocus()
</t>
<t tx="michael.20060703233047.19">def OnRightDown(self, event):
    top = controller().get_top_menu()

    row = event.GetRow()
    col = event.GetCol()
    task, name = self.code_info.get((row, col), (None, None))
    menu = self.make_menu(True, task)

    self.PopupMenu(menu.wxobj, event.GetPosition())
</t>
<t tx="michael.20060703233047.20">def OnCellSelect(self, event):
    event.Skip()
    row = event.GetRow()
    col = event.GetCol()
    self.grid.MakeCellVisible(row, col)
    self.grid.SelectBlock(row, col, row, col)

    task, name = self.code_info.get((row, col), (None, None))
    if task:
        taskfuncs.make_menu_task_clipboard(controller(), task)
        if self.link_view:
            self.model.show_object(self, task, name)
    else:
        taskfuncs.remove_menu_task_clipboard(controller())
</t>
<t tx="michael.20060703233047.21">def menu_print_report(self):
    path = utils.get_template_path()
    path = os.path.join(path, "printing", "report.tmpl")
    template = CHTemplate.Template(file=path)

    template.report = self.report
    template.Cell = faces.report.Cell
    template.encoding = chart_tools.chart_encoding
    template.compile(file=path)
    template.encode = encode 

    fh, tmpfile = tempfile.mkstemp(".html")
    os.close(fh)
    out = file(tmpfile, "w")
    print &gt;&gt; out, str(template)
    out.close()
    webbrowser.open("file://%s" % tmpfile, True, False)
    controller().session.tmp_files_to_remove.append(tmpfile)

</t>
<t tx="michael.20060703233047.22">def menu_export_csv(self):
    dlg = ExportCSV_Dialog(controller().frame,
                           self.report.__class__.__name__)
    if dlg.ShowModal() == wx.ID_OK:
        exporter = dlg.data.exporter()
        exporter.writerow(map(encode, self.report.headers))
        for row in self.report:
            exporter.writerow(map(encode, row))

    dlg.Destroy()
</t>
<t tx="michael.20060703233047.23">def Destroy(self):
    taskfuncs.remove_menu_task_clipboard(controller())
    wx.Panel.Destroy(self)
</t>
<t tx="michael.20060703233047.24">def show_object(self, task, attrib, caller=None):
    if not self.link_view or not hasattr(task, "_function"): return

    rc = (self.grid.GetGridCursorRow(), self.grid.GetGridCursorCol())
    cursor_task, cursor_attrib = self.code_info.get(rc, (None, None))

    # don't move if the cursor is at the correct position
    if cursor_task == task and (not attrib or cursor_attrib == attrib):
        return

    taskid = task._idendity_()
    rc = self.task_info.get((taskid, attrib),
                            self.task_info.get((taskid, None)))

    if rc: self.set_cursor(*rc)
</t>
<t tx="michael.20060703233047.25">def set_cursor(self, row, col, link=True):
    row = max(0, row)
    col = max(0, col)
    row = min(row, self.grid.GetNumberRows() - 1)
    col = min(col, self.grid.GetNumberCols() - 1)

    link_view = self.link_view
    self.link_view &amp;= link
    self.grid.SetGridCursor(row, col)
    self.grid.MakeCellVisible(row, col)
    self.link_view = link_view
</t>
<t tx="michael.20060703233047.26">def replace_data(self, report):
    if self.grid:
        rc = (self.grid.GetGridCursorRow(), self.grid.GetGridCursorCol())
        self.GetSizer().Remove(self.grid)
        self.grid.Destroy()
    else:
        sizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(sizer)
        rc = (0, 0)

    save_execute = controller().session.save_execute
    self.report = save_execute(report)

    if not self.report: self.report = _ErrorReport()
    save_execute(self.__fill_grid)
    wx.CallAfter(self.set_cursor, rc[0], rc[1], False)
    self.link_view = self.report.link_view
</t>
<t tx="michael.20060703233047.27">def __fill_grid(self):
    self.code_info.clear()
    self.task_info.clear()

    cols = len(self.report.headers)
    col_range = range(cols)

    grid = self.grid = wx.grid.Grid(self, -1)
    grid.SetDefaultRenderer(CellRenderer(weakref.proxy(self)))
    grid.EnableGridLines(wx.VERSION[:2] == (2,4))
    grid.SetRowLabelSize(0)
    grid.CreateGrid(0, cols)

    grid.BeginBatch()
    try:
        r = 0
        for row in self.report:
            grid.AppendRows(1)

            for c in col_range:
                try:
                    val = row[c]
                except IndexError:
                    val = faces.report.Cell("cell not defined")
                    val.back_color = "red"

                try:
                    strval = val.unicode(chart_tools.chart_encoding)
                except AttributeError:
                    if isinstance(val, str):
                        strval = unicode(val, chart_tools.chart_encoding)
                    else:
                        strval = unicode(val)

                grid.SetCellValue(r, c, strval)
                grid.SetReadOnly(r, c)

                ref = val.get_ref()
                self.code_info[(r, c)] = ref[:2]
                if ref[0]:
                    taskid = ref[0]._idendity_()
                    self.task_info[(taskid, ref[1])] = (r, c)
                    last_info = self.task_info.get((taskid, None), (r,9999))
                    self.task_info[(taskid, None)] = min((r, c), last_info)

                align = _align_map.get(val.align, wx.ALIGN_LEFT)
                grid.SetCellAlignment(r, c, align, wx.ALIGN_TOP)

                if val.back_color:
                    back_color = convert_color(val.back_color)
                    grid.SetCellBackgroundColour(\
                        r, c, wx.Colour(*back_color))
                else:
                    grid.SetCellBackgroundColour(\
                        r, c, grid.GetDefaultCellBackgroundColour())

                if val.text_color:
                    text_color = convert_color(val.text_color)
                    grid.SetCellTextColour(r, c, wx.Colour(*text_color))
                else:
                    grid.SetCellTextColour(\
                        r, c, grid.GetDefaultCellTextColour())

                is_bold = val.font_bold
                is_italic = val.font_italic
                is_underline = val.font_underline
                font_size = val.font_size

                font = grid.GetDefaultCellFont()
                if is_bold or is_italic or is_underline or font_size:
                    style = is_italic and wx.ITALIC or font.GetStyle()
                    weight = is_bold and wx.BOLD or font.GetWeight()
                    fsize = self.calc_font_size(font_size)

                    new_font = wx.Font(\
                        fsize, font.GetFamily(), style, weight,\
                        is_underline, font.GetFaceName())

                    grid.SetCellFont(r, c, new_font)
                else:
                    grid.SetCellFont(r, c, font)


                border_val = 0
                if val.left_border: border_val += _LEFT
                if val.top_border: border_val += _TOP
                if val.right_border: border_val += _RIGHT
                if val.bottom_border: border_val += _BOTTOM
                if border_val != _DEFAULT and wx.VERSION[:2] != (2,4):
                    attr = grid.GetOrCreateCellAttr(r, c) #bug in 2.4
                    attr.border_val = border_val

            r += 1

        try:
            for c in col_range:
                grid.SetColLabelValue(c, self.report.headers[c])
        except:
            pass

        grid.AutoSizeColumns()
        grid.AutoSizeRows()
        self.set_grid_notifications()


    finally:
        grid.EndBatch()
        sizer = self.GetSizer()
        sizer.Add(grid, 1, wx.EXPAND)
        sizer.Layout()
</t>
<t tx="michael.20060703233047.28">def calc_font_size(self, font_size):
    grid_font_size = self.grid.GetDefaultCellFont().GetPointSize()
    if not font_size: return grid_font_size

    old_size = font.fontManager.get_default_size()
    font.fontManager.set_default_size(grid_font_size)
    fp = font.FontProperties(size=font_size)
    fsize = fp.get_size_in_points()
    font.fontManager.set_default_size(old_size)
    return fsize
</t>
<t tx="michael.20060703233047.29">def accept_sibling(self, new_view):
    import editor

    if isinstance(new_view, editor.PlanEditorProxy):
        return navigator.SIBLING_BELOW

    if isinstance(new_view, ReportView):
        return navigator.SIBLING_BELOW

    return False
</t>
<t tx="michael.20060703233047.30">class ExportCSV_Model(db.Model):
	&lt;&lt; class ExportCSV_Model declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060703233047.31">filename = db.Text(default="test.csv")
delimiter = db.Text(";")
quotechar = db.Text('"')
quoting = db.Enumerate({ csv.QUOTE_ALL : _("All"),
                         csv.QUOTE_MINIMAL : _("Minimal"),
                         csv.QUOTE_NONNUMERIC : _("Non Numeric"),
                         csv.QUOTE_NONE : _("None") } )
escapechar = db.Text("")

</t>
<t tx="michael.20060703233047.32">def check_constraints(self):
    if not self.filename: 
        error = db.ConstraintError()
        error.message["filename"] = _("A filename must be specified")
        raise error
</t>
<t tx="michael.20060703233047.33">def exporter(self):
    return csv.writer(file(self.filename, "w"),
                      delimiter=str(self.delimiter),
                      quoting=self.quoting,
                      quotechar=str(self.quotechar),
                      escapechar=str(self.escapechar) or None,
                      lineterminator="\n")
</t>
<t tx="michael.20060703233047.34">class ExportCSV_View(views.FormView):
    __model__ = ExportCSV_Model
    __view_name__ = "default"
    format = _("""
[File: ]      |filename(SaveFile)&gt;
[Delimiter: ] |delimiter
[Quoting:]    |quoting
[Quote Char:] |quotechar
[Escape Char:]|escapechar
(0,0)
--
(buttons)&gt;
""")

    format_buttons = "btn_ok{r}|(0,5)|btn_cancel"

	@others
</t>
<t tx="michael.20060703233047.36">def prepare(self):
    self.grow_col(1)
    self.grow_row(-3)
    self.buttons.grow_col(0)
    self.filename.set_filter(_("CSV (*.csv)|*.csv"))
    self.delimiter.set_width("8")
    self.delimiter.SetMaxLength(1)
    self.quotechar.set_width("8")
    self.quotechar.SetMaxLength(1)
    self.escapechar.set_width("8")
    self.escapechar.SetMaxLength(1)
</t>
<t tx="michael.20060703233047.37">def constitute(self, imodel):
    views.FormView.constitute(self, imodel)
    self.state_changed("quoting")
</t>
<t tx="michael.20060703233047.38">def state_changed(self, attrib):
    if attrib == "quoting":
        has_escape = self.imodel.quoting == csv.QUOTE_NONE
        self.quotechar.Enable(not has_escape)
        self.escapechar.Enable(has_escape)
</t>
<t tx="michael.20060703233047.39">def button_cancel(self):
    self.rollback()
    self.GetParent().GetParent().EndModal(wx.ID_CANCEL)
</t>
<t tx="michael.20060703233047.40">def button_ok(self):
    if self.save():
        self.GetParent().GetParent().EndModal(wx.ID_OK)
</t>
<t tx="michael.20060703233047.41">class ExportCSV_Dialog(wx.Dialog):
	@others
</t>
<t tx="michael.20060703233047.42">def __init__(self, parent, name):
    wx.Dialog.__init__(self, parent, -1, _("Export CSV"),
                       style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
    self.name = name
</t>
<t tx="michael.20060703233047.43">def ShowModal(self):
    container = views.ScrollViewContainer(self)
    self.data = ExportCSV_Model(filename=self.name + ".csv")
    self.data.constitute("default")(container)
    container.fit_size()
    self.SetClientSize(container.GetSize())
    result = wx.Dialog.ShowModal(self)
    return result

</t>
<t tx="michael.20060703235036">def _parse_evaluation(self, text):
    pos = text.index("=")
    if 0 &lt;= text.find("#") &lt; pos:
        return False

    self._type = EVALUATION
    self._name = text[:pos].strip()
    self._header = False
    return True

</t>
<t tx="michael.20060703235036.2">text = event.GetText()
if text.find("=") &gt;= 0 or not text.strip():
    self.context.make_button(self.context_button, 
                             self.get_expression(line))</t>
<t tx="michael.20060703235036.3">self.check_context(line)
self.context.make_button(self.context_button, 
                         self.get_expression(line))
self.move_context_button()</t>
<t tx="michael.20060703235820">def is_project_name(n):
    try:
        return n[0] != "_" and issubclass(getattr(ftask, n), ftask._ProjectBase)
    except TypeError:
        return False

project_names = tuple([name for name in dir(ftask) if is_project_name(name)])

del is_project_name




</t>
<t tx="michael.20060703235853">def update_code_info(self, module=None):
    session = controller().session
    path = self.model.path

    for varname, eval in session.evaluations.iteritems():
        &lt;&lt; assign tasks to code_items &gt;&gt;

    &lt;&lt; assign observers and resources to code_items &gt;&gt;
    &lt;&lt; assign evaluations to code_items &gt;&gt;
</t>
<t tx="michael.20060703235912">def sync_text(self, reset_savepoint=False):
    try:
        self.model.text = self.GetText().encode(self.model.get_encoding())
    except AttributeError:
        pass
    else:
        if self.model.text[-1] != "\n":
            self.model.text += "\n"

    if reset_savepoint:
        self.SetSavePoint()
        self.check_modified()
</t>
<t tx="michael.20060704001124">def check_modified(self):
    frame = controller().frame
    try:
        if self.GetModify():
            self.model.modified(True)
            frame.SetStatusText("C", 1)
        else:
            frame.SetStatusText("", 1)
            self.model.modified(False)
    except AttributeError:
        pass
</t>
<t tx="michael.20060704001124.1">pos = self.GetCurrentPos()
line = self.GetFirstVisibleLine()
offset = self.GetXOffset()</t>
<t tx="michael.20060704001124.2">self.SetUndoCollection(0)
self.SetText(unicode(model.text, model.get_encoding(), "replace"))
self.SetSavePoint()
self.SetUndoCollection(1)</t>
<t tx="michael.20060704001124.3">self.setup_eol()
self.SetCodePage(wx.stc.STC_CP_UTF8)
self.__change_count = 0
self.check_modified()</t>
<t tx="michael.20060704001124.4">if self.__last_module_id != id(module):
    self.browse_code()
    if module: 
        self.update_code_info(module)
        self.show_call_tips = getattr(module, "faces_show_call_tips", True)
        self.dimmer_color = getattr(module, "faces_dimmer_color", "#f0aeb8")
        self.task_completions = getattr(module, "faces_task_completions", None)

    self.check_context(self.GetCurrentLine())
    self.GetParent().browser.refresh()
    self.__last_module_id = id(module)


self.setup_style()
</t>
<t tx="michael.20060704001124.6">self.GotoPos(pos)
self.LineScroll(0, line - self.GetFirstVisibleLine())
self.SetXOffset(offset)
self.check_context(self.LineFromPosition(pos))
</t>
<t tx="michael.20060704001244">def show_object(self, search_object, attrib=None, caller=None):
    if hasattr(search_object, "_function"):
        return self.show_task(search_object, attrib, caller)

    for c in self.code_items:
        if getattr(c, "obj", None) is search_object:
            line = c.get_line()
            self.LineScroll(0, line - self.GetFirstVisibleLine())
            start = self.PositionFromLine(line)
            end = self.GetLineEndPosition(line)
            pos = self.FindText(start, end, "class", 0)
            self.GotoPos(pos + 4)
            self.WordPartRight()
            return True

    return False
</t>
<t tx="michael.20060704001500">def show_task(self, search_task, attrib=None, caller=None):
    obj = None
    item = None

    def context_result(found_item, found_attrib=False):
        if attrib is not None: return found_item, found_attrib
        return found_item

    for item in self.code_items:
        obj = getattr(item, "obj", None)
        if isinstance(obj, ftask.Task):
            if obj._function.func_code is search_task._function.func_code:
                break
    else:
        return context_result(False)

    item_line = item.get_line()

    def goto_declaration():
        start = self.PositionFromLine(item_line)
        end = self.GetLineEndPosition(item_line)
        pos = self.FindText(start, end, "def", 0)
        self.GotoPos(pos + 3)
        self.WordPartRight()
        return context_result(True)

    self.LineScroll(0, item_line - self.GetFirstVisibleLine())
    if not attrib:
        return goto_declaration()

    line = min(item.get_last_line(), self.next_item_line(item_line + 1))
    start = self.GetLineEndPosition(line)
    end = self.GetLineEndPosition(item_line)
    pos = self.FindText(start, end, attrib, 0)
    if pos &lt; 0:
        return goto_declaration()

    end = start
    start = pos + len(attrib)

    line_end = self.GetLineEndPosition(self.LineFromPosition(start))
    if self.FindText(start, end, "=") &lt; 0:
        # attribs have always a = behind
        return goto_declaration()

    scenario = search_task.root.scenario
    tpos = self.FindText(start, end, scenario, 0)
    if tpos &gt;= 0: start = tpos + len(scenario)

    org_val = search_task._original_values.get(attrib, "") or \
              getattr(search_task, attrib, "")

    try:
        org_val = org_val.decode(self.model.get_encoding())
    except AttributeError:
        org_val = str(org_val)

    if org_val:
        tpos = self.FindText(start, end, org_val, 0)
        if tpos &gt; 0:
            self.GotoPos(tpos)
            self.SetSelectionEnd(tpos + len(org_val))
            return True, True

    self.GotoPos(pos)
    return True, False
</t>
<t tx="michael.20060704020852">def eval_expression(self, expression, globvars={}, context=None):
    locdict = { }
    context = context or self.context

    if globvars:
        globdict = self.get_module().__dict__.copy()
        globdict.update(globvars)
    else:
        globdict = self.get_module().__dict__

    while True:
        try:
            exec expression in globdict, locdict
            return locdict
        except NameError, e:
            name = str(e).split("'")[1]
            obj = context.find_object(name)
            if obj is None:
                obj = self.guess_object(name, context=context)

            if obj is None or globdict.has_key(name):
                # may be a python bug but "globdict.has_key(name)" can happen!
                raise

            globdict[name] = obj

</t>
<t tx="michael.20060704235642">class PlanEditorProxy(wx.PyPanel, View):
    @others
</t>
<t tx="michael.20060705002353">def __init__(self, model, parent):
    wx.PyPanel.__init__(self, parent)

    self.model = weakref.ref(model)
    editor = model.editor
    editor.show(self)

    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(editor, 1, wx.EXPAND)
    self.SetSizer(sizer)

    &lt;&lt; redirect methods &gt;&gt;
</t>
<t tx="michael.20060705002353.1">def Destroy(self):
    editor = self.GetChildren()[0]
    self.GetSizer().Detach(editor)
    editor.hide()
    wx.PyPanel.Destroy(self)
</t>
<t tx="michael.20060705003619"></t>
<t tx="michael.20060705003619.1"></t>
<t tx="michael.20060705003619.2"></t>
<t tx="michael.20060705004026"></t>
<t tx="michael.20060705004026.1"></t>
<t tx="michael.20060705004026.2"></t>
<t tx="michael.20060705004818">path = self.get_backup_file()
if self.consider_backup and os.access(path, os.F_OK):
    result = wx.MessageBox(_('A backup copy of "%s" exists.\n'
                             'Should I use it?') % self.path,
                           _("Backup exists"),
                           style=wx.YES_NO|wx.ICON_QUESTION)
    if result == wx.NO:
        path = self.path
else:
    path = self.path

</t>
<t tx="michael.20060705013905">self.show_object = editor.show_object
self.sync_text = editor.sync_text
self.refresh = editor.refresh
self.goto_line = editor.goto_line
self.find_in_source = editor.find_in_source
self.SetFocus = editor.editor.SetFocus
self.on_make_menu = editor.browser.on_make_menu
self.find_resource_references = editor.find_resource_references
self.find_task_references = editor.find_task_references</t>
<t tx="michael.20060705164052">def show(self, parent):
    self.Reparent(parent)

    view_menu = controller().view_menu
    self.browser_menu = view_menu.make_item(parent,
                                            _("&amp;Project Browser\tF9"),
                                            self.toggle_browser,
                                            pos=8000,
                                            check_item=True)
    view_menu.make_separator(_("&amp;Project Browser\tF9"), True)
    self.browser_menu.check(False)

    if self.browser.IsShown():
        wx.CallAfter(self.toggle_browser, True)
</t>
<t tx="michael.20060705164052.1">def hide(self):
    if self.browser.IsShown():
        self.browser.open_width = self.browser.GetSize()[0]

    self.browser_menu = None
    self.Reparent(controller().hidden_parent)

</t>
<t tx="michael.20060707121238">class DimmerStyler(object):
    dimmer_color = "#f0aeb8"
    _marker_number = 1

    @others
</t>
<t tx="michael.20060707125319">def StyleSetSpec(self, style_index, spec):
    if style_index != wx.stc.STC_STYLE_LINENUMBER: 
        spec += ",back:%s" % self.dimmer_color

    super(DimmerStyler, self).StyleSetSpec(style_index, spec)
</t>
<t tx="michael.20060707130205">def highlite(self, start_line=0, end_line=0):
    end_line = end_line or self.GetLineCount() - 1

    self.__start_pos = self.PositionFromLine(start_line)
    self.__end_pos = self.GetLineEndPosition(end_line)
    self.__last_style_end = 0

    self.Freeze()

    MarkerAdd = self.MarkerAdd
    marker_number = self._marker_number
    self.MarkerDeleteAll(marker_number)
    for i in range(start_line, end_line + 1):
        MarkerAdd(i, marker_number)

    self.Thaw()
</t>
<t tx="michael.20060707181914">def __init__(self):
    self.__start_pos = self.__end_pos = 0
    self.MarkerDefine(self._marker_number, 
                      wx.stc.STC_MARK_BACKGROUND, 
                      "white", "white")
</t>
<t tx="michael.20060708104315">try:
    self.highlite(item.get_line(), item.get_last_line())
except AttributeError:
    self.highlite()</t>
<t tx="michael.20060713212925">self._raise(RecursionError("A child defines a "\
                           "recursive definition at %s" % self.path))
</t>
<t tx="michael.20060717214039">@language python
&lt;&lt; Copyright &gt;&gt;
"""
    faces project management in python

    @var LEFT:
    The left border position of a graphical widget.

    @var RIGHT:
    The right border position of a graphical widget.

    @var TOP:
    The top border position of a graphical widget.

    @var BOTTOM:
    The bottom border position of a graphical widget.

    @var VCENTER:
    The vertical center position of a graphical widget.

    @var HCENTER:
    The horizontal center position of a graphical widget.

    @var VSEP:
    Specifies the vertical space equivalent to 1/4 of the height of
    the character 'I'.

    @var HSEP:
    Specifies the horizontal space equivalent to 1/4 of the height of
    the character 'I'.

    @var FACTOR:
    Specifies the height of a graphical widget in units of VSEP.

"""

__version__ = "0.11.7"

from pcalendar import Calendar, WorkingDate, StartDate, EndDate, Minutes

from task import Project, BalancedProject, AdjustedProject, Task, \
    STRICT, SLOPPY, SMART, Multi, YearlyMax, WeeklyMax, MonthlyMax, \
    DailyMax, VariableLoad

from resource import Resource
from operators import intersect, unify, difference
from charting.tools import VSEP, HSEP, LEFT, RIGHT, BOTTOM, \
     TOP, VCENTER, HCENTER, FACTOR, \
     set_default_size as set_default_chart_font_size,\
     set_encoding as set_chart_encoding, \
     chart_encoding

from charting.patches import Arrow, Circle, Polygon, RegularPolygon, \
     Shadow, Wedge, Rectangle

from charting.taxis import alt_week_locator

gui_controller = None

__all__ = ("Arrow", "Circle", "Polygon", "RegularPolygon", \
           "Shadow", "Wedge", "Rectangle", \
           "VSEP", "HSEP", "LEFT", "RIGHT", "BOTTOM", \
           "TOP", "VCENTER", "HCENTER", "FACTOR", \
           "set_default_chart_font_size",\
           "set_chart_encoding", "chart_encoding", "Resource",
           "Project", "BalancedProject", "AdjustedProject", "Task", \
           "STRICT", "SLOPPY", "SMART", "Multi", \
           "YearlyMax", "WeeklyMax", "MonthlyMax", "DailyMax", \
           "intersect", "unify", "difference", "Calendar", "gui_controller",
           "WorkingDate", "StartDate", "EndDate", "Minutes", "VariableLoad",
           "alt_week_locator")


_is_source = True
_DEBUGGING = True
_PROFILING = False
</t>
<t tx="michael.20060718000534">def union(*calendars):
    """ 
    returns a calendar that unifies all working times 
    """
    &lt;&lt; check arguments &gt;&gt;
    &lt;&lt; intersect vacations &gt;&gt;
    &lt;&lt; unify extra worktime &gt;&gt;
    &lt;&lt; unify working times &gt;&gt;
    &lt;&lt; create result calendar &gt;&gt;
    return result</t>
<t tx="michael.20060718001417">if len(calendars) == 1:
    calendars = calendars[0]</t>
<t tx="michael.20060718001417.1">free_time = []
for c in calendars:
    for start, end, is_free in c.time_spans:
        if is_free:
            free_time.append((start, False))
            free_time.append((end, True))

count = len(calendars)
open = 0
time_spans = []
free_time.sort()
for date, is_end in free_time:
    if is_end:
        if open == count:
            time_spans.append((start, date, True))
        open -= 1
    else: 
        open += 1
        start = date
</t>
<t tx="michael.20060718001417.2">for c in calendars:
    for start, end, is_free in c.time_spans:
        if not is_free:
            time_spans = _add_to_time_spans(time_spans, start, end)</t>
<t tx="michael.20060718005323">working_times = {}
for d in range(0, 7):
    times = []
    for c in calendars:
        for start, end in c.working_times.get(d, []):
            times.append((start, False))
            times.append((end, True))

    times.sort()
    open = 0
    ti = []
    start = None
    for time, is_end in times:
        if not is_end:
            if not start: start = time
            open += 1
        else:
            open -= 1
            if not open:
                ti.append((start, time))
                start = None

    if ti: 
        working_times[d] = ti
</t>
<t tx="michael.20060718005402">result = Calendar()
result.working_times = working_times
result.time_spans = time_spans
result._recalc_working_time()
result._build_mapping()</t>
<t tx="michael.20060720224306">"""
This class represents a single task in the project tree. A task
can have other child tasks, or is a leaf of the tree. Resources
will be allocated only to leafes. You will never create task
objects by your self, they are created indirectly by Projects.

@var root:
Returns the root project task.

@var up:
Returns the parent task.

@var title:
Specifies an alternative more descriptive name for the task.

@var start:
The start date of the task. Valid values are expressions and
strings specifing a datatime

@var end:
The end date of the task. Valid values are expressions and
strings.

@var effort:
Specifies the effort needed to complete the task. Valid values
are expressions and strings. (Todo: What happens, in case of 
specified performance data...)


@var length:
Specifies the time the task occupies the resources.  This is
working time, not calendar time. 7d means 7 working days, not one
week. Whether a day is considered a working day or not depends on
the defined working hours and global vacations.

@var duration:
Specifies the time the task occupies the resources. This is
calendar time, not working time. 7d means one week.

@var buffer:
Specifies the time a task can be delayed, without moving dependend
milestones. A Task with a buffer S{&lt;=} 0d is part of the critical
chain.  This attribute is readonly.

@var complete:
Specifies what percentage of the task is already completed.

@var todo:
Specifies the effort, which needs to be done to complete a
task. This is another (indirect) way to specify the ME{complete}
attribute.

@var done:
Specifies the work effort, which has been already done. This
attribute is readonly.

@var estimated_effort:
Specifies the estimated_effort given by setting the effort property.

@var performed:
Specifies a list of actual working times performed on the task.
The format is: C{[ (resource, from, to, time), ... ]}

@var performed_work_time:
Specifies the sum of all working times. This attribute is
readonly.

@var performed_effort:
Specifies the complete effort of all working times. This attribute is
readonly.

@var performed_start:
The start date of the performed data.

@var performed_end:
The end date of the performed data.

@var performed_resource:
The resources who have already performed on the task. This attribute is readonly.


@var balance:
Specifies the resource allocation type. Possible values are
CO{STRICT}, CO{SLOPPY}, CO{SMART}.

@var resource:
Specifies the possible resources, that may be allocated for the
task.

@var booked_resource:
Specifies the allocated resources of a task. This attribute is
readonly.

@var load:
Specifies the daily load of a resource for an allocation of the
specified task. A load of 1.0 (default) means the resource is
allocated for as many hours as specified by
ME{working_hours_per_day}. A load of 0.5 means half that many
hours.

@var max_load:
Specify the maximal allowed load sum of all simultaneously
allocated tasks of a resource. A ME{max_load} of 1.0 (default)
means the resource may be fully allocated. A ME{max_load} of 1.3
means the resource may be allocated with 30% overtime.

@var efficiency:
The efficiency of a resource can be used for two purposes. First
you can use it as a crude way to model a team. A team of 5 people
should have an efficiency of 5.0. Keep in mind that you cannot
track the member of the team individually if you use this
feature. The other use is to model performance variations between
your resources.

@var milestone:
Specified if the task is a milestone. The possible values are
C{True} or "later". If the start date of the milestone is not
a valid working date, the milestone will appear at the previous
working date before the given start date. If "later" is specified
the milestone will appear at the next valid working date.
A milestone has always an effort of 0d.

@var priority:
Specifies a priority between 1 and 1000. A task with higher
priority is more likely to get the requested resources.  The
default priority is 500.

@var children:
Specifies a list of all subtasks. A task without children is
called a leaf task index{leaf task} otherwise it is called a
parent task index{parent task}. This attribute is readonly.

@var depth:
Specifies the depth of the task within the hierachy. This
attribute is readonly.

@var index:
Specifies a structural index number. This attribute is readonly.

@var path:
Specifies the path.

@var copy_src:
Specifies the path to an other task.  When you set this attribute,
all attributes (except of ME{start} and ME{end}) of copy_src will
be copied to the current task. This is usefull if you want to
define the same task, in diffent project definitions. It acts like
a task link.

@var scenario:
The scenario which is currently evaluated. This attribute is readonly.

@var dont_inherit:
A list of attribute names, which will be not inherited by
subtasks.

@var calendar:
Specifies the task calendar.    

@var working_days_per_week:
Specifies the days within a working week. This value is used
internally to convert time differences from weeks to days. The
default value is 5 days.

@var working_days_per_month:
Specifies the days within a working month. This value is used
internally to convert time differences from months to days. The
default value is 20 days.

@var working_days_per_year:
Specifies the days within a working year. This value is used
internally to convert time differences from years to days The
default value is 200 days.

@var working_hours_per_day:
Specifies the hours within a working day. This value is used
internally to convert time differences from are entered in days to
hours.  The default value is 8 hours.

@var minimum_time_unit:
Specifies the minimum resolution in minutes for the task
scheduling. The default value is 15 minutes.

@var vacation:
Specifies a public vacation for the calendar. This attribute is
specified as a list of date literals or date literal intervals. Be
aware that the end of an interval is excluded, i.e. it is the
first working date.

@var extra_work:
Specifies additional worktime. This attribute is specified as a
list of date literals or date literal intervals. Be aware that the
end of an interval is excluded, i.e. it is the first working date.

@var working_days:
Specifies the weekly working time within calendar. The format of
this attribute is: [ (day_range, time_range, ...), (day_range, time_range, ...), ... ].
day_range is a comma sperated string of week days. Valid values
are mon, tue, wed, thu, fri, sat, sun.
time_range is string specifing a time interval like
8:00-10:00. You can specified any number of time_ranges, following
the first.

@var now:
Specifies the current daytime and is a date literal. ME{now} is
used to calculate several task attributes.

"""</t>
<t tx="michael.20060724135631">def _set_calendar(self, value):
    self.calendar = value
    self._to_delta = value.Minutes
    self._to_start = value.StartDate
    self._to_end = value.EndDate
    self.__renew_dates()

</t>
<t tx="michael.20060724142145">def __or__(self, other):
    if isinstance(other, Calendar):
        return union(self, other)

    return NotImplemented</t>
<t tx="michael.20060724150058"></t>
<t tx="michael.20060724153604">def clone(self):
    result = Calendar()
    result.working_times = self.working_times.copy()
    result.time_spans = self.time_spans
    result._recalc_working_time()
    result._build_mapping()
    return result</t>
<t tx="michael.20060724164954">def __make_calendar(self):
    if not "calendar" in self.__dict__:
        cal = self.calendar = self.calendar.clone()
        self._to_delta = cal.Minutes
        self._to_start = cal.StartDate
        self._to_end = cal.EndDate</t>
<t tx="michael.20060724204442">def get_calendar_completions(self, obj=None):
    return map(lambda r: (r, r), self.model.calendars.keys())</t>
<t tx="michael.20060724204736">if isinstance(v, _faces.Calendar):
    calendars.setdefault(path, {})[k] = v
    continue</t>
<t tx="michael.20060726163212">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A collection of classes and functions for editing attributes
"""
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others</t>
<t tx="michael.20060726163212.1">import wx
import context
import re
import sys
import operator
import faces.plocale
import faces.pcalendar as pcalendar
import faces.task as ftask
import faces.charting
import metapie.dbtransient as db
import metapie.gui.views as views
import metapie.gui.grid as grid
import metapie.gui.widgets as widgets
import metapie.gui.pyeditor as pyeditor
import inspect
import textwrap
import classifiers
import datetime
from metapie.gui import controller
import editorlib
try:
    set
except NameError:
    from sets import Set as set
</t>
<t tx="michael.20060726163359"></t>
<t tx="michael.20060726163359.1"></t>
<t tx="michael.20060726163359.2">class Delta(db.Model):
    days = db.Float(width=5, precision=1)
    hours = db.Float(width=4, precision=1) 
    minutes = db.Int()
    is_duration = False

    @others
</t>
<t tx="michael.20060726163359.3">def __init__(self, code_item, attrib, value):
    super(Delta, self).__init__()
    try:
        self.to_delta = code_item.obj._to_delta
    except AttributeError:
        self.to_delta = pcalendar.Minutes

    &lt;&lt; find best value &gt;&gt;
    self.minutes = (value.seconds / 60) % 60
    self.hours = value.seconds / 3600
    self.days = value.days</t>
<t tx="michael.20060726163359.4">try:
    value = self.to_delta(value).to_timedelta(self.is_duration)
except ValueError:
    try:
        value = getattr(code_item.obj, attrib).to_timedelta(self.is_duration)
    except AttributeError:
        value = datetime.timedelta()</t>
<t tx="michael.20060726163359.5">def __str__(self):
    td = datetime.timedelta(days=self.__days, 
                            hours=self.__hours, 
                            minutes=self.__minutes)
    return '"%s"' % self.to_delta(td, self.is_duration)\
                        .strftime(is_duration=self.is_duration)</t>
<t tx="michael.20060726163359.6">class Duration(Delta):
    is_duration = True</t>
<t tx="michael.20060726163359.7">class DeltaView(views.FormView):
    __model__ = Delta
    __view_name__ = "default"
    vgap = 0

    format = _("""
days|[Days ]|hours|[Hours ]|minutes|[Minutes]
""")</t>
<t tx="michael.20060726163359.8"></t>
<t tx="michael.20060726163359.9">class Date(db.Model):
    value = db.DateTime()

    @others</t>
<t tx="michael.20060726163359.10">def __init__(self, code_item, attrib, value):
    super(Date, self).__init__()

    to_date = pcalendar.to_datetime

    try:
        value = to_date(value)
    except ValueError:
        &lt;&lt; try alternatives &gt;&gt;
    except TypeError:
        &lt;&lt; try alternatives &gt;&gt;

    self.value = value</t>
<t tx="michael.20060726163359.11">def __str__(self):
    return '"%s"' % self.__value.strftime("%x %H:%M")
</t>
<t tx="michael.20060726163359.12">class DateView(views.FormView):
    __model__ = Date
    __view_name__ = "default"
    vgap = 0
    format = "value"</t>
<t tx="michael.20060726163359.13"></t>
<t tx="michael.20060726163359.14">class String(db.Model):
    value = db.Text()

    @others</t>
<t tx="michael.20060726163359.15">def __init__(self, code_item, attrib, value):
    super(String, self).__init__()
    self.value = value</t>
<t tx="michael.20060726163359.16">def __str__(self):
    return '"%s"' % self.value
</t>
<t tx="michael.20060726163359.17">class StringView(views.FormView):
    __model__ = String
    __view_name__ = "default"
    vgap = 0
    format = "value&gt;"

    def prepare(self):
        self.grow_col(0)
</t>
<t tx="michael.20060726163359.33"></t>
<t tx="michael.20060726163359.34">class MultiText(db.Model):
    value = db.Text(multi_line=True)

    @others</t>
<t tx="michael.20060726163359.35">def __init__(self, code_item, attrib, value):
    super(MultiText, self).__init__()
    self.value = textwrap.dedent(value or "").strip("\n").decode("utf8")</t>
<t tx="michael.20060726163359.36">def __str__(self):
    return '"""\n%s\n"""' % self.__value</t>
<t tx="michael.20060726163359.37">class MultiTextView(views.FormView):
    __model__ = MultiText
    __view_name__ = "default"
    vgap = 0
    format = "value&gt;"

    @others</t>
<t tx="michael.20060726163359.38">def prepare(self):
    self.grow_col(0)
    self.grow_row(0)
    self.value.set_width("X" * 50)
    self.value.set_height(20)</t>
<t tx="michael.20060726163359.39"></t>
<t tx="michael.20060726163359.40">class DateTimeRange(db.Model):
    start = db.DateTime(format="HHMM")
    end = db.DateTime(format="HHMM")

    @others</t>
<t tx="michael.20060726163359.41">def __init__(self, **kwargs):
    super(DateTimeRange, self).__init__(**kwargs)
    if not kwargs.has_key("start"):
        self.start = datetime.datetime.now()</t>
<t tx="michael.20060726163359.42">def _set_start(self, value):
    self.end = value.replace(hour=0, minute=0) \
               + datetime.timedelta(days=1)
    return value</t>
<t tx="michael.20060726163359.43">def __str__(self):
    return '("%s", "%s")' \
            % (self.start.strftime("%x %H:%M"), 
               self.end.strftime("%x %H:%M"))</t>
<t tx="michael.20060726163359.44">class DateTimeRanges(db.Model):
    @others

db.Relation("tr",
            db.End(DateTimeRange, "ranges", multi='*'),
            db.End(DateTimeRanges))</t>
<t tx="michael.20060726163359.45">def __init__(self, code_item, attrib, value):
    super(DateTimeRanges, self).__init__()
    to_datetime = pcalendar.to_datetime
    for start, end in value or ():
        self.ranges.insert(DateTimeRange(start=to_datetime(start), 
                                         end=to_datetime(end)))</t>
<t tx="michael.20060726163359.46">def __str__(self):
    ranges = map(str, self.ranges)
    return "[%s]" % ",\n".join(ranges)</t>
<t tx="michael.20060726163359.47">class DateTimeRangeGrid(grid.EditGrid, views.GridView):
    __model__ = DateTimeRange
    columns = ((__model__.start, _("From")),
               (__model__.end, _("To")))
    resize_col = 0


class DateTimeRangesView(views.FormView):
    __model__ = DateTimeRanges
    __view_name__ = "default"
    vgap = 0
    format = """
ranges&gt;
delete
"""

    @others</t>
<t tx="michael.20060726163359.48">def create_controls(self):
    self.ranges = self.get_control("ranges(DateTimeRangeGrid)")
    self.delete = self.ranges.get_delete_button(self)</t>
<t tx="michael.20060726163359.49">def prepare(self):
    self.grow_col(0)
    self.grow_row(0)</t>
<t tx="michael.20060726164252">try:
    value = to_date(getattr(code_item.obj, attrib))
except AttributeError:
    value = datetime.datetime.now()</t>
<t tx="michael.20060727133714"></t>
<t tx="michael.20060727171038"></t>
<t tx="michael.20060727171038.1">class ScenarioAttributeEditor(AttributeEditor):
    @others
</t>
<t tx="michael.20060727171038.4">def activate(self, context):
    """
    activates the editor.
    """
    imodel = ScenarioContainer(self.edit_model, context, self.attrib_name, 
                               self.evaluator, self.default)
    imodel.show()


</t>
<t tx="michael.20060727171134">tok_identifier = r"([a-zA-Z_][a-zA-Z0-9_]*)"
tok_path = r"(ident(\.ident)*)".replace("ident", tok_identifier)
tok_assignment = r"^(path)\s*=".replace("path", tok_path)
tok_identifier_assignment = r"%s\s*(?P&lt;project&gt;%s)\(" % (tok_assignment, tok_identifier)

reg_assignment = re.compile(tok_assignment)
reg_identifier_assignment = re.compile(tok_identifier_assignment)
reg_identifier = re.compile(tok_identifier + "$")
reg_path = re.compile(tok_path + "$")
</t>
<t tx="michael.20060727171307.1">class Evaluator(object):
    def __init__(self, expression, context):
        try:
            editor = context.code_item.editor
            self.attributes = editor.eval_expression(expression, context=context)
        except Exception, e:
            self.error = e




</t>
<t tx="michael.20060727171438">class AttributeEditor(context.ItemEditor):
    evaluator = Evaluator

    @others</t>
<t tx="michael.20060727171438.1">def __init__(self, attrib_name, edit_model, default=None):
    self.attrib_name = attrib_name
    self.edit_model = edit_model
    self.default = default</t>
<t tx="michael.20060727171438.2">def apply(self, expression, code_item):
    if not expression: return True

    mo = reg_assignment.search(expression)
    if not mo: return False

    path = mo.group(1).split(".")
    return path[-1] == self.attrib_name

</t>
<t tx="michael.20060727171438.3">def activate(self, context):
    """
    activates the editor.
    """
    imodel = SimpleContainer(self.edit_model, context, self.attrib_name, 
                             self.evaluator, self.default)
    imodel.show()
    return imodel
</t>
<t tx="michael.20060727171523"></t>
<t tx="michael.20060727171523.1">class ScenarioContainer(db.Model):
    child = db.Model.type(readonly=True)
    error = db.Text()
    @others</t>
<t tx="michael.20060727171523.2">def __init__(self, child_model, context, attrib_name, evaluator, default):
    self.child_model = child_model
    self.code_item = code_item = context.code_item
    self.attrib_name = attrib_name
    self.scenarios = ["_default"]

    &lt;&lt; calculate attribute value &gt;&gt;

    child_model = lambda v: self.child_model(self.code_item, 
                                             self.attrib_name, 
                                             v)
    if not isinstance(value, dict):
        self.child__default = child_model(value)
        self.scenarios = ["_default"]
        self.default = value
    else:
        self.scenarios = []

        if "_default" not in value:
            value["_default"] = value.values()[0]

        self.default = value["_default"]

        for k, v in value.iteritems():
            setattr(self, "child_%s" % k, child_model(v))
            self.scenarios.append(k)

</t>
<t tx="michael.20060727171523.5">def remove_scenario(self, name):
    if name == "_default": return None

    try:    
        self.scenarios.remove(name)
    except ValueError:
        return False

    child = getattr(self, "child_%s" % name)
    delattr(self, "child_%s" % name)
    return child</t>
<t tx="michael.20060727171523.6">def show(self):
    #no wizzard while processing
    if controller().is_processing(): return

    dlg = editorlib.PatchedDialog(controller().frame,  -1, 
            _("Edit %s") % self.attrib_name,
            style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)

    dlg.SetClientSize((10, 10))
    view = self.constitute()(dlg)
    view.layout()
    dlg.simulate_modal(self.code_item.editor)</t>
<t tx="michael.20060727171523.7">def code(self):
    default = self.child__default
    scenarios = list(self.scenarios)
    scenarios.remove("_default")

    if scenarios:
        first = "%s = Multi(%s" % (self.attrib_name, unicode(default))
        others = map(lambda s: '%s=%s' % (s, unicode(getattr(self, "child_%s" % s))), scenarios)
        others.insert(0, first)
        max_len = sum(map(len, others)) + len(others) * 2 + self.code_item.indent + 4
        joiner = max_len &gt; 80 and ",\n" or ", "
        return "%s)" % joiner.join(others)
    else:
        return "%s = %s" % (self.attrib_name, unicode(default))</t>
<t tx="michael.20060727171523.8">def realize(self):
    root = get_code_root(self.code_item)
    try:
        root.all_scenarios.update(self.scenarios)
    except AttributeError:
        root.all_scenarios = set(self.scenarios)

    editor = self.code_item.editor
    attribs = editor.get_attribs(self.code_item)
    if self.attrib_name in attribs:
        editor.replace_expression(self.code(), attribs[self.attrib_name])
    else:
        editor.insert_expression(self.code_item, self.code())
</t>
<t tx="michael.20060727171523.10">class ScenarioView(editorlib.MainView):
    __model__ = ScenarioContainer
    __view_name__ = "default"
    vgap = 0


    format = _("""
error(Static)
lbl_error
new|(0,3)|remove
(0,3)&gt;
--&gt;
notebook(Page_default[_default])&gt;
(0,3)&gt;
--&gt;
(0,3)
(buttons)&gt;
""")


    @others</t>
<t tx="michael.20060727171523.11">def create_controls(self):
    self.new = self.get_button(_("Add Scenario"))
    self.remove = self.get_button(_("Remove Scenario"))

    def new_scenario():
        simodel = NewScenario(self.imodel)
        simodel.show(self)

    self.new.attach(new_scenario)
    self.remove.attach(self.remove_scenario)


</t>
<t tx="michael.20060727171523.12">def prepare(self):
    self.grow_col(-1)
    self.grow_row(5)
    self.buttons.grow_col(0)
    self.error.Hide()
    self.error.SetForegroundColour(self.error_colour)
    self.notebook.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, 
                       lambda e: self.update_remove_button())
    self.update_remove_button()

def update_remove_button(self):
    if self.remove:
        self.remove.Enable(self.notebook.GetSelection() != 0)
</t>
<t tx="michael.20060727171523.13">def constitute(self, imodel):
    super(ScenarioView, self).constitute(imodel)
    for s in self.imodel.scenarios:
        if s != "_default":
            page = self.create_subform(self.notebook, "Page%s" % s)
            page.inspect(self.imodel, s)
            self.notebook.AddPage(page, s)

    if imodel.error: self.error.Show()
    self.update_remove_button()</t>
<t tx="michael.20060727171523.14">def update_scenarios(self):
    self.scenario.Clear()
    map(self.scenario.Append, self.imodel.get_scenarios())
</t>
<t tx="michael.20060727171740">def get_code_root(code_item):
    item = code_item
    while item:
        last = item
        item = item.get_parent()

    return last</t>
<t tx="michael.20060727172857"></t>
<t tx="michael.20060727172857.1">class SimpleContainer(db.Model):
    attrib_name = db.Text()
    child = db.Model.type()
    error = db.Text()
    @others</t>
<t tx="michael.20060727172857.2">def __init__(self, child_model, context, attrib_name, evaluator, default):
    self.attrib_name = attrib_name
    self.code_item = code_item = context.code_item
    &lt;&lt; calculate attribute value &gt;&gt;
    self.child = child_model(code_item, attrib_name, value)

</t>
<t tx="michael.20060727172857.6">def show(self):
    #no wizzard while processing
    if controller().is_processing(): return

    dlg = editorlib.PatchedDialog(controller().frame,  -1, 
            _("Edit %s") % self.attrib_name,
            style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)

    dlg.SetClientSize((10, 10))
    view = self.constitute()(dlg)
    view.layout()
    dlg.simulate_modal(self.code_item.editor)</t>
<t tx="michael.20060727172857.7">def code(self):
    return "%s = %s" % (self.attrib_name, unicode(self.child))</t>
<t tx="michael.20060727172857.8">def realize(self):
    editor = self.code_item.editor
    attribs = editor.get_attribs(self.code_item)
    if self.attrib_name in attribs:
        editor.replace_expression(self.code(), attribs[self.attrib_name])
    else:
        editor.insert_expression(self.code_item, self.code())
</t>
<t tx="michael.20060727172857.10">class SimpleView(editorlib.MainView):
    __model__ = SimpleContainer
    __view_name__ = "default"
    vgap = 0

    format = _("""
error(Static)
lbl_error
child&gt;
(0,3)&gt;
--&gt;
(0,3)
(buttons)&gt;
""")

    @others</t>
<t tx="michael.20060727172857.12">def prepare(self):
    self.grow_col(-1)
    self.grow_row(2)
    self.buttons.grow_col(0)
    self.error.Hide()
    self.error.SetForegroundColour(self.error_colour)</t>
<t tx="michael.20060727172857.13">def constitute(self, imodel):
    super(SimpleView, self).constitute(imodel)
    if imodel.error: self.error.Show()
</t>
<t tx="michael.20060727174303">class AttributeEditor(AttributeEditor):
    evaluator = TaskEvaluator
</t>
<t tx="michael.20060727174639">attribs = code_item.editor.get_attribs(self.code_item)
if self.attrib_name in attribs:
    line = attribs[self.attrib_name]
    expression = code_item.editor.get_expression(line)
else:
    expression = ""

evaluation = evaluator(expression, context)
try:
    self.error = "%s: %s" % (evaluation.error.__class__.__name__, \
                             str(evaluation.error))
    value = default
except AttributeError:
    if expression:
        value = evaluation.attributes.get(attrib_name) 
    else:
        value = default

</t>
<t tx="michael.20060727180105.1"></t>
<t tx="michael.20060727180230"></t>
<t tx="michael.20060727180230.1">class Float(db.Model):
    value = db.Float()

    @others</t>
<t tx="michael.20060727180230.2">def __init__(self, code_item, attrib, value):
    super(Float, self).__init__()
    self.value = float(value or 0.0)</t>
<t tx="michael.20060727180230.3">def __str__(self):
    return '%.02f' % self.__value
</t>
<t tx="michael.20060727180230.4">class FloatView(views.FormView):
    __model__ = Float
    __view_name__ = "default"
    vgap = 0
    format = "value"</t>
<t tx="michael.20060727180601"></t>
<t tx="michael.20060727180601.1">class Boolean(db.Model):
    value = db.Boolean()

    @others</t>
<t tx="michael.20060727180601.2">def __init__(self, code_item, attrib, value):
    super(Boolean, self).__init__()
    self.value = bool(value)

</t>
<t tx="michael.20060727180601.3">def __str__(self):
    return self.__value and "True" or "False"
</t>
<t tx="michael.20060727180601.4">class BooleanView(views.FormView):
    __model__ = Boolean
    __view_name__ = "default"
    vgap = 0
    format = "value(BoolEnum)"

</t>
<t tx="michael.20060728142041"></t>
<t tx="michael.20060728142041.1">class Int(db.Model):
    value = db.Int()

    @others</t>
<t tx="michael.20060728142041.2">def __init__(self, code_item, attrib, value):
    super(Int, self).__init__()
    self.value = int(value or 0)</t>
<t tx="michael.20060728142041.3">def __str__(self):
    return '%i' % self.__value
</t>
<t tx="michael.20060728142041.4">class IntView(views.FormView):
    __model__ = Int
    __view_name__ = "default"
    vgap = 0
    format = "value"</t>
<t tx="michael.20060728153537"></t>
<t tx="michael.20060728153537.1">class ResourceNames(db.Enumerate):
    def __init__(self):
        super(ResourceNames, self).__init__({"" : ""})


    def fill(self, model):
        encoding = model.get_encoding()
        self.choices.clear()

        for d, r in model.resources.iteritems():
            if r.name != "Resource":
                self.choices[d] = r.title.decode(encoding)


</t>
<t tx="michael.20060728153749">def weekdays():
    dt = faces.pcalendar.Calendar.EPOCH
    return dict(map(lambda d: (d - 1, dt.replace(day=d).strftime("%A")),
                    range(1, 8)))


class WorkingTime(db.Model):
    day = db.Enumerate(weekdays())
    start = db.Time(format="HHMM")
    end = db.Time(format="HHMM")</t>
<t tx="michael.20060728153749.1">class WorkingTimes(db.Model):
    @others

db.Relation("workingtime",
            db.End(WorkingTime, "workingtimes", multi='*'),
            db.End(WorkingTimes))</t>
<t tx="michael.20060728153749.2">def __init__(self, code_item, attrib, value):
    super(WorkingTimes, self).__init__()

    cal = pcalendar.Calendar()
    for item in value or ():
        cal.set_working_days(*item)

    default = pcalendar.DEFAULT_WORKING_DAYS
    for d in range(0, 7):
        slots = cal.working_times.get(d, default[d])
        for start, end in slots:
            start = datetime.time(start / 60, start % 60)
            end = datetime.time(end / 60, end % 60)
            self.workingtimes.insert(\
                WorkingTime(day = d, start=start, end=end))</t>
<t tx="michael.20060728153749.3">def __str__(self):
    day_names = ("mon",  "tue", "wed", "thu", "fri", "sat", "sun")
    day_times = {}
    for t in self.workingtimes:
        start, end = t.start.strftime("%H:%M"), t.end.strftime("%H:%M")
        day_times.setdefault(t.day, []).append('"%s-%s"' % (start, end))

    tr = []
    def make_day(day):
        try:
            return '("%s", %s)' % (day_names[day], 
                                   ", ".join(day_times[day]))
        except KeyError:
            return '("%s", ())' % day_names[day]

    tr = map(make_day, range(0, 7))
    return '[%s]' % ",\n".join(tr)</t>
<t tx="michael.20060728153749.4">class WorkingTimesView(views.FormView):
    __model__ = WorkingTimes
    __view_name__ = "default"
    vgap = 0
    format = """
workingtimes&gt;
delete
"""
    def create_controls(self):
        self.workingtimes = self.get_control("workingtimes(WorkingTimeGrid)")
        self.delete = self.workingtimes.get_delete_button(self)

    def prepare(self):
        self.grow_col(0)
        self.grow_row(0)</t>
<t tx="michael.20060728153749.5">class WorkingTimeGrid(grid.EditGrid, views.GridView):
    __model__ = WorkingTime
    columns = ((__model__.day, _("Day")),
               (__model__.start, _("From")),
               (__model__.end, _("To")))
    resize_col = 0</t>
<t tx="michael.20060728153909"></t>
<t tx="michael.20060729171506">def create_editor_menu(menu, context, editors):
    #editors is a pair consisting of ("path", attrib_editor)
    &lt;&lt; define improve_duplicate_names &gt;&gt;
    &lt;&lt; define make_groups &gt;&gt;
    &lt;&lt; define create_menu &gt;&gt;
    editors = make_groups(editors)
    create_menu(menu, editors)
    if editors:
        menu.make_separator(tuple(menu)[-1].title)

</t>
<t tx="michael.20060801124835">def improve_duplicate_names(editors):
    if len(editors[0][0].split("/")) &lt; 2: 
        #path has no group
        return editors

    counts = { }
    for path, editor in editors:
        name = path.split("/")[-1]
        counts[name] = counts.get(name, 0) + 1

    result = []    
    for path, editor in editors:
        path = path.split("/")
        name = path[-1]
        if counts[name] &gt; 1:
            group = path[-2]
            result.append(("%s (%s)" % (name, group), editor))
        else:
            result.append((name, editor))

    return result</t>
<t tx="michael.20060801124835.1">def make_groups(editors):
    """
    If there are more than 10 editors arange them in groups
    """
    if len(editors) &lt;= 10:
        return improve_duplicate_names(editors)

    groups = {}
    for name, ie in editors:
        path = name.split("/")
        gl = groups.setdefault(path[0], [])
        gl.append(("/".join(path[1:]), ie))

    for g, e in groups.iteritems():
        if len(g.split("/")) &gt; 1:
            groups[g] = make_groups(e)

    return groups.items()</t>
<t tx="michael.20060801124835.2">def make_call(item_editor):
    def call(): item_editor.activate(context)
    return call


def create_menu(parent_menu, editors):
    editors.sort()
    was_list = False
    for name, ie in editors:
        path = name.split("/")
        menu_title = path[0]
        menu_pos = -1

        &lt;&lt; extract menu position from title &gt;&gt;

        if isinstance(ie, list):
            create_menu(parent_menu.make_menu(menu_title, pos=menu_pos), ie)
            if not was_list: parent_menu.make_separator(menu_title, True)
            was_list = True
        else:
            parent_menu.make_temp_item(menu_title, make_call(ie), pos=menu_pos,
                                       bitmap=getattr(ie, "__icon__", None))
            was_list = False
</t>
<t tx="michael.20060804041654">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A collection of functions for editing tasks and their attributes
"""
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others</t>
<t tx="michael.20060804041820">registry = context.CResource.editors
std_attributes = _("Standard/%s")

registry[std_attributes % "title..."] = AttributeEditor("title", String, _("Title"))
registry[std_attributes % "max_load..."] = AttributeEditor("max_load", Float, 1.0)
registry[std_attributes % "vacation..."] = AttributeEditor("vacation", DateTimeRanges)
registry[std_attributes % "efficiency..."] = AttributeEditor("efficiency", Float, 1.0)
registry[std_attributes % "Create Resource...(1000)"] = ResourceCreator()
registry[std_attributes % "Rename...(1010)"] = ResourceRenamer()
registry[std_attributes % "Remove...(1020)"] = ResourceRemover()
registry[std_attributes % "Show References...(1900)"] = ReferencePrinter()
del std_attributes

</t>
<t tx="michael.20060804041905">import sys
import faces.plocale
from attribedit import *
import editorlib
try:
    set
except NameError:
    from sets import Set as set</t>
<t tx="michael.20060804044438">@language python
&lt;&lt; Copyright &gt;&gt;
"""
A collection of functions for editing tasks and their attributes
"""
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others</t>
<t tx="michael.20060804044438.1">############################################################################
#   Copyright (C) 2005, 2006 by Reithinger GmbH
#   mreithinger@web.de
#
#   This file is part of faces.
#                                                                         
#   faces is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   faces is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the
#   Free Software Foundation, Inc.,
#   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
############################################################################

</t>
<t tx="michael.20060804044438.2">import sys
import inspect
import faces.plocale
import faces.task as ftask
import faces.observer as fobserver
import matplotlib.font_manager as fm
import metapie.gui.pyeditor as pyeditor
import docparser
from metapie.gui.controller import ResourceManager
from attribedit import *
import editorlib
try:
    set
except NameError:
    from sets import Set as set</t>
<t tx="michael.20060804044506"></t>
<t tx="michael.20060804044506.1">class AttributeEditor(AttributeEditor):
    evaluator = ObserverEvaluator
    @others
</t>
<t tx="michael.20060804120410"></t>
<t tx="michael.20060804121345">def register_editors(cls, registry):
    super(MatplotChart, cls).register_editors(registry)
    registry.Boolean(_("Shape/show_tips..."))
    registry.Boolean(_("Chart/scroll_bars..."))
    registry.Property(_("Chart/properties..."), cls.create_property_groups)

register_editors = classmethod(register_editors)

def create_property_groups(cls, property):
    property.set_default_groups()

create_property_groups = classmethod(create_property_groups)</t>
<t tx="michael.20060804132135">def register_editors(cls, registry):
    super(TimeWidgetChart, cls).register_editors(registry)
    registry.String(_("Chart/sharex..."), "time_share")
    registry.Boolean(_("Chart/show_rowlines..."), False)
    registry.Boolean(_("Chart/auto_scale_y..."), True)


register_editors = classmethod(register_editors)</t>
<t tx="michael.20060804133122">def register_editors(cls, registry):
    #"time_axis_properties" : 'time_axis_properties = { | }',
    super(TimeAxisChart, cls).register_editors(registry)
    registry.Boolean(_("Axis/show_grid..."), True)
    registry.Boolean(_("Axis/show_scale..."), True)
    registry.Boolean(_("Axis/show_free_time..."), True)
    registry.Boolean(_("Axis/show_now..."), True)
    registry.Property(_("Axis/time_axis_properties..."), cls.create_time_axis_property_groups)

register_editors = classmethod(register_editors)

def create_time_axis_property_groups(cls, property):
    property.fill_gc_group("")
    property.fill_font_group("")
    property.fill_gc_group("now")
    property.fill_gc_group("grid")
    property.fill_font_group("0")
    property.name_groups.append("0.facecolor")
    property.name_groups.append("tickers")
    property.name_groups.append("facecolor")
    property.name_groups.append("free.facecolor")
    for t in range(3):
        property.fill_font_group(str(t))
        property.name_groups.append("%s.facecolor" % str(t))


create_time_axis_property_groups = classmethod(create_time_axis_property_groups)</t>
<t tx="michael.20060804140428"></t>
<t tx="michael.20060804140428.1"></t>
<t tx="michael.20060804140428.2">class MultiEvaluation(db.Model):
    """
    An editor for a combination of a modules project data
    """
    operator = db.Enumerate({"unify" : _("Unify"),
                             "intersect" : _("Intersect"),
                             "difference" : _("Difference") },
                            default="unify")
    
    @others
    
db.Relation("evals",
            db.End(Evaluation, "evals", multi='*'),
            db.End(MultiEvaluation))</t>
<t tx="michael.20060804140428.3">def __init__(self, code_item, attrib, value):
    super(MultiEvaluation, self).__init__()
    Evaluation.__attributes_map__["value"].fill(code_item.editor.model)
    
    if isinstance(value, tuple):
        try:
            self.operator = value[0]
        except db.ConstraintError:
            pass
        else:
            for ed in value[1]:
                self.evals.insert(Evaluation(code_item=code_item, value=ed))
    elif isinstance(value, ftask._ProjectBase):
        self.evals.insert(Evaluation(code_item=code_item, value=value))
        
    
</t>
<t tx="michael.20060804140428.7">def __str__(self):
    evals = map(str, self.evals)
    if len(evals) &gt; 1:
        return "%s(%s)" % (self.operator, ", ".join(evals))
    
    if evals:
        return evals[0]
        
    return "()"
</t>
<t tx="michael.20060804140428.8">class MultiEvaluationView(views.FormView):
    __model__ = MultiEvaluation
    __view_name__ = "default"
    vgap = 0
    format = _("""
[Operator:]
operator
(0,3)
[Evaluations:]
evals&gt;
(0,3)
delete
""")

    @others
</t>
<t tx="michael.20060804140428.9">def create_controls(self):
    self.evals = self.get_control("evals(EvaluationGrid)")
    self.delete = self.evals.get_delete_button(self)</t>
<t tx="michael.20060804140428.10">def prepare(self):
    self.grow_col(0)
    self.grow_row(3)</t>
<t tx="michael.20060804140428.12">class Evaluation(db.Model):
    value = EvaluationNames()
    
    @others
    </t>
<t tx="michael.20060804140428.13">def __str__(self):
    return self.value
</t>
<t tx="michael.20060804140428.15">class EvaluationGrid(grid.EditGrid, views.GridView):
    __model__ = Evaluation
    columns = (("value", _("Name")),)
    resize_col = 0


</t>
<t tx="michael.20060804141028">class EvaluationNames(db.Enumerate):
    def __init__(self):
        super(EvaluationNames, self).__init__({"" : ""})


    def fill(self, model):
        self.choices.clear()

        for k, v in model.evaluations.iteritems():
            self.choices[k] = k
</t>
<t tx="michael.20060804143857">class Resource(db.Model):
    name = ResourceNames()
    load = db.Float(precision=2, default=1.0)
    efficiency = db.Float(precision=2, default=1.0)

    def __init__(self, resource=None):
        super(Resource, self).__init__()
        if resource is None:
            self.load = 1.0
            self.efficiency = 1.0
            self.name = self.__attributes_map__["name"].default()
        else:
            self.name = resource.name
            self.load = getattr(resource, "load", 1.0)
            self.efficiency = resource.efficiency


    def __str__(self):
        src = self.parent.model.resources[self.name]

        args = []
        if self.load != 1.0:
            args.append("load=%.02f" % self.load)

        if self.efficiency != src.efficiency:
            args.append("efficiency=%.02f" % self.efficiency)

        if args: return "%s(%s)" % (self.name, ", ".join(args))
        return self.name</t>
<t tx="michael.20060804143857.1">class ResourceSet(db.Model):
    @others

db.Relation("resources",
            db.End(Resource, "resources", multi='*'),
            db.End(ResourceSet, "parent", multi=1))</t>
<t tx="michael.20060804143857.2">class ResourceSetView(views.FormView):
    __model__ = ResourceSet
    __view_name__ = "default"
    vgap = 0
    format = """
resources&gt;
delete
"""
    def create_controls(self):
        self.resources = self.get_control("resources(ResourceGrid)")
        self.delete = self.resources.get_delete_button(self)

    def prepare(self):
        self.grow_col(0)
        self.grow_row(0)</t>
<t tx="michael.20060804143857.3">class ResourceGrid(grid.EditGrid, views.GridView):
    __model__ = Resource
    columns = ((__model__.name, _("Resource")),
               (__model__.load, _("Load")),
               (__model__.efficiency, _("Efficiency")))
    resize_col = 0</t>
<t tx="michael.20060804145158"></t>
<t tx="michael.20060804145403">class EvaluationView(views.FormView):
    __model__ = Evaluation
    __view_name__ = "default"
    vgap = 0
    format = "value"</t>
<t tx="michael.20060804145710">def __init__(self, code_item=None, attrib=None, value=None):
    super(Evaluation, self).__init__()

    eval_type = Evaluation.__attributes_map__["value"]
    if attrib:
        eval_type.fill(code_item.editor.model)
        
    if value:
        model = code_item.editor.model
        for name, data in model.evaluations.iteritems():
            if value is data:
                self.value = name
                break
    else:
        self.value = eval_type.choices.keys()[0]

</t>
<t tx="michael.20060804151253">class ObserverEvaluator(object):
    def __init__(self, expression, context):
        vars = { "unify" : lambda *args: ("unify", args),
                 "intersect" : lambda *args: ("intersect", args),
                 "difference" : lambda *args: ("difference", args), }
        try:
            editor = context.code_item.editor
            self.attributes = editor.eval_expression(expression, vars, context)
        except Exception, e:
            self.error = e
                        
        

        
        </t>
<t tx="michael.20060804152844">def register_editors(cls, registry):
    super(TableChart, cls).register_editors(registry)
    registry.Boolean(_("Chart/show_rowlines..."), False)
    registry.Boolean(_("Chart/show_collines..."), False)


register_editors = classmethod(register_editors)</t>
<t tx="michael.20060804153528">def register_editors(cls, registry):
    super(Gantt, cls).register_editors(registry)
    registry.Boolean(_("Shape/show_resource..."), True)
    registry.Boolean(_("Chart/show_connectors..."), True)
    registry.Boolean(_("Shape/show_complete..."), True)
    registry.String(_("Chart/row_attrib..."), "gantt_same_row")
    registry.String(_("Chart/accumulate_attrib..."), "gantt_accumulate")
    registry.String(_("Chart/shape_attrib..."), "gantt_shape")
    registry.String(_("Chart/shape_properties_attrib..."), "gantt_properties")
    registry.Shape(_("Shape/parent_shape..."), "brace")
    registry.Symbol(_("Shape/milestone_shape..."), "diamond")
    registry.Shape(_("Shape/leaf_shape..."), "bar")
    registry.String(_("Shape/title_attrib..."), "title")

register_editors = classmethod(register_editors)

def create_property_groups(cls, property):
    property.set_default_groups()
    property.name_groups.append("bar.height")
    property.name_groups.append("complete.height")
    property.name_groups.append("magnification")
    property.name_groups.append("up")

    def add_group(group):
        property.fill_font_group(group)

        shape = getattr(cls, group + "_shape", "")
        if shape.find("_bar_") &gt; 0:
            property.name_groups.append(group + ".bar.height")
            property.name_groups.append(group + ".complete.height")
            property.name_groups.append(group + ".start.magnification")
            property.name_groups.append(group + ".end.magnification")
            property.name_groups.append(group + ".start.up")
            property.name_groups.append(group + ".end.up")
            property.fill_patch_group(group + ".complete")
            property.fill_patch_group(group + ".bar")
            property.fill_patch_group(group + ".start")
            property.fill_patch_group(group + ".end")
        else:
            property.fill_patch_group(group)

        if shape == "bar":
            property.fill_patch_group(group + ".complete")
            property.fill_font_group(group + ".inside")

        elif shape in faces.charting.shapes.symbols:
            property.name_groups.append(group + ".magnification")

    add_group("parent")
    add_group("leaf")
    add_group("milestone")



create_property_groups = classmethod(create_property_groups)</t>
<t tx="michael.20060804154017">def register_editors(cls, registry):
    super(Compare, cls).register_editors(registry)
    registry.ColorSet(_("Shape/colors..."), ("navy", "seagreen", "indianred"))
    registry.MultiEvaluation(_("Chart/data..."))


register_editors = classmethod(register_editors)
</t>
<t tx="michael.20060804154418"></t>
<t tx="michael.20060804154418.1"></t>
<t tx="michael.20060804154418.2">class Standard(Gantt):
    __doc__ = _("""
      A Standard gantt chart.
      """)

    @others
</t>
<t tx="michael.20060804154609">def register_editors(cls, registry):
    super(Standard, cls).register_editors(registry)
    registry.Evaluation(_("Chart/data..."))


register_editors = classmethod(register_editors)
</t>
<t tx="michael.20060804155401"></t>
<t tx="michael.20060804160034">def __init__(self, code_item, attrib, value):
    super(ResourceSet, self).__init__()
    self.model = code_item.editor.model
    Resource.__attributes_map__["name"].fill(self.model)

    for r in value and value()._get_resources(0) or ():
        self.resources.insert(Resource(r))</t>
<t tx="michael.20060804160034.1">def __str__(self):
    return " &amp; ".join(map(str, self.resources))</t>
<t tx="michael.20060804160034.2">def check_constraints(self):
    error = db.ConstraintError()

    res = { }
    for r in self.resources:
        if r.name in res:
            error.message["resources"] = \
                  _("Resource '%s' is specified twice.") \
                  % r.name
            break

        res[r.name] = True

    if error.message:
        raise error</t>
<t tx="michael.20060804161145">class Color(db.Model):
    value = db.Text()

    def __str__(self):
        return '"%s"' % self.value

</t>
<t tx="michael.20060804161145.1">class ColorGrid(grid.EditGrid, views.GridView):
    __model__ = Color
    columns = (("value(Color)", _("Value")),)
    resize_col = 0</t>
<t tx="michael.20060804161145.2">class ColorSet(db.Model):
    def __init__(self, code_item, attrib, value):
        super(ColorSet, self).__init__()
        for c in value or ():
            self.colors.insert(Color(value=c))


    def __str__(self):
        return "[%s]" % ", ".join(map(str, self.colors))


db.Relation("colors",
            db.End(Color, "colors", multi='*'),
            db.End(ColorSet))</t>
<t tx="michael.20060804161145.3">class ColorSetView(views.FormView):
    __model__ = ColorSet
    __view_name__ = "default"
    vgap = 0
    format = """
colors&gt;
delete
"""
    def create_controls(self):
        self.colors = self.get_control("colors(ColorGrid)")
        self.delete = self.colors.get_delete_button(self)

    def prepare(self):
        self.grow_col(0)
        self.grow_row(0)</t>
<t tx="michael.20060804162848"></t>
<t tx="michael.20060804162848.1">class ColorLimit(db.Model):
    limit = db.Text()
    color = db.Text()

    def check_constraints(self):
        error = db.ConstraintError()
        try:
            faces.pcalendar.to_timedelta(self.limit)
        except ValueError, e:
            error.message["limit"] = str(e)
            raise error


    def __str__(self):
        return '"%s" : "%s"' % (self.limit, self.color)
</t>
<t tx="michael.20060804162848.2">class ColorLimitGrid(grid.EditGrid, views.GridView):
    __model__ = ColorLimit
    columns = (("limit", _("&lt; Limit")),
               ("color(Color)", _("Color")))
    resize_col = 0
</t>
<t tx="michael.20060804162848.3">class ColorMap(db.Model):
    def __init__(self, code_item, attrib, value):
        super(ColorMap, self).__init__()
        for limit, color in value.iteritems() or ():
            self.colors.insert(ColorLimit(limit=limit, color=color))


    def __str__(self):
        return "{%s}" % ",\n".join(map(str, self.colors))


db.Relation("colors",
            db.End(ColorLimit, "colors", multi='*'),
            db.End(ColorMap))</t>
<t tx="michael.20060804162848.4">class ColorMapView(views.FormView):
    __model__ = ColorMap
    __view_name__ = "default"
    vgap = 0
    format = """
colors&gt;
delete
"""
    def create_controls(self):
        self.colors = self.get_control("colors(ColorGrid)")
        self.delete = self.colors.get_delete_button(self)

    def prepare(self):
        self.grow_col(0)
        self.grow_row(0)</t>
<t tx="michael.20060804163807">def register_editors(cls, registry):
    super(Critical, cls).register_editors(registry)
    registry.ColorMap(_("Shape/colors..."), { "0d" : "red" })


register_editors = classmethod(register_editors)
</t>
<t tx="michael.20060804165131"></t>
<t tx="michael.20060804165454">class Symbol(String): pass
class SymbolView(StringView):
    __model__ = Symbol
    __view_name__ = "default"
    format = "value(SymbolCombo)&gt;"

</t>
<t tx="michael.20060804171822">class Shape(String): pass
class ShapeView(StringView):
    __model__ = Shape
    __view_name__ = "default"
    format = "value(ShapeCombo)&gt;"

</t>
<t tx="michael.20060804172453">class PropertyEditor(AttributeEditor):
    @others
</t>
<t tx="michael.20060804172453.3">def activate(self, context):
    """
    activates the editor.
    """
    imodel = super(PropertyEditor, self).activate(context)
    Property.init_groups()
    self.create_property_groups(Property)
    Property.apply_groups()
    return imodel
    
        
</t>
<t tx="michael.20060804180304">class SymbolCombo(widgets.Combo):
    def __init__(self, *args, **kwargs):
        widgets.Combo.__init__(self, *args, **kwargs)
        map(self.Append, faces.charting.shapes.symbols)</t>
<t tx="michael.20060804180304.1">class ShapeCombo(widgets.Combo):
    def __init__(self, *args, **kwargs):
        widgets.Combo.__init__(self, *args, **kwargs)

        symbols = faces.charting.shapes.symbols
        shapes = ["%s_bar_%s" % (i, j) for i in symbols for j in symbols]
        shapes.append("bar")
        shapes.append("brace")
        shapes.sort()
        map(self.Append, shapes)</t>
<t tx="michael.20060804180304.2">class BoolEnum(widgets.Enumerate):
    __type__ = db.Boolean

    def get_choices(self, itype):
        return { False : _("False"), True : _("True") }

</t>
<t tx="michael.20060804180304.3"></t>
<t tx="michael.20060804183602"></t>
<t tx="michael.20060804183602.1">class BoolEnum(BoolEnum):
    __type__ = db.Text</t>
<t tx="michael.20060804183602.2">class FamilyCombo(widgets.Combo):
    def __init__(self, *args, **kwargs):
        widgets.Combo.__init__(self, *args, **kwargs)
        names = fm.fontManager.ttfdict.keys()
        names.sort()
        map(self.Append, names)</t>
<t tx="michael.20060804183602.3">class WeightCombo(widgets.Combo):
    def __init__(self, *args, **kwargs):
        widgets.Combo.__init__(self, *args, **kwargs)
        choices = map(lambda kv: (kv[1], kv[0]), fm.weight_dict.items())
        choices.sort()
        map(self.Append, map(lambda vk: vk[1], choices))</t>
<t tx="michael.20060804183602.4">class SizeCombo(widgets.Combo):
    def __init__(self, *args, **kwargs):
        widgets.Combo.__init__(self, *args, **kwargs)
        choices = map(lambda kv: (kv[1], kv[0]), fm.font_scalings.items())
        choices.sort()
        map(self.Append, map(lambda vk: vk[1], choices))</t>
<t tx="michael.20060804183602.5">class VariantEnum(widgets.Enumerate):
    __type__ = db.Text
    
    def get_choices(self, itype):
        return { "capitals" : "capitals",
                 "small-caps" : "small-caps",
                 "normal" : "normal" }</t>
<t tx="michael.20060804183602.6">class LinestyleEnum(widgets.Enumerate):
    __type__ = db.Text
    
    def get_choices(self, itype):
        return { "solid" : "solid",
                 "dashed" : "dashed",
                 "dashdot": "dashdot",
                 "dotted" : "dotted" }</t>
<t tx="michael.20060804183602.7">class JoinstyleEnum(widgets.Enumerate):
    __type__ = db.Text
    
    def get_choices(self, itype):
        return { "miter" : "miter",
                 "round" : "round",
                 "bevel" : "bevel" }</t>
<t tx="michael.20060804183602.8">class StyleEnum(widgets.Enumerate):
    __type__ = db.Text
    
    def get_choices(self, itype):
        return { "italics" : "italics",
                 "oblique" : "oblique",
                 "normal" : "normal" }</t>
<t tx="michael.20060804183602.9">class Property(db.Model):
    name_groups = []
    name = db.Text()
    value = db.Text()

    @others
    def check_constraints(self):
        error = db.ConstraintError()
        try:
            faces.charting.widgets.check_property(self.name, self.value)
        except ValueError, e:
            error = db.ConstraintError()
            error.message["value"] = str(e)
            raise error


    def _set_name(self, name):
        if self.value:
            try:
                faces.charting.widgets.check_property(name, self.value)
                return name
            except ValueError:
                pass

        self.__name = name
        if name.endswith("color"):
            self.value = "white"
        elif name.endswith("fill"):
            self.value = "True"
        elif name.endswith("width"):
            self.value = 1.0
        elif name.endswith("alpha"):
            self.value = 1.0
        elif name.endswith("height"):
            self.value = 4.0
        elif name.endswith("magnification"):
            self.value = 1.0
        elif name.endswith("family"):
            self.value = "sans-serif"
        elif name.endswith("weight"):
            self.value = "normal"
        elif name.endswith("size"):
            self.value = "medium"
        elif name.endswith("variant"):
            self.value = "normal"
        elif name.endswith("antialiased"):
            self.value = "True"
        elif name.endswith("up"):
            self.value = "True"
        elif name.endswith("linestyle"):
            self.value = "solid"
        elif name.endswith("joinstyle"):
            self.value = "miter"
        elif name.endswith("style"):
            self.value = "normal"
        elif name == "tickers":
            self.value = "1, 2"

        return name

    def _set_value(self, val):
        def name_is(*options):
            for o in options:
                if self.name.endswith(o): return True
            return False
        
        if name_is("width", "alpha", "magnification", "height"):
            try:
                val = float(val)
            except ValueError:
                val = 0.0
        elif name_is("fill", "antialiased", "up"):
            if str(val).upper() == "FALSE": val = False
            else: val = bool(val)
        elif name_is("size", "weight"):
            val = str(val)
        elif self.name == "tickers":
            val = str(val).replace("(", "").replace(")", "")
            val = tuple(map(int, val.split(",")))

        return val
    

    def __str__(self):
        def to_float(val):
            try:
                return "%.1f" % float(val)
            except ValueError:
                return "0.0"
            
        def to_string(val): return '"%s"' % val
        def to_int(val):
            try:
                return "%i" % int(val)
            except ValueError:
                return "0"

        def name_is(*options):
            for o in options:
                if self.name.endswith(o): return True
            return False
            
        formater = to_string
        if name_is("width", "alpha", "magnification", "height"):
            formater = to_float
        elif name_is("fill", "antialiased", "up"):
            formater = to_int
        elif self.name == "tickers":
            def formater(val):
                return "(%s, )" % ", ".join(map(str, val))
        elif name_is("size", "weight"):
            try:
                int(self.value)
                formater = to_int
            except ValueError:
                pass

        return '"%s" : %s' % (self.name, formater(self.value))


    def init_groups(cls):
        cls.name_groups = []

    init_groups = classmethod(init_groups)
    
    def fill_gc_group(cls, group):
        styles = ("edgecolor", "linewidth", "linestyle",
                  "antialiased", "alpha", "joinstyle" )

        if group: group += "."
        cls.name_groups.extend(map(lambda s: group + s, styles))


    fill_gc_group = classmethod(fill_gc_group)
                          
    def fill_patch_group(cls, group):
        styles = faces.charting.widgets._PropertyAware.patch_attribs
        cls.name_groups.extend(map(lambda s: group + "." + s, styles))

    fill_patch_group = classmethod(fill_patch_group)


    def fill_font_group(cls, group):
        styles = faces.charting.widgets._PropertyAware.font_attribs
        if group: group += "."
        cls.name_groups.extend(map(lambda s: group + s, styles))
        cls.name_groups.append(group + "color") 

    fill_font_group = classmethod(fill_font_group)


    def apply_groups(cls):
        singulized = dict(zip(cls.name_groups, [0]*len(cls.name_groups)))
        cls.name_groups = singulized.keys()
        cls.name_groups.sort()

    apply_groups = classmethod(apply_groups)
        

    def set_default_groups(cls):
        cls.fill_gc_group("")
        cls.fill_font_group("")
        cls.name_groups.append("fill")
        cls.name_groups.append("facecolor")
        cls.name_groups.append("background.facecolor")
        cls.fill_patch_group("marker")
        cls.fill_patch_group("focused.marker")

    set_default_groups = classmethod(set_default_groups)</t>
<t tx="michael.20060814190211">if length is not None:
    length = to_delta(max(length - (task.start - base_start), 0))</t>
<t tx="michael.20060814190211.1">if duration is not None:
    delta = task.start.to_datetime() - base_start.to_datetime()
    delta = to_delta(delta, True)
    duration = to_delta(max(duration - delta, 0), True)</t>
<t tx="michael.20060814190211.2">if end is not None:
    length = end - start
    if length &lt;= 0: return False</t>
<t tx="michael.20060814190211.3">if effort is not None:
    effort -= task.performed_effort
    effort = to_delta(max(effort, 0))
    if effort &lt;= 0: return False

    if length is not None:
        #if length and effort is set, the load will be calculated
        length = length or task.calendar.minimum_time_unit
        loads = self._distribute_len_loads(task, resource,
                                           effort, length)
        def calc_load(res):
            return loads[res]
    else:
        #the length depends on the count of resources
        factor = sum(map(lambda a: a[0].efficiency * a[1],
                         loads)) * task.efficiency
        length = effort / factor</t>
<t tx="michael.20060814190211.4">if length is not None:
    adjust_date = lambda date: date
    delta = to_delta(length).round()
else:
    assert(duration is not None)
    adjust_date = _to_datetime
    delta = datetime.timedelta(minutes=duration)</t>
<t tx="michael.20060817115302">class NewScenario(db.Model):
    scenario = db.Text("_default")

    @others</t>
<t tx="michael.20060817115302.1">class NewScenarioView(editorlib.MainView):
    __model__ = NewScenario
    __view_name__ = "default"
    format = (""" 
[Scenario: ]|scenario(Combo)
--&gt;
(buttons)&gt;
""")

    format_buttons = """
btn_ok{r}|btn_cancel{r}
"""

    @others</t>
<t tx="michael.20060817115418">def constitute(self, imodel):
    super(NewScenarioView, self).constitute(imodel)
    self.update_scenarios()

</t>
<t tx="michael.20060817140817">def add_scenario(self, name):
    if name in self.scenarios: return None
    child = self.child_model(self.code_item, 
                             self.attrib_name, 
                             self.default)
    setattr(self, "child_%s" % name, child)
    self.scenarios.append(name)
    return child</t>
<t tx="michael.20060817142344">def add_scenario(self, scenario):
    child = self.imodel.add_scenario(scenario)
    if child:
        page = self.create_subform(self.notebook, "Page%s" % scenario)
        page.inspect(self.imodel, scenario)
        self.notebook.AddPage(page, scenario, True)
        self.remove.Enable(True)
        self.update_remove_button()

</t>
<t tx="michael.20060817144005">def modify_subview(self, subview_class, name):
    if not name.startswith("Page"): return subview_class
    me = self

    class Page(subview_class):
        format = "child_"  + name[4:] + "&gt;"

        def get_control(self, name):
            if name.startswith("child_"):
                name = "child"

            return super(Page, self).get_control(name)

        def inspect_state(self):
            ichild = getattr(self.imodel, "child_%s" % name[4:])
            me.transaction.include(ichild)
            self.widgets["child"].inspect(self.imodel, "child_%s" % name[4:])


        def prepare(self):
            self.grow_col(0)
            self.grow_row(0)

    return Page</t>
<t tx="michael.20060817145008">def remove_scenario(self):
    current = self.notebook.GetSelection()
    scenario = self.notebook.GetPageText(current)
    child = self.imodel.remove_scenario(scenario)
    if child:
        self.notebook.DeletePage(current)
        self.update_remove_button()
        #self.transaction.</t>
<t tx="michael.20060817145008.1">def __init__(self, parent_imodel):
    self.parent_imodel = parent_imodel</t>
<t tx="michael.20060817145008.2">def get_scenarios(self):
    scenarios = set()
    parent_imodel = self.parent_imodel
    try:
        scenarios.update(parent_imodel.code_item.obj.root.all_scenarios)
    except AttributeError:
        pass

    try:
        root = get_code_root(parent_imodel.code_item)
        scenarios.update(root.all_scenarios)
    except AttributeError:
        pass

    scenarios.update(parent_imodel.scenarios)
    return scenarios</t>
<t tx="michael.20060817145008.3">def show(self, parent):
    dlg = editorlib.PatchedDialog(controller().frame,  -1, 
                _("Add Scenario"), style=wx.DEFAULT_DIALOG_STYLE)

    dlg.SetClientSize((10, 10))
    view = self.constitute()(dlg)
    view.layout()
    self.parent = parent
    dlg.simulate_modal(parent)</t>
<t tx="michael.20060817145030">def realize(self):
    self.parent.add_scenario(self.scenario)</t>
<t tx="michael.20060821115933">class EditorRegistry(object):
    def __init__(self):
        self.editors = {}

    
    def register(self, name, type, default):
        path = name.split("/")
        self.editors[name] = AttributeEditor(path[-1].rstrip("."), 
                                             type, default)


    def unregister(self):
        cls_name = self.cls.__name__
        for path in self.editors.keys():
            if path.split("/")[0] == cls_name:
                del self.editors[path]
        

    def Boolean(self, name, default=True):
        self.register(name, Boolean, default)

    def Float(self, name, default=1.0):
        self.register(name, Float, default)


    def Date(self, name, default=None):
        self.register(name, Date, default or datetime.datetime.now())

        
    def String(self, name, default=""):
        self.register(name, String, default)
        

    def Symbol(self, name, default):
        self.register(name, Symbol, default)


    def Shape(self, name, default):
        self.register(name, Shape, default)
        

    def MultiEvaluation(self, name):
        self.register(name, MultiEvaluation, None)

        
    def Evaluation(self, name):
        self.register(name, Evaluation, None)
        

    def TwoColorSet(self, name, default):
        self.register(name, TwoColorSet, default)


    def ColorSet(self, name, default):
        self.register(name, ColorSet, default)


    def ColorMap(self, name, default):
        self.register(name, ColorMap, default)
        

    def Property(self, name, create_property_groups):
        path = name.split("/")
        self.editors[name] = \
                     PropertyEditor(path[-1].rstrip("."), 
                                    create_property_groups)


    def Column(self, name, data_name):
        path = name.split("/")
        self.editors[name] = ColumnEditor(path[-1].rstrip("."), data_name)

</t>
<t tx="michael.20060821122847">class PropertySet(db.Model):
    def __init__(self, code_item, attrib, value):
        super(PropertySet, self).__init__()
        for k, v in (value or {}).iteritems():
            self.properties.insert(Property(name=k, value=v))            
        

    def __str__(self):
        return "{%s}" % ",\n".join(map(str, self.properties))


db.Relation("properies",
            db.End(Property, "properties", multi='*'),
            db.End(PropertySet))</t>
<t tx="michael.20060821191020">def __init__(self, attrib_name, create_property_groups):
    super(AttributeEditor, self).__init__(attrib_name, PropertySet)
    self.create_property_groups = create_property_groups
</t>
<t tx="michael.20060822214147">def register_editors(cls, registry):
    pass

register_editors = classmethod(register_editors)

</t>
<t tx="michael.20060822215648">def get_editors(self):
    import faces.gui.editor.observer as gobserver

    try:
        obj = self.code_item.obj
    except AttributeError:
        obj = self.get_default_pseudo()

    registry = gobserver.EditorRegistry()
    obj.register_editors(registry)
    registry.editors.update(self.editors)
    return registry.editors
</t>
<t tx="michael.20060826120325">__assignment_pattern = re.compile(r'([^=#]+)=[^=]')

def get_attribs(self, code_item):
    """
    get all assigned attribs of code_item
    """
    code_line = code_item.get_line()
    last_code_line = code_item.get_last_line() + 1
    lines = xrange(code_line, last_code_line)

    &lt;&lt; filter out child code &gt;&gt;

    if code_item.obj_type == pyeditor.FUNCTION:
        def get_attrib(line):
            text = self.GetLine(line)
            mo = self.__assignment_pattern.match(text)
            return mo and (mo.group(1).strip(), line)
    else:
        def get_attrib(line):
            text = self.GetLine(line)
            mo = self.__assignment_pattern.match(text)
            return mo and (mo.group(1).strip(), line)

    return dict(filter(bool, [ get_attrib(l) for l in lines ]))



</t>
<t tx="michael.20060826121701">nline = self.next_item_line(code_line + 1)
if nline &lt; last_code_line:
    indent = self.GetLineIndentation(nline)
    lines = [ i for i in lines if self.GetLineIndentation(i) &lt;= indent ]</t>
<t tx="michael.20060828215008">def register_editors(cls, registry):
    super(Standard, cls).register_editors(registry)
    registry.Evaluation(_("Report/data..."))
    registry.Column(_("Report/make_report..."), "data")

register_editors = classmethod(register_editors)

</t>
<t tx="michael.20060828221603">def make_browser_menu(self, menu, action_filter=None):
    return False</t>
<t tx="michael.20060828221643">def make_browser_menu(self, menu, action_filter=None):
    if not is_task(self.code_item): return False
    self.amend_browser_menu(menu, action_filter)
    return True
</t>
<t tx="michael.20060828221821"></t>
<t tx="michael.20060828221821.1">def make_browser_menu(self, menu, action_filter=()):
    if is_resource(self.code_item) or "create" in action_filter:
        self.amend_browser_menu(menu, action_filter)
        return True

    return False</t>
<t tx="michael.20060828221856"></t>
<t tx="michael.20060828221856.1">def make_browser_menu(self, menu, action_filter=None):
    if is_observer(self.code_item) or "create" in action_filter:
        self.amend_browser_menu(menu, action_filter)
        return True

    return False
</t>
<t tx="michael.20060828221931">def make_browser_menu(self, menu, action_filter=None):
    if is_import(self.code_item) or "create" in action_filter:
        self.amend_browser_menu(menu, action_filter)
        return True

    return False</t>
<t tx="michael.20060831002737">def insert_expression(self, code_item, text, move_cursor=True):
    """
    insert the expression after the last non empty line 
    before the first child
    """
    self.BeginUndoAction()
    line = code_item.get_line()
    indent = code_item.indent
    next_line = self.next_item_line(line + 1)
    for i in range(next_line - 1, line - 1, -1):
        if self.GetLineIndentation(i) &gt; indent \
            and self.GetLine(i).strip():
            break

    start_line = i + 1
    text += "\n"
    if self.GetLine(start_line).strip():
        start_line -= 1
        text = "\n" + text

    start = self.GetLineEndPosition(start_line)
    self.InsertText(start, text)

    if move_cursor: self.GotoPos(start + len(text))

    lines = text.split("\n")
    self.UpdateWindowUI()
    &lt;&lt; auto indent text &gt;&gt;
    self.EndUndoAction()

</t>
<t tx="michael.20060901114003"></t>
<t tx="michael.20060901114003.1">def make_browser_menu(self, menu, action_filter=None):
    if is_project(self.code_item) or "create" in action_filter:
        self.amend_browser_menu(menu, action_filter)
        return True

    return False
</t>
<t tx="michael.20060901185155">def _on_shash_pos_change(self, evt):
    width = self.GetClientSize()[0]
    sw = self.GetSashSize()
    if evt.GetSashPosition() &gt;= width - sw - 1:
        evt.SetSashPosition(width - sw - 1)
        self.SetSashGravity(1.0)
    else:
        self.SetSashGravity(0.0)</t>
<t tx="michael.20060901185516">def register_editors(cls, registry):
    super(Critical, cls).register_editors(registry)
    registry.ColorMap(_("Shape/colors..."), { "0d" : "red" })

register_editors = classmethod(register_editors)

</t>
<t tx="michael.20060901190834">class Balance(db.Model):
    value = db.Enumerate(ftask._allocator_strings)
    @others

class BalanceView(views.FormView):
    __model__ = Balance
    __view_name__ = "default"
    vgap = 0
    format = "value&gt;"

    def prepare(self):
        self.grow_col(0)
</t>
<t tx="michael.20060901190851">def __init__(self, code_item, attrib, value):
    super(Balance, self).__init__()
    self.value = value or ftask.SMART</t>
<t tx="michael.20060901190952">def __str__(self):
    return '%s' % ftask._allocator_strings[self.value]
</t>
<t tx="michael.20060901200906">class ColumnEditor(AttributeEditor):
    @others</t>
<t tx="michael.20060901201020">def apply(self, expression, code_item):
    if code_item.obj_type == pyeditor.CLASS:
        if not expression: 
            return self.attrib_name not in map(repr, code_item.get_children())
                            
        return False
        
    if code_item.obj_type == pyeditor.FUNCTION:
        return code_item.name == self.attrib_name
        
    return False    
    

</t>
<t tx="michael.20060901201827">def apply(self, expression, code_item):
    if code_item.obj_type != pyeditor.CLASS: return False
    return super(AttributeEditor, self).apply(expression, code_item)
</t>
<t tx="michael.20060901201924">def activate(self, context):
    """
    activates the editor.
    """
    code_item = context.code_item
    if code_item.obj_type == pyeditor.FUNCTION:
        code_item = code_item.get_parent()

    imodel = ColumnSet(context, self.attrib_name, self.data_name)
    imodel.show()
    return imodel
    
        
</t>
<t tx="michael.20060901202023">def __init__(self, attrib_name, data_name):
    self.attrib_name = attrib_name
    self.data_name = data_name</t>
<t tx="michael.20060901205413">def make_button(self, button, expression):
    &lt;&lt; get editors &gt;&gt;

    applies = lambda ne: ne[1].apply("", self.code_item)
    editors = filter(applies, editors.iteritems())

    if len(editors) != 1:
        button.hide()
        return

    button.set_bitmap("edit16")
    item_editor = editors[0][1]
    def show_popup(editor):
        item_editor.activate(CObserver(self.code_item.get_parent()))

    button.action = show_popup
    button.Show()</t>
<t tx="michael.20060901205826">import faces.gui.editor.observer as gobserver

parent_item = self.code_item.get_parent()
try:
    obj = parent_item.obj
except AttributeError:
    try:
        obj = get_observer_pseudo(parent_item)
    except AttributeError:
        obj = None

if obj:
    registry = gobserver.EditorRegistry()
    obj.register_editors(registry)
    editors = registry.editors
else:
    editors = {}</t>
<t tx="michael.20060902013502"></t>
<t tx="michael.20060903115207">if not pos:
    if context:
        end = self.GetLineEndPosition(context.code_item.get_last_line())
    else:
        end = self.GetCurrentPos()</t>
<t tx="michael.20060906005234">Column.choice = []
self.data_list_len = len(data_list)

for i, c in enumerate(data_list):
    attrlist = self.get_object_attribs(c)
    var_name = self.get_data_var_name(i)
    Column.choice.append(var_name)
    for a in attrlist: 
        Column.choice.append("%s.%s" % (var_name, a))
        
</t>
<t tx="michael.20060906020338">self.creator_item = None
for c in self.code_item.get_children():
    if c.name == attrib_name: 
        self.creator_item = c
        break</t>
<t tx="michael.20060906020338.1">start = editor.PositionFromLine(self.creator_item.get_line())
end = editor.GetLineEndPosition(self.creator_item.get_last_line())
pos = editor.FindText(start, end, "yield", 0)
values = editor.get_expression(editor.LineFromPosition(pos))
values = values[values.index("yield") + 5:].strip()
try:
    while values[0] in "([" and values[-1] in ")]": 
        values = values[1:-1].strip()
except IndexError: pass
values = [ v.strip() for v in values.split(",") ]</t>
<t tx="michael.20060906020338.2">attribs = editor.get_attribs(self.code_item)
try:
    headers = editor.get_expression(attribs["headers"])
    headers = editor.eval_expression(headers, context=context)["headers"]
except KeyError:
    headers = ("",) * len(values)

</t>
<t tx="michael.20060906020656">class Column(db.Model):
    value = db.Text()
    header = db.Text()
    choice = []</t>
<t tx="michael.20060906020656.1">class ColumnSet(SimpleContainer):
    error = db.Text()
    
    @others
    
    def get_data_var_name(self, no):
        if self.data_list_len == 1: return "t"
        return "t%i" % no
        

db.Relation("columns",
            db.End(Column, "columns", multi='*'),
            db.End(ColumnSet))</t>
<t tx="michael.20060906020656.2">def __init__(self, context, attrib_name, data_name):
    editor = context.code_item.editor
    self.attrib_name = attrib_name
    self.code_item = context.code_item
    
    &lt;&lt; get the data attribute value &gt;&gt;
    &lt;&lt; create the choice list for column values &gt;&gt;
    
    &lt;&lt; get the code_item, that creates the columns &gt;&gt;
    if self.creator_item:
        &lt;&lt; get column values &gt;&gt;
        &lt;&lt; get column headers &gt;&gt;
        
        for value, header in zip(values, headers):
            self.columns.insert(Column(value=value.strip(), header=header))
</t>
<t tx="michael.20060906020656.3">class ColumnSetView(editorlib.MainView):
    __model__ = ColumnSet
    __view_name__ = "default"
    vgap = 0
    format = """
error(Static)
[Columns:]
columns&gt;
delete
---
(buttons)&gt;
"""
    def create_controls(self):
        self.columns = self.get_control("columns(ColumnGrid)")
        self.delete = self.columns.get_delete_button(self)
    
    def prepare(self):
        self.grow_col(0)
        self.grow_row(1)
        self.buttons.grow_col(0)
        self.error.Hide()
        self.error.SetForegroundColour(self.error_colour)

    def constitute(self, imodel):
        super(ColumnSetView, self).constitute(imodel)
        if imodel.error: self.error.Show()
</t>
<t tx="michael.20060906020656.4">class ColumnGrid(grid.EditGrid, views.GridView):
    __model__ = Column
    columns = (("value(auto_tree)", _("Value")),
               ("header", _("Header")))
    resize_col = 0


    def prepare(self, attribute):
        if attribute == "value":
            self.value.fill_tree(Column.choice)</t>
<t tx="michael.20060906020907">try:
    attribs = editor.eval_expression("evals=%s" % data_name, 
                                     context=context)
    data = attribs["evals"]
    for data_list in data:
        break
        
    if not isinstance(data_list, (list, tuple)):
        data_list = (data_list,)
        
except Exception, e:
    self.error = "%s: %s" % (e.__class__.__name__, str(e))
    data_list = ()</t>
<t tx="michael.20060906182627">def realize(self):
    editor = self.code_item.editor
    columns = [ c for c in self.columns if c.header or c.value ]
    headers = [c.header for c in columns]
    has_headers = bool(filter(bool, headers))

    try:
        header_line = editor.get_attribs(self.code_item)["headers"]
    except KeyError:
        header_line = None
    
    if has_headers:
        headers = "headers = (%s)" % ", ".join(['"%s"' % h for h in headers])
        if not header_line:
            editor.insert_expression(self.code_item, headers)
        else:
            editor.replace_expression(headers, header_line)
    elif header_line:
        editor.replace_expression("", header_line)

    data_list = ", ".join([ self.get_data_var_name(i) 
                           for i in range(self.data_list_len) ])
    values = [c.value for c in columns]
    maxlen = sum(map(len, values)) + len(values) * 2 + self.code_item.indent + 8
    joiner = maxlen &gt; 80 and ",\n" or ", "
    values = joiner.join(values)

    creator_text = "def %s(self, data):\nfor %s in data:\nyield (%s)" \
                    % (self.attrib_name, data_list, values)
      
    if self.creator_item:
        line = self.creator_item.get_line()
        editor.replace_expression(creator_text, line)
    else:
        creator_text = "\n" + creator_text    
        editor.insert_expression(self.code_item, creator_text)</t>
<t tx="michael.20060907105636">def activate(self, editor, line, prev, next, inside):
    if not super(CStructureContext, self)\
            .activate(editor, line, prev, next, inside):
        self.make_button(None, None)
        return False

    return True</t>
<t tx="michael.20060907133950">def apply_browser_menu(self, existing_attribs, code_item):
    if self.attrib_name in existing_attribs:
        return "edit"

    return "add"</t>
<t tx="michael.20060907134327">def apply_browser_menu(self, existing_attribs, code_item):
    if self.attrib_name in map(repr, code_item.get_children()):
        return "edit"
        
    return "add"</t>
<t tx="michael.20060909120029">class PropertySetView(views.FormView):
    __model__ = PropertySet
    __view_name__ = "default"
    vgap = 0
    format = """
properties&gt;
delete
"""
    def create_controls(self):
        self.properties = self.get_control("properties(PropertyGrid)")
        self.delete = self.properties.get_delete_button(self)
    
    def prepare(self):
        self.grow_col(0)
        self.grow_row(0)</t>
<t tx="michael.20060909120029.1">class PropertyGrid(grid.EditGrid, views.GridView):
    __model__ = Property
    columns = (("name(Combo)", _("Name")),
               ("value(Changeling)", _("Value")))
    resize_col = 0


    def begin_edit(self, name):
        if name == "name":
            if self.name.GetCount() != len(self.__model__.name_groups):
                self.name.Clear()
                for a in self.__model__.name_groups:
                    self.name.Append(a)
            return
        
        if name == "value":
            if self.imodel.name.endswith("color"):
                self.value.change("Color")
            elif self.imodel.name.endswith("width"):
                self.value.change("Text")
            elif self.imodel.name.endswith("fill"):
                self.value.change("BoolEnum")
            elif self.imodel.name.endswith("family"):
                self.value.change("FamilyCombo")
            elif self.imodel.name.endswith("weight"):
                self.value.change("WeightCombo")
            elif self.imodel.name.endswith("size"):
                self.value.change("SizeCombo")
            elif self.imodel.name.endswith("variant"):
                self.value.change("VariantEnum")
            elif self.imodel.name.endswith("antialiased"):
                self.value.change("BoolEnum")
            elif self.imodel.name.endswith("up"):
                self.value.change("BoolEnum")
            elif self.imodel.name.endswith("linestyle"):
                self.value.change("LinestyleEnum")
            elif self.imodel.name.endswith("joinstyle"):
                self.value.change("JoinstyleEnum")
            elif self.imodel.name.endswith("style"):
                self.value.change("StyleEnum")
            else:
                self.value.change("default")


    def inserted(self, imodel):
        return bool(imodel.name)</t>
<t tx="michael.20060910114955">@language python
"""
A timeaxis for gantt and resource charts.
"""
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

_colorConverter = colors.colorConverter

_week_name = _("Week")

def alt_week_locator(alt=True):
    global _week_name
    if alt:
        _week_name = ""
    else:
        _week_name = _("Week")

@others
</t>
<t tx="michael.20060910114955.1">import matplotlib.font_manager as font
import matplotlib.transforms as mtrans
import matplotlib.colors as colors
import matplotlib.artist as artist
import matplotlib._image as mimage
import datetime
import widgets
import faces.plocale
import locale
from faces.pcalendar import strftime
from tools import *


</t>
<t tx="michael.20060910114955.2">class Locator(object):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060910114955.3">can_locate_free_time = False

</t>
<t tx="michael.20060910114955.4">def __init__(self):
    self.tick_pos = (0, 0) # position is 0, the highest positon is 0
    self.sizes = {}
    self.format_cache = { }
</t>
<t tx="michael.20060910114955.5">def get_marks(self, intervals, scale, transform):
    xmin, xmax = transform.get_bbox1().intervalx().get_bounds()
    if intervals[0][0] &lt; xmin:
        intervals[0] = (xmin, intervals[0][1])

    if intervals[-1][1] &gt; xmax:
        intervals[-1] = (intervals[-1][0], xmax)

    middles = map(lambda i: (i[0] + i[1]) / 2, intervals)
    build_mark = self.build_mark
    marks = [ build_mark(i, scale, transform) for i in intervals ]
    xs = transform.seq_x_y(middles, middles)[0]
    return zip(marks, xs)
</t>
<t tx="michael.20060910114955.6">def fits(self, transform, scale):
    delta = self._delta(scale)
    key = self.tick_pos[0] == self.tick_pos[1] and "top" or "default"
    sizes = self.sizes.get(key, self.sizes["default"])[0]
    delta = transform(delta)
    return sizes[-1][0] &lt; delta
</t>
<t tx="michael.20060910114955.7">def prepare(self, renderer, fonts, tickers):
    "precalculates all possible marker sizes"
    self.renderer = renderer
    self.fonts = zip(tickers, fonts)
    self._calc_sizes()
    for v in self.sizes.itervalues():
        for s in v.itervalues():
            s.sort()
            s.reverse()

    del self.renderer
    del self.fonts
</t>
<t tx="michael.20060910114955.8">def _calc_sizes(self):
    raise RuntimeError("abstract")
</t>
<t tx="michael.20060910114955.9">def _delta(self, scale):
    raise RuntimeError("abstract")
</t>
<t tx="michael.20060910114955.10">def _get_format(self, interval, transform):
    delta = int(interval[0] - interval[1])
    format = self.format_cache.get(delta)
    if format: return format

    x, y = transform.seq_x_y(interval, (0, 0))
    tdelta = x[1] - x[0]
    key = self.tick_pos[0] == self.tick_pos[1] and "top" or "default"
    sizes = self.sizes.get(key, self.sizes["default"])[self.tick_pos[0]]
    for s, f in sizes:
        if s &lt; tdelta:
            format = f
            break
    else:
        format = ""

    self.format_cache[delta] = format
    return format
</t>
<t tx="michael.20060910114955.11">def _calc_markers(self, markers, format, key="default"):
    extent = self.renderer.get_text_width_height

    key_fonts = self.sizes.get(key)
    if not key_fonts:
        key_fonts = {}
        for i, f in self.fonts: key_fonts[i] = []

    if not isinstance(markers, (list, tuple)):
        markers = (markers,)

    for i, f in self.fonts:
        size = max([extent(m, f, False)[0] for m in markers])
        key_fonts[i].append((size, str(format)))

    self.sizes[key] = key_fonts
</t>
<t tx="michael.20060910114955.12">def is_free(self, num_date):
    #num_date is int
    return False
</t>
<t tx="michael.20060910114955.13">class DecadeLocator(Locator):
	@others
</t>
<t tx="michael.20060910114955.14">def _delta(self, scale):
    return scale.week_delta * 52 * 10
</t>
<t tx="michael.20060910114955.15">def _calc_sizes(self):
    self._calc_markers("88888", "%D")
</t>
<t tx="michael.20060910114955.16">def __call__(self, left, right, time_scale):
    num = time_scale.to_num
    dt = datetime.datetime
    left = num(int(left))
    right = num(int(right))
    start = left.to_datetime().year / 10
    end = right.to_datetime().year / 10 + 2
    locs = map(lambda y: num(dt(y * 10, 1, 1)), range(start, end))
    return locs
</t>
<t tx="michael.20060910114955.17">class YearLocator(Locator):
	@others
</t>
<t tx="michael.20060910114955.18">def _delta(self, scale):
    return scale.week_delta * 52
</t>
<t tx="michael.20060910114955.19">def _calc_sizes(self):
    self._calc_markers("88888", "%IY")
</t>
<t tx="michael.20060910114955.20">def __call__(self, left, right, time_scale):
    num = time_scale.to_num
    dt = datetime.datetime
    left = num(int(left))
    right = num(int(right))
    start = left.to_datetime().year
    end = right.to_datetime().year + 2
    locs = map(lambda y: num(dt(y, 1, 1)), range(start, end))
    return locs
</t>
<t tx="michael.20060910114955.21">class QuaterLocator(Locator):
	@others
</t>
<t tx="michael.20060910114955.22">def _delta(self, scale):
    return scale.week_delta * 12
</t>
<t tx="michael.20060910114955.23">def _calc_sizes(self):
    self._calc_markers("Q 8/88888", "Q %Q/%IY", "top")
    self._calc_markers("Q 88", "Q %Q")
</t>
<t tx="michael.20060910114955.24">def __call__(self, left, right, time_scale):
    num = time_scale.to_num
    dt = datetime.datetime
    left = num(int(left))
    right = num(int(right))
    start = left.to_datetime()
    end = right.to_datetime()
    start = start.year * 4 + (start.month - 1) / 3
    end = end.year * 4 + (end.month - 1) / 3 + 2
    locs = map(lambda qy: num(dt(qy/4, (qy%4)*3+1, 1)), range(start, end))
    return locs
</t>
<t tx="michael.20060910114955.25">class MonthLocator(Locator):
	@others
</t>
<t tx="michael.20060910114955.26">def _delta(self, scale):
    return scale.week_delta * 4
</t>
<t tx="michael.20060910114955.27">def _calc_sizes(self):
    dt = datetime.datetime
    def mlist(format):
        return map(lambda m: strftime(dt(2005, m, 1), format), range(1, 13))

    self._calc_markers(mlist("%B 88888"), "%B %IY", "top")
    self._calc_markers(mlist("%b 88888"), "%b %IY", "top")
    self._calc_markers(mlist("%m.88888"), "%m.%IY", "top")
    self._calc_markers(mlist("%B"), "%B")
    self._calc_markers(mlist("%b"), "%b")
    self._calc_markers("8888", "%m")
</t>
<t tx="michael.20060910114955.28">def __call__(self, left, right, time_scale):
    num = time_scale.to_num
    dt = datetime.datetime

    left = num(int(left))
    right = num(int(right))
    start = left.to_datetime()
    end = right.to_datetime()
    start = start.year * 12 + start.month - 1
    end = end.year * 12 + end.month + 1
    locs = map(lambda my: num(dt(my/12, 1+my%12, 1)), range(start, end))
    return locs
</t>
<t tx="michael.20060910114955.29">class WeekLocator(Locator):
	@others
</t>
<t tx="michael.20060910114955.30">def _delta(self, scale):
    return scale.week_delta
</t>
<t tx="michael.20060910114955.31">def _calc_sizes(self):
    global _week_name

    dt = datetime.datetime
    def mlist(format):
        return map(lambda m: strftime(dt(2005, m, 1), str(format)), range(1, 13))

    if _week_name:
        self._calc_markers(mlist("%IW. " + _week_name + " %IB 88888"),
                           "%IW. " + _week_name + " %IB %IY", "top")
        self._calc_markers(mlist("%IW. " + _week_name + " %ib 88888"),
                           "%IW. " + _week_name + " %ib %IY", "top")
        self._calc_markers(mlist("%IW. " + _week_name + " %im.88888"),
                           "%IW. " + _week_name + " %m.%IY", "top")
        self._calc_markers(mlist("%IW %ib 88888"), "%IW %ib %IY", "top")
        self._calc_markers(mlist("%IW %im 88888"), "%IW %im.%IY", "top")
        self._calc_markers("888. " + _week_name, "%IW. " + _week_name)
        self._calc_markers("8888", "%IW")
    else:
        # in the US week numbers are not used
        self._calc_markers(mlist("%B 88"), "%B %d")
        self._calc_markers(mlist("%b. 88"), "%b. %d")

</t>
<t tx="michael.20060910114955.32">def __call__(self, left, right, time_scale):
    num = time_scale.to_num
    left = num(int(left))
    right = num(int(right)) + time_scale.week_delta
    start = left.to_datetime().replace(hour=0, minute=0)
    start -= datetime.timedelta(days=start.weekday()) 
    start = num(start)
    locs = range(start, right, time_scale.week_delta)
    return locs
</t>
<t tx="michael.20060910114955.33">class DayLocator(Locator):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060910114955.34">can_locate_free_time = True


</t>
<t tx="michael.20060910114955.35">def _delta(self, scale):
    return scale.day_delta
</t>
<t tx="michael.20060910114955.36">def _calc_sizes(self):
    dt = datetime.datetime
    def dlist(format):
        return map(lambda d: strftime(dt(2005, 1, d), format), range(1, 8))

    self._calc_markers(dlist("%A %x88"), "%A %x", "top")
    self._calc_markers(dlist("%a %x88"), "%a %x", "top")
    self._calc_markers(dlist("%x88"), "%x", "top")
    self._calc_markers(dlist("%A 888."), "%A %d.")
    self._calc_markers(dlist("%a 888."), "%a %d.")
    self._calc_markers("8888", "%d")
</t>
<t tx="michael.20060910114955.37">def __call__(self, left, right, time_scale):
    self.time_scale = time_scale
    num = time_scale.to_num
    date = time_scale.to_datetime
    td = datetime.timedelta
    left = date(num(int(left))).replace(hour=0, minute=0)
    right = date(num(int(right)))
    days = (right - left).days + 2
    locs = map(lambda d: num(left + td(days=d)), range(0, days))
    return locs
</t>
<t tx="michael.20060910114955.38">def is_free(self, num_date):
    return self.time_scale.is_free_day(num_date)
</t>
<t tx="michael.20060910114955.39">class SlotLocator(Locator):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060910114955.40">can_locate_free_time = True


</t>
<t tx="michael.20060910114955.41">def _delta(self, scale):
    return scale.slot_delta
</t>
<t tx="michael.20060910114955.42">def __call__(self, left, right, time_scale):
    self.time_scale = time_scale
    num = time_scale.to_num
    date = time_scale.to_datetime
    td = datetime.timedelta
    left = date(num(int(left))).replace(hour=0, minute=0)
    right = date(num(int(right)))
    days = (right - left).days + 2
    days = map(lambda d: left + td(days=d), range(0, days))
    get_working_times = time_scale.chart_calendar.get_working_times

    locs = []
    for d in days:
        slots = get_working_times(d.weekday())
        locs.extend(map(lambda s: num(d + td(minutes=s[0])), slots))

    return locs
</t>
<t tx="michael.20060910114955.43">def _calc_sizes(self):
    self._calc_markers("888:88-88:88", "%(sh)02i:%(sm)02i-%(eh)02i:%(em)02i")
    self._calc_markers("888-88", "%(sh)02i-%(eh)02i")
    self._calc_markers("888:88", "%(sh)02i:%(sm)02i")
    self._calc_markers("888", "%(sh)02i")
</t>
<t tx="michael.20060910114955.44">def get_marks(self, intervals, scale, transform):
    def build_mark(interval):
        format = self._get_format(interval, transform)
        start = scale.to_num(interval[0]).to_datetime()
        end = scale.to_num(interval[1]).to_datetime()
        vals = { "sh" : start.hour,
                 "sm" : start.minute,
                 "eh" : end.hour,
                 "em" : end.minute }
        return format % vals

    middles = map(lambda i: (i[0] + i[1]) / 2, intervals)
    marks = map(build_mark, intervals)
    xs = transform.seq_x_y(middles, (0,)*len(middles))[0]
    return zip(marks, xs)
</t>
<t tx="michael.20060910114955.45">def is_free(self, num_date):
    return self.time_scale.is_free_slot(num_date)
</t>
<t tx="michael.20060910114955.46">def _zigzag_lines(locs, top, bottom):
    xs = locs * 2
    xs.sort()
    ys = [ top, bottom,  bottom, top ] * ((len(locs) + 1) / 2)
    if len(locs) % 2: del ys[-2:]
    return xs, ys
</t>
<t tx="michael.20060910114955.47">class TimeAxis(artist.Artist, widgets._PropertyAware):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060910114955.48">properties = {
    "family": "sans-serif",
    #"family": [ "Arial", "Verdana", "Bitstream Vera Sans" ] ,
    "weight": "normal",
    "size"  : "medium",
    "style" : "normal",
    "variant" : "normal",
    "2.weight" : "bold",
    "2.size" : "x-large",
    "1.weight" : "bold",
    "1.size" : "large",
    "color": 'black',
    "0.facecolor" : 'white',
    "facecolor" : 'darkgray',
    "edgecolor" : 'black',
    "grid.edgecolor" : 'darkgray',
    "free.facecolor": "lightgrey",
    "linewidth" : 1,
    "joinstyle" : 'miter',
    "linestyle" : 'solid',
    "now.edgecolor" : "black",
    "now.linewidth" : 2,
    "now.linestyle" : "dashed",
    "antialiased" : True,
    "alpha" : 1.0,
    "tickers" : (1, ) }


zorder = -100
show_grid = True
show_scale = True
show_free_time = True
show_now = True
time_scale = None # must be set by Chart

</t>
<t tx="michael.20060910114955.49">def __init__(self, properties=None):
    widgets._PropertyAware.__init__(self, properties)
    artist.Artist.__init__(self)
    self._locators = tuple(map(lambda l: l(), _locators))
    self._last_cache = None
    self._last_cache_state = None
    self._last_width = 0
    self.encoding = locale.getlocale()[1] or "ascii"
</t>
<t tx="michael.20060910114955.50">def calc_height(self):
    if not self.show_scale:
        self.height = 0
        return 0

    prop = self.get_property
    def_height = font.fontManager.get_default_size()

    sep = def_height / 3
    tickers = (0,) + prop("tickers")
    self.height = 0
    for t in tickers:
        tsize = self.get_font(str(t)).get_size_in_points()
        self.height += tsize + 2 * sep

    return self.height
</t>
<t tx="michael.20060910114955.51">def set_transform(self, t):
    #a non scaled point y axis
    Value = mtrans.Value
    Point = mtrans.Point
    Bbox = mtrans.Bbox
    Transformation = mtrans.SeparableTransformation

    fig_point_to_pixel = self.get_figure().dpi / mtrans.Value(72)

    view_box = t.get_bbox2()
    top = view_box.ur().y()
    bottom = view_box.ll().y()
    point_height = (bottom - top) / fig_point_to_pixel

    bbox = t.get_bbox1()
    ll = bbox.ll()
    ur = bbox.ur()
    new_ll = Point(ll.x(), point_height)
    new_ur = Point(ur.x(), Value(0))
    data_box = Bbox(new_ll, new_ur)

    t = Transformation(data_box, view_box, t.get_funcx(), t.get_funcy())
    artist.Artist.set_transform(self, t)
</t>
<t tx="michael.20060910114955.52">__prepared = False
def draw(self, renderer):
    if not self.get_visible(): return

    trans = self.get_transform()
    trans.freeze()
    try:
        if not self.__prepared:
            self.__prepared = True
            tickers = (0,) + self.get_property("tickers")
            fonts = map(lambda t: self.get_font(str(t)), tickers)
            for l in self._locators:
                l.prepare(renderer, fonts, tickers)

        data_box = trans.get_bbox1()
        view_box = trans.get_bbox2()
        width = data_box.width()

        if self._last_width != width:
            self._last_width = width
            self.find_ticker(renderer)

        cache_state = (self.show_grid + self.show_scale,
                       view_box.width(), view_box.height(),
                       renderer, data_box.xmin())

        if self._last_cache_state == cache_state and self._last_cache:
            try:
                #not now because of memory leak
                renderer.draw_image(0, 0, self._last_cache, view_box)
                #renderer.restore_region(self._last_cache)
                return
            except:
                pass

        gc = renderer.new_gc()

        if self.get_clip_on():
            gc.set_clip_rectangle(self.clipbox.get_bounds())

        if self.show_grid: self.draw_grid(renderer, gc, trans)
        if self.show_now:
            time_scale = self.time_scale
            left, right = data_box.intervalx().get_bounds()
            if left &lt;= time_scale.now &lt;= right:
                top, bottom = data_box.intervaly().get_bounds()
                self.set_gc(gc, "now")
                renderer.draw_lines(gc,
                                    (time_scale.now, time_scale.now),
                                    (top, bottom), trans)

        if self.show_scale: self.draw_scale(renderer, gc, trans)

        self._last_cache_state = cache_state
        #self._last_cache = renderer.copy_from_bbox(view_box)
        try:
            self._last_cache = mimage.frombuffer(\
                renderer.buffer_rgba(0, 0),
                renderer.width,
                renderer.height, 1)
        except AttributeError:
            self._last_cache = None

        if self._last_cache:
            self._last_cache.flipud_out()
    finally:
        trans.thaw()
</t>
<t tx="michael.20060910114955.53">def find_ticker(self, renderer):
    time_scale = self.time_scale

    tickers = self.get_property("tickers")
    if not isinstance(tickers, tuple):
        tickers = tuple(tickers)

    tickers = (0,) + tickers
    highest_locator = tickers[-1]

    transform = self.get_transform()
    origin = transform.xy_tup((0, 0))[0]

    def delta_trans(x_delta):
        p = transform.xy_tup((x_delta, 0))
        return p[0] - origin

    def refresh_locators(lowest):
        self.ticker = lowest
        for t in tickers:
            loc = self._locators[lowest + t]
            loc.tick_pos = (t, highest_locator)
            loc.format_cache.clear()

    for ti in range(len(self._locators) - highest_locator):
        loc = self._locators[ti]
        loc.tick_pos = (0, highest_locator)

        if loc.fits(delta_trans, time_scale):
            refresh_locators(ti)
            break
    else:
        refresh_locators(len(self._locators) - highest_locator - 1)
</t>
<t tx="michael.20060910114955.54">def draw_scale(self, renderer, gc, trans):
    prop = self.get_property
    time_scale = self.time_scale

    def_height = font.fontManager.get_default_size()
    sep = def_height / 3
    left, right = trans.get_bbox1().intervalx().get_bounds()
    dpi = self.get_figure().get_dpi()

    if left &gt;= right: return

    self.set_gc(gc)
    free_face = _colorConverter.to_rgb(prop("free.facecolor"))

    def dline(x1, y1, x2, y2):
        draw_line(renderer, gc, x1, y1, x2, y2, trans)

    def draw_ticks(bottom, locator, name, show_free_time=False):
        fp = self.get_font(name)
        top = bottom - fp.get_size_in_points() - 2 * sep

        locs = locator(left, right, time_scale)
        lintervals = zip(locs[:-1], locs[1:])

        face = _colorConverter.to_rgb(prop(name + ".facecolor"))
        verts = ((left, -bottom), (left, -top),
                 (right, -top), (right, -bottom))
        verts = trans.seq_xy_tups(verts)
        renderer.draw_polygon(gc, face, verts)

        if show_free_time and locator.can_locate_free_time:
            gc.set_linewidth(0)
            for l, r in lintervals:
                #if locator.is_free((l + r) / 2):
                if locator.is_free(l):
                    verts = ((l, -bottom), (l, -top),
                             (r, -top), (r, -bottom))
                    verts = trans.seq_xy_tups(verts)
                    renderer.draw_polygon(gc, free_face, verts)

        fp = self.get_font(name)
        gc.set_foreground(prop(name + ".color"))
        x, y = trans.xy_tup((0, -bottom + sep))
        markers = locator.get_marks(lintervals, time_scale, trans)
        for m, x in markers:
            self.draw_text(renderer, gc, x, y, m, fp, "bc", dpi)

        gc.set_foreground(prop(name + ".edgecolor"))
        gc.set_linewidth(prop(name + ".linewidth"))

        xs, ys = _zigzag_lines(locs, -top, -bottom)
        renderer.draw_lines(gc, xs, ys, trans)

        gc.set_linewidth(prop("linewidth"))
        dline(left, -top, right, -top)
        dline(left, -bottom, right, -bottom)

        return top

    tickers = prop("tickers")
    bottom = self.height
    ticks = self._locators[self.ticker]
    bottom = draw_ticks(bottom, ticks, "0", self.show_free_time)
    for t in tickers:
        ticks = self._locators[self.ticker + t]
        bottom = draw_ticks(bottom, ticks, str(t))
</t>
<t tx="michael.20060910114955.55">def draw_grid(self, renderer, gc, trans):
    time_scale = self.time_scale
    prop = self.get_property        

    data_box = trans.get_bbox1()
    left, right = data_box.intervalx().get_bounds()
    top, bottom = data_box.intervaly().get_bounds()

    if left &gt;= right: return

    locator = self._locators[self.ticker]
    locs = locator(left, right, time_scale)
    lintervals = zip(locs[:-1], locs[1:])

    self.set_gc(gc, "grid")
    if self.show_free_time and locator.can_locate_free_time:
        gc.set_linewidth(0)
        free_face = _colorConverter.to_rgb(prop("free.facecolor"))
        for l, r in lintervals:
            if locator.is_free((l + r) / 2):
                verts = trans.seq_xy_tups(((l, bottom), (l, top),
                                           (r, top), (r, bottom)))

                renderer.draw_polygon(gc, free_face, verts)


    gc.set_linewidth(prop("grid.linewidth"))

    xs, ys = _zigzag_lines(locs, top, bottom)
    renderer.draw_lines(gc, xs, ys, trans)
    draw_line(renderer, gc, left, bottom, right, bottom, trans)
</t>
<t tx="michael.20060910114955.56">def draw_text(self, renderer, gc, x, y, text, fp, align, dpi):
    """
    special draw_text for taxis using the locale encoding which is used by
    the strftime functions
    """

    if not text: return
    text = text.decode(self.encoding)

    w, h = renderer.get_text_width_height(text, fp, False)
    if align[0] == 'c': 
        y -= h / 2
    elif align[0] == 't':
        y -= h

    if align[1] == 'c': 
        x -= w / 2
    elif align[1] == 'r':
        x -= w

    if renderer.flipy():
        canvasw, canvash = renderer.get_canvas_width_height()
        y = canvash-y

    renderer.draw_text(gc, x, y, text, fp, 0, False)
</t>
<t tx="michael.20060910115214">@others

_locators = ( SlotLocator,
              DayLocator,
              WeekLocator,
              MonthLocator,
              QuaterLocator,
              YearLocator,
              DecadeLocator )
</t>
<t tx="michael.20060910151243"></t>
<t tx="michael.20060910154312">class ModuleDoc(DocBase):
	@others
</t>
<t tx="michael.20060910154430">def __init__(self, module):
    self.description = str(module.__doc__ or "")
</t>
<t tx="michael.20060910160841">def constructor(self, name):
    desc = textwrap.fill(self.description,
                         max(self.min_width, len(name) + 1))
    return len(name) + 1, "%s:\n%s" % (name, desc)
</t>
<t tx="michael.20060910220708">def get_object_attribs(self, obj):
    try:
        attrlist = obj.__all__
    except AttributeError:
        attrlist = dir(obj)
        
    attrlist = filter(lambda n: n[0] != "_", attrlist)

    def make_call(a):
        if callable(getattr(obj, a)):
            return "%s()" % a
        return a
        
    if isinstance(obj, ftask.Task):
        #filter out children
        attrlist = [ a for a in attrlist 
                     if not isinstance(getattr(obj, a), ftask.Task)]
        attrlist = [ make_call(a) for a in attrlist ]
        attrlist += [ "to_string.%s" % a for a in attrlist 
                      if a != "_to_string" and a[-1] != ")" ]
        attrlist.sort()
    else:
        attrlist = [ make_call(a) for a in attrlist ]
    
    return attrlist</t>
<t tx="michael.20060912153307">def encode(text):
    if type(text) is unicode:
        return str(text.encode(chart_tools.chart_encoding))
    return str(text)</t>
<t tx="michael.20060912164103">def update_menus(self):
    top = controller().get_top_menu()
    project_menu = top.make_menu(_("&amp;Project"), pos=110)
    view = controller().find_view_of(self)
    menu = lambda *args, **kw: project_menu.make_item(view, *args, **kw)


    def expand(): self.Expand(self.GetSelection())
    def collapse(): self.Collapse(self.GetSelection())
    def next(): 
        next = self.GetNextVisible(self.GetSelection())
        if next.IsOk():
            self.SelectItem(next)
            self.EnsureVisible(next)

    def prev():
        prev = self.get_prev_visible(self.GetSelection())
        if prev.IsOk():
            self.SelectItem(prev)
            self.EnsureVisible(prev)

    menu(_("Collapse Item\tALT-LEFT"), collapse, "left16", pos=10)
    menu(_("Expand Item\tALT-RIGHT"), expand, "right16", pos=20)
    menu(_("Move Item Up\tALT-UP"), prev, "up16", pos=30)
    menu(_("Move Item Down\tALT-DOWN"), next, "down16", pos=40)

    project_menu.make_separator(_("Move Item Down"), False)        </t>
<t tx="michael.20060913121250">for t in eval:
    code = t._function.func_code
    if path != code.co_filename: continue
    line = code.co_firstlineno
    item = self.code_item_at(line - 1)
    if item and item.name == t.name:
        item.obj = t
        # The next assignments are needed in correct_code and find_task_references
        item.task_path = t.path 
        t._function.code_item = weakref.proxy(item)
</t>
<t tx="michael.20060913121250.1">is_class = lambda i: i.obj_type == pyeditor.CLASS
for ci in filter(is_class, self.code_items):
    v = module.__dict__.get(ci.name)
    if inspect.isclass(v): ci.obj = v</t>
<t tx="michael.20060913121250.2">for ci in filter(is_evaluation, self.code_items):
    v = module.__dict__.get(ci.name)
    if isinstance(v, ftask._ProjectBase): ci.obj = v</t>
<t tx="michael.20060913132734">class TaskCreator(NameEditor):
    title = _("Add Task")

    @others</t>
<t tx="michael.20060913150931">try:
    paren_pos = menu_title.index("(")
    menu_pos = int(menu_title[paren_pos + 1:-1])
    menu_title = menu_title[:paren_pos]
except ValueError:
    pass</t>
<t tx="michael.20060913152318.2">def insert_code(self, code):
    indent = self.context.code_item.editor.GetIndent()
    self.context.append_item(code, self.context.code_item.indent + indent)
</t>
<t tx="michael.20060914094858">def append_item(self, code, indent=-1, prespace="\n\n"):
    """
    appends a new code_item after the current item
    """
    editor = self.code_item.editor
    editor.BeginUndoAction()

    last_line = self.code_item.get_last_line()
    line_end = editor.GetLineEndPosition(last_line)
    insert_code = "%s%s" % (prespace, code)

    editor.InsertText(line_end, insert_code)

    start_line = last_line + 2
    line_pos = editor.PositionFromLine(start_line)
    if indent &gt; -1:
        editor.SetLineIndentation(start_line, indent)
    else:
        editor.autoindent(line_pos, False)

    line_count = len(code.split("\n"))
    for line in range(start_line + 1, start_line + line_count):
        editor.autoindent(editor.PositionFromLine(line), False)
    else:
        line = start_line + line_count

    line_end = editor.GetLineEndPosition(line)        
    if editor.GetLine(line + 1).strip():
        # the next line is not empty ==&gt; insert an extra line
        editor.InsertText(line_end, "\n")

    editor.GotoPos(line_end)
    editor.EndUndoAction()
    return start_line, start_line + line_count</t>
<t tx="michael.20060914103204.1">class SubTaskCreator(TaskCreator):
    @others</t>
<t tx="michael.20060914103204.2">class TaskSiblingCreator(TaskCreator):
    @others</t>
<t tx="michael.20060914103351">def realize_code(self):
    now = datetime.datetime.now().strftime("%x %H:%M:%S")
    code = 'def %s():\n"Inserted at %s"' % (self.name, now)
    self.insert_code(code)
</t>
<t tx="michael.20060914103403">def insert_code(self, code):
    self.context.append_item(code, self.context.code_item.indent)
</t>
<t tx="michael.20060914104037">class TaskSiblingBeforeCreator(TaskCreator):
    @others</t>
<t tx="michael.20060914104037.1">def insert_code(self, code):
    self.context.insert_item(code, self.context.code_item.indent)
</t>
<t tx="michael.20060914113429">@doc
The code must bei inserted before the line marker of the code item!
(Therefore the insertion ahs to be done at prev_line_end)
@code
def insert_item(self, code, indent):
    """
    inserts a new code_item beforte the current item
    """
    editor = self.code_item.editor
    editor.BeginUndoAction()

    line = self.code_item.get_line()
    prev_line_end = editor.GetLineEndPosition(line - 1)

    insert_code = "\n%s\n" % code
    editor.InsertText(prev_line_end, insert_code)

    start_line = line
    line_pos = editor.PositionFromLine(start_line)
    editor.SetLineIndentation(start_line, indent)

    line_count = len(code.split("\n"))
    for line in range(start_line + 1, start_line + line_count):
        editor.autoindent(editor.PositionFromLine(line), False)
    else:
        line = start_line + line_count

    line_end = editor.GetLineEndPosition(line)
    if editor.GetLine(start_line - 1).strip():
        # the before line is not empty ==&gt; insert an extra line
        line_before_end = editor.GetLineEndPosition(start_line - 1)
        editor.InsertText(line_before_end, "\n")

    editor.GotoPos(line_end)
    editor.EndUndoAction()
    return start_line, start_line + line_count
</t>
<t tx="michael.20060915105317">__correct_code_cal = False
def correct_code(self):
    if self.__correct_code_cal: return
    self.__correct_code_cal = True

    self.should_be_corrected = False

    self.BeginUndoAction()

    ctrl = controller()
    task_items = [ i for i in self.code_items if is_task(i) or is_project(i)]
    resource_items = [ i for i in self.code_items if is_resource(i) ]    

    ctrl.progress_start(_("correct code"), 
                        len(task_items) + len(resource_items))

    counter = 1

    for ti in task_items: 
        self.correct_task_code(ti)
        ctrl.progress_update(counter)
        counter += 1

    for r in resource_items:
        self.correct_resource_code(r)
        ctrl.progress_update(counter)
        counter += 1

    ctrl.progress_end()            
    self.EndUndoAction()
    self.__correct_code_cal = False
</t>
<t tx="michael.20060915183222">def get_code_item_path(code_item):
    item = code_item
    path = []
    while item:
        path.append(item.name)
        item = item.get_parent()

    path.reverse()
    path[0] = "root"
    return ".".join(path)

</t>
<t tx="michael.20060915184406">def create_relative_path(from_, to_):
    """
    creates a relative path from absolute path 
    from_ to absolute path to_
    """
    from_ = from_.split(".")
    to_ = to_.split(".")

    for i, parts in enumerate(zip(from_, to_)):
        from_part, to_part = parts
        if from_part != to_part:
            break

    from_ = from_[i:]
    to_ = to_[i:]
    return "up." * len(from_) + ".".join(to_)</t>
<t tx="michael.20060915184406.1">_to_datetime = pcalendar.to_datetime</t>
<t tx="michael.20060915190443">def create_absolute_path(from_, to_):
    """
    creates a absolute path from absolute path 
    from_ to relative path to_
    """
    from_ = from_.split(".")
    to_ = to_.split(".")

    for i, part in enumerate(to_):
        if part != "up":
            break

    from_ = from_[:-i]
    to_ = to_[i:]
    return "%s.%s" % (".".join(from_), ".".join(to_))


</t>
<t tx="michael.20060915191847">def path_argument(path):
    if path.startswith("up."):
        return { "path": ftask.create_absolute_path(self.item_path, path),
                 "relative": True }

    return { "path": path,
             "relative": False }</t>
<t tx="michael.20060915234005">class TaskUnindenter(object):
    __icon__ = "unindent16"
    @others</t>
<t tx="michael.20060915234005.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060915234005.2">def apply_browser_menu(self, existing_attribs, code_item):
    parent = code_item.get_parent()
    if classifiers.is_task(parent):
        return "extra"

    return ""
</t>
<t tx="michael.20060915234005.3">def activate(self, context):
    code_item = context.code_item
    editor = code_item.editor
    indent = editor.GetIndent()
    start_line = code_item.get_line()
    end_line = code_item.get_last_line()
    lines = xrange(start_line, end_line + 1)
    editor.BeginUndoAction()
    for l in lines:
        old_indent = editor.GetLineIndentation(l)
        editor.SetLineIndentation(l, old_indent - indent)

    editor.check_code_updates(start_line, end_line)
    editor.correct_task_code(code_item)
    editor.EndUndoAction()
</t>
<t tx="michael.20060918124853">class TaskIndenter(object):
    __icon__ = "indent16"
    @others</t>
<t tx="michael.20060918124853.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060918124853.2">def apply_browser_menu(self, existing_attribs, code_item):
    line = code_item.get_line()
    editor = code_item.editor
    prev_line = editor.prev_item_line(line - 1)
    prev_item = editor.code_item_at(prev_line)

    if classifiers.is_task(prev_item) and prev_item.indent &gt;= code_item.indent:
        return "extra"

    return ""
</t>
<t tx="michael.20060918124853.3">def activate(self, context):
    code_item = context.code_item
    editor = code_item.editor
    indent = editor.GetIndent()
    start_line = code_item.get_line()
    end_line = code_item.get_last_line()
    lines = xrange(start_line, end_line  + 1)
    editor.BeginUndoAction()
    for l in lines:
        old_indent = editor.GetLineIndentation(l)
        editor.SetLineIndentation(l, old_indent + indent)

    editor.check_code_updates(start_line, end_line)
    editor.correct_task_code(code_item)
    editor.EndUndoAction()
</t>
<t tx="michael.20060918130215">def get_last_code_item(self):
    """
    returns the last code item of the context.
    This code_item can be used for function append_item
    """
    raise RuntimeError("abstract")</t>
<t tx="michael.20060918130628">def get_last_code_item(self):
    editor = self.code_item.editor
    try:
        return [ci for ci in editor.code_items if is_observer(ci) ][-1]
    except IndexError:
        return CEvaluation(self.code_item).get_last_code_item()

</t>
<t tx="michael.20060918131528"></t>
<t tx="michael.20060918131528.1">def get_last_code_item(self):
    editor = self.code_item.editor
    try:
        return [ci for ci in editor.code_items if is_evaluation(ci) ][-1]
    except IndexError:
        return CProjectDelaration(self.code_item).get_last_code_item()
</t>
<t tx="michael.20060918131528.2">def make_browser_menu(self, menu, action_filter=None):
    if is_evaluation(self.code_item) or "create" in action_filter:
        self.amend_browser_menu(menu, action_filter)
    return True</t>
<t tx="michael.20060918131942">def get_last_code_item(self):
    try:
        editor = self.code_item.editor
        return [ci for ci in editor.code_items if is_project(ci) ][-1]
    except IndexError:
        return CResource(self.code_item).get_last_code_item()
</t>
<t tx="michael.20060918132012">def get_last_code_item(self):
    editor = self.code_item.editor
    try:
        return [ci for ci in editor.code_items if is_resource(ci) ][-1]
    except IndexError:
        return CImport(self.code_item).get_last_code_item()
</t>
<t tx="michael.20060918132238">def get_last_code_item(self):
    editor = self.code_item.editor
    try:
        return [ci for ci in editor.code_items if is_import(ci) ][-1]
    except IndexError:
        import wx
        wx.MessageBox("At least one import has to bei in the code!", "Error")
        return None</t>
<t tx="michael.20060918134452"></t>
<t tx="michael.20060918135024">class ResourceCreator(NameEditor):
    title = _("Create Resource")
    @others</t>
<t tx="michael.20060918135024.5">def realize_code(self):
    now = datetime.datetime.now().strftime("%x %H:%M:%S")
    code = 'class %s(Resource):\n"Inserted at %s"' % (self.name, now)
    context = self.context.__class__(self.context.get_last_code_item())
    context.append_item(code, 0)

</t>
<t tx="michael.20060918141622"></t>
<t tx="michael.20060918141622.1">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()


papersize = {\
         "Letter" : ( 612, 792 ),
         "Legal" : ( 612, 1008 ),
         "Tabloid" :  ( 792, 1224 ),
         "Ledger" :   ( 792, 1224 ),
         "Executive" :( 540, 720 ),
         "Monarch" :  ( 279, 540 ),
         "Statement" :( 396, 612 ),
         "Folio" :    ( 612, 936 ),
         "Quarto" :   ( 610, 780 ),
         "C5" :       ( 459, 649 ),
         "B4" :       ( 729, 1032 ),
         "B5" :       ( 516, 729 ),
         "Dl" :       ( 312, 624 ),
         "A0" :	      ( 2380, 3368 ),
         "A1" :	      ( 1684, 2380 ),
         "A2" :	      ( 1190, 1684 ),
         "A3" :	      ( 842, 1190 ),
         "A4" :       ( 595, 842 ),
         "A5" :	      ( 420, 595 ),
         "A6" :	      ( 297, 421 ),
         "custom" :   None }

paper_choices = dict(zip(papersize.keys(), papersize.keys()))
scale_choices = { "no_scale" : _("no scaling") }
scale_choices.update(paper_choices)



@others
</t>
<t tx="michael.20060918141622.2">import wx
import metapie
import metapie.dbtransient as db
import metapie.gui.views as views
import faces.charting.printer as prnt
import faces.charting.charts as charts
import faces.gui.patches as patches
import faces.plocale
import tempfile
import os
import os.path
import utils



</t>
<t tx="michael.20060918141622.3">class ChartPrinter(db.Model):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060918141622.4">filename = db.Text(none=True, default="")
unit = db.Enumerate({ 'cm' : _('cm'),
                      'mm' : _('mm'),
                      'inch' : _('inch'),
                      'point' : _('point'),
                      'pixel' : _('pixel') },
                    default="pixel")

scale = db.Enumerate(scale_choices, default="no_scale")
media = db.Enumerate(paper_choices, default="custom")
media_size = db.Text("test")
dpi = db.Int(default=72)
command = db.Text(multi_line=True)
edgecolor = db.Text(default="black")
linewidth = db.Float(1.0)
width = db.Float(width=7)
height = db.Float(width=7)
poster = db.Boolean()
print_out_number = 0

</t>
<t tx="michael.20060918141622.5">def __init__(self, printer):
    super(ChartPrinter, self).__init__()
    self.filename = None
    self.chart_name = printer._chart.__name__
    self.printer = printer
    self.printer.type = "eps"
    self.printer.unit = "mm"
    self.refresh()
    self.calc_command()
    self.attach_weak(self)
    self.calc_media_size()
</t>
<t tx="michael.20060918141622.6">def refresh(self):
    self.printer.refresh()
    self._chart_instance = self.printer._chart_instance
</t>
<t tx="michael.20060918141622.7">def reset_valid(self):
    if not self.printer.valid:
        self.printer._chart_instance = self._chart_instance
</t>
<t tx="michael.20060918141622.8">def __call__(self, attrib):
    if attrib != "command":
        self.calc_command()

    self._fire_others(attrib)

    if attrib in ("unit", "media", "width", "height"):
        self.calc_media_size()

    if attrib in ("unit", "dpi", "font_size"):
        #if the unit changes the size changes also
        self.fire("width", "width")
        self.fire("height", "height")
        return
</t>
<t tx="michael.20060918141622.9">def _fire_others(self, attrib):
    pass
</t>
<t tx="michael.20060918141622.10">def _get_filename(self, org):
    if org: return self.printer.filename
    return org
</t>
<t tx="michael.20060918141622.11">def _set_filename(self, value):
    if value:
        dpi = self.dpi
        self.printer.filename = value
        if dpi != self.dpi:
            self.dpi = self.dpi

    return value
</t>
<t tx="michael.20060918141622.12">def _get_unit(self, org):
    return self.printer.unit
</t>
<t tx="michael.20060918141622.13">def _set_unit(self, value):
    self.printer.unit = value
    return value
</t>
<t tx="michael.20060918141622.14">def _get_width(self, org):
    self.reset_valid()
    return self.printer.width
</t>
<t tx="michael.20060918141622.15">def _set_width(self, value):
    self.reset_valid()
    self.printer.width = value
    return value
</t>
<t tx="michael.20060918141622.16">def _get_height(self, org):
    self.reset_valid()
    return self.printer.get_height()
</t>
<t tx="michael.20060918141622.17">def _set_height(self, value):
    self.reset_valid()
    self.printer.height = value
</t>
<t tx="michael.20060918141622.18">def _get_dpi(self, org):
    self.reset_valid()
    return int(self.printer.dpi)
</t>
<t tx="michael.20060918141622.19">def _set_dpi(self, value):
    self.printer.dpi = value
    return self.printer.dpi
</t>
<t tx="michael.20060918141622.20">def calc_media_size(self):
    unit = self.unit
    if unit == "pixel": unit = "point"
    size = papersize.get(self.media)
    if not size:
        size = (self.width, self.height)
    else:
        point_factor = prnt.ChartPrinter._point_factor
        size = map(lambda s: s / point_factor[unit], size)

    if self.printer.width &lt; self.printer.height:
        w, h = size
    else:
        h, w = size

    self.media_size = "%0.2f x %0.2f %s" % (w, h, unit)

</t>
<t tx="michael.20060918141622.21">def calc_command(self):
    command = "printer = %s.printer()" % self.chart_name

    if self.filename is not None:
        command += '\nprinter.filename = "%s"' % self.filename

    command += '\nprinter.linewidth = %.2f' % self.linewidth
    command += '\nprinter.edgecolor = "%s"' % self.edgecolor
    command += '\nprinter.unit = "%s"' % self.unit

    if self.printer.type != "eps":
        command += '\nprinter.dpi = %i' % self.dpi

    command = self.add_command_attributes(command)

    if self.filename is not None:
        command += '\nprinter.save()'

    command += '\nprinter.end()'
    self.command = command.strip()
</t>
<t tx="michael.20060918141622.22">def add_command_attributes(self, command):
    return command
</t>
<t tx="michael.20060918141622.23">def check_constraints(self):
    error = db.ConstraintError()

    if self.filename: 
        for e in prnt.ChartPrinter._extensions:
            if self.filename.endswith(e): return
        else:
            error.message["filename"] = _("""File name must have one of the following extensions:
%s""") % str(prnt.ChartPrinter._extensions)

    elif self.poster and self.media == "custom":
        error.message["media"] = _("""For poster printing, you have to set
a standard output media""")

    if error.message:
        raise error
</t>
<t tx="michael.20060918141622.24">def save(self):
    self.printer.edgecolor = self.edgecolor
    self.printer.linewidth = self.linewidth

    if self.filename is None:
        tmpdir = tempfile.gettempdir()
        number = self.__class__.print_out_number
        self.__class__.print_out_number += 1

        #make shure the temp filename is an 8.3 name
        #poster doesn't like larger names under windows
        eps_path = os.path.join(tmpdir, "fpr%05i.eps" % number)
        self.printer.filename = eps_path
        self.printer.refresh()
        if self.printer.width &lt; self.printer.height:
            self.printer.orientation = "portrait"
        else:
            self.printer.orientation = "landscape"

        to_remove = metapie.controller().session.tmp_files_to_remove
        pdf_path = eps_path.replace(".eps", ".pdf")
        size = self.printer._figure.get_size_inches()

        if self.poster:
            to_remove.append(eps_path)
            self.printer.save()

            if self.scale == "no_scale":
                scale = "%.2fx%.2fi" % size
            else:
                scale = self.scale

            ps_path = eps_path.replace(".eps", ".ps")
            to_remove.append(ps_path)

            media = self.media
            if media == "custom":
                raise ValueError("media may not be custom")

            arguments = ("-p%s" % scale,
                         "-m%s" % media,
                         "-o%s" % ps_path,
                         eps_path)

            utils.call_command("poster", arguments,
                               "Poster",
                               "http://www.geocities.com/SiliconValley/5682/poster.html")

            self.call_ps2pdf(ps_path, pdf_path)
        else:
            to_remove.append(eps_path)
            self.printer.save()
            if self.media == "custom":
                args = ('-dDEVICEWIDTHPOINTS=%i' % (size[0] * 72),
                        '-dDEVICEHEIGHTPOINTS=%i' % (size[1] * 72),
                        '-dEPSFitPage')
            else:
                args = ('-sPAPERSIZE=%s' % self.media.lower(),)
            self.call_ps2pdf(eps_path, pdf_path, args)

            #the next two lines would be the easier an cleaner implementation
            #but the pdf_backend cannot handle unicode
            #self.printer.filename = pdf_path
            #self.printer.save()

        to_remove.append(pdf_path)

        import webbrowser
        webbrowser.open("file://%s" % pdf_path, True, False)
    else:
        self.printer.save()
</t>
<t tx="michael.20060918141622.25">def call_ps2pdf(self, input, output, args=()):
    arguments = ('-dCompatibilityLevel=1.4',
                 "-dQUIET",
                 '-dNOPAUSE',
                 '-dBATCH',
                 '-sDEVICE=pdfwrite',
                 '-sOutputFile=%s' % output,
                 '-c.setpdfwrite',
                 '-f%s' % input) + args
    utils.call_command("gs", arguments,
                       "Ghostscript",
                       "http://www.cs.wisc.edu/~ghost/doc/GPL/index.htm")
</t>
<t tx="michael.20060918141622.26">#different printers for the type of the widget_axes of the chart

class LimitsPrinter(ChartPrinter):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060918141622.27">xmin = db.Float(width=7)
xmax = db.Float(width=7)
ymin = db.Float(width=7)
ymax = db.Float(width=7)


</t>
<t tx="michael.20060918141622.28">def __init__(self, printer):
    super(LimitsPrinter, self).__init__(printer)
</t>
<t tx="michael.20060918141622.29">def zoom(self):
    self.printer.autoscale()
    self.fire("width", "width")
    self.fire("height", "height")
    self.fire("xmin", "xmin")
    self.fire("ymin", "ymin")
    self.fire("tmin", "tmin")
    self.fire("xmax", "xmax")
    self.fire("ymax", "ymax")
    self.fire("tmax", "tmax")
</t>
<t tx="michael.20060918141622.30">def _fire_others(self, attrib):
    super(LimitsPrinter, self)._fire_others(attrib)

    if attrib == "width":
        self.fire("xmin", "xmin")
        self.fire("xmax", "xmax")
        return

    if attrib == "height":
        self.fire("ymin", "ymin")
        self.fire("ymax", "ymax")
        return

    if attrib in ("unit", "dpi", "font_size"):
        self.fire("xmin", "xmin")
        self.fire("ymin", "ymin")
        self.fire("tmin", "tmin")
        self.fire("xmax", "xmax")
        self.fire("ymax", "ymax")
        self.fire("tmax", "tmax")
        return

    if attrib in ("xmin", "xmax"):
        self.fire("width", "width")
        return

    if attrib in ("ymin", "ymax"):
        self.fire("height", "height")
        return
</t>
<t tx="michael.20060918141622.31">def _set_xmin(self, value):
    self.printer.set_xlimits(xmin=value)
    return value
</t>
<t tx="michael.20060918141622.32">def _set_xmax(self, value):
    self.printer.set_xlimits(xmax=value)
    return value
</t>
<t tx="michael.20060918141622.33">def _set_ymin(self, value):
    self.printer.set_ylimits(ymin=value)
    return value
</t>
<t tx="michael.20060918141622.34">def _set_ymax(self, value):
    self.printer.set_ylimits(ymax=value)
    return value
</t>
<t tx="michael.20060918141622.35">def _get_xmin(self, value):
    self.reset_valid()
    return self.printer.get_xlimits()[0]
</t>
<t tx="michael.20060918141622.36">def _get_xmax(self, value):
    self.reset_valid()
    return self.printer.get_xlimits()[1]
</t>
<t tx="michael.20060918141622.37">def _get_ymin(self, value):
    self.reset_valid()
    return self.printer.get_ylimits()[0]
</t>
<t tx="michael.20060918141622.38">def _get_ymax(self, value):
    self.reset_valid()
    return self.printer.get_ylimits()[1]
</t>
<t tx="michael.20060918141622.39">def set_max_limits(self):
    self.printer.set_xlimits()
    self.printer.set_ylimits()
    self.y_limits.min, self.y_limits.max = self.printer.get_ylimits()
</t>
<t tx="michael.20060918141622.40">def add_command_attributes(self, command):
    command = super(LimitsPrinter, self).add_command_attributes(command)
    command += "\nprinter.set_xlimits(%.2f, %.2f)" % (self.xmin, self.xmax)
    command += "\nprinter.set_ylimits(%.2f, %.2f)" % (self.ymin, self.ymax)
    return command
</t>
<t tx="michael.20060918141622.41">class WidgetPrinter(LimitsPrinter):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060918141622.42">font_size = db.Int()

</t>
<t tx="michael.20060918141622.43">def _get_font_size(self, org):
    return self.printer.font_size
</t>
<t tx="michael.20060918141622.44">def _set_font_size(self, value):
    value = max(value, 2)
    self.printer.font_size = value
    self.refresh()
    return value
</t>
<t tx="michael.20060918141622.45">def add_command_attributes(self, command):
    command = super(WidgetPrinter, self).add_command_attributes(command)
    command += '\nprinter.fontsize = %i' % self.font_size
    return command
</t>
<t tx="michael.20060918141622.46">class TimePrinter(db.Model):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060918141622.47">tmin = db.DateTime()
tmax = db.DateTime()


</t>
<t tx="michael.20060918141622.48">def __init__(self, *args, **kwargs):
    super(TimePrinter, self).__init__(*args, **kwargs)
</t>
<t tx="michael.20060918141622.49">def _set_tmin(self, value):
    self.printer.set_time_limits(min=value)
    return value
</t>
<t tx="michael.20060918141622.50">def _set_tmax(self, value):
    self.printer.set_time_limits(max=value)
    return value
</t>
<t tx="michael.20060918141622.51">def _get_tmin(self, value):
    self.reset_valid()
    return self.printer.get_time_limits()[0]
</t>
<t tx="michael.20060918141622.52">def _get_tmax(self, value):
    self.reset_valid()
    return self.printer.get_time_limits()[1]
</t>
<t tx="michael.20060918141622.53">def add_command_attributes(self, command):
    command = super(TimePrinter, self).add_command_attributes(command)
    command += '\nprinter.width = %.2f' % self.width
    return command
</t>
<t tx="michael.20060918141622.54">class TimeWidgetPrinter(TimePrinter, WidgetPrinter, ChartPrinter):
	pass
</t>
<t tx="michael.20060918141622.55">class TimePlotPrinter(TimePrinter, LimitsPrinter):
	@others
</t>
<t tx="michael.20060918141622.56">def add_command_attributes(self, command):
    command = super(TimePlotPrinter, self).add_command_attributes(command)
    command += '\nprinter.height = %.2f' % self.height
    return command
</t>
<t tx="michael.20060918141622.57">class PointPrinter(WidgetPrinter, LimitsPrinter):
    pass

</t>
<t tx="michael.20060918141622.58">class PrinterView(views.FormView):
&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20060918141622.59">    __model__ = ChartPrinter
    __view_name__ = "default"

    format = _("""
[File: ]     |filename(SaveFile)&gt;
[Edgecolor: ]|edgecolor(Color)|[Linewidth: ]|linewidth
[Unit:]      |unit
%s
(canvas)&gt;
--
(cmd_or_print)&gt;
--
(buttons)&gt;
""")

    format_cmd_or_print = """
(Command)&gt;|(Printer)&gt;
"""

    format_Printer = _("""
[Printer:]
(0,0)            |poster[Print as Poster]
[Scale To Size: ]|scale
[Output Media: ] |media|media_size(Static)
""")

    format_Command = _("""
[Command:]
command&gt;
""")

    format_buttons = "btn_print{r}|btn_save{r}|(0,5)|btn_cancel"
    viewlimit = ""
    format_canvas = """
[Canvas Size:]
[ Size: ]      |(size)
[ Resolution:] |dpi|[ dpi]
"""

    format_size = "width|[ x ]|height|[ ]|unit"

</t>
<t tx="michael.20060918141622.60">def __init__(self, *args, **kwargs):
    self.format = self.format % self.viewlimit
    super(PrinterView, self).__init__(*args, **kwargs)
</t>
<t tx="michael.20060918141622.61">def create_buttons_controls(self, view):
    view.btn_print = view.get_button(wx.ID_PRINT)
    def prnt():
        if self.save(): self.imodel.save()
    view.btn_print.attach(prnt)
</t>
<t tx="michael.20060918141622.62">def prepare(self):
    self.grow_col(1)
    self.grow_row(-3)

    self.cmd_or_print.grow_col(0)
    self.cmd_or_print.grow_col(1)
    self.cmd_or_print.grow_row(0)

    self.cmd_or_print.Printer.grow_col(-1)
    self.cmd_or_print.Command.grow_col(0)
    self.cmd_or_print.Command.grow_row(1)

    self.buttons.grow_col(0)
    self.filename.set_filter(_("EPS (*.eps)|*.eps|"  \
                               "SVG (*.svg)|*.svg|"  \
                               "BMP (*.bmp)|*.bmp|"  \
                               "PNG (*.png)|*.png"))
    self.filename.set_width("X" * 20)
    self.canvas.dpi.set_width("8888")
    self.canvas.dpi.SetMaxLength(4)
    self.cmd_or_print.Command.command.set_height(6)
    self.cmd_or_print.Command.command.SetEditable(False)
    self._prepare_others()
</t>
<t tx="michael.20060918141622.63">def modify_subview(self, subview, name):
    if name in ("limits", "size"):
        subview.hgap = subview.vgap = 0

    return subview
</t>
<t tx="michael.20060918141622.64">def _prepare_others(self):
    pass
</t>
<t tx="michael.20060918141622.65">def button_cancel(self):
    self.rollback()
    self.GetParent().GetParent().EndModal(wx.ID_CANCEL)
</t>
<t tx="michael.20060918141622.66">def button_save(self):
    if self.save():
        self.imodel.save()
        self.GetParent().GetParent().EndModal(wx.ID_OK)
</t>
<t tx="michael.20060918141622.67">def make_size_int(self):
    self.canvas.size.width.SetFractionWidth(0)
    self.canvas.size.height.SetFractionWidth(0)
    self.canvas.size.layout()
</t>
<t tx="michael.20060918141622.68">def make_size_float(self):
    self.canvas.size.width.SetFractionWidth(2)
    self.canvas.size.height.SetFractionWidth(2)
    self.canvas.layout()
</t>
<t tx="michael.20060918141622.69">def state_changed(self, attrib):
    if attrib == "unit":
        if self.imodel.unit in ('pixel', 'mm', 'point'):
            self.make_size_int()
        else:
            self.make_size_float()
        return

    if attrib == "filename":
        value = self.imodel.filename

        if not value or value.endswith("ps"):
            self.canvas.dpi.Enable(False)
        else:
            self.canvas.dpi.Enable(True)

        if value is None:
            self.buttons.btn_save.Hide()
            self.cmd_or_print.Command.Hide()
            self.buttons.btn_print.Show()
            self.cmd_or_print.Printer.Show()
            self.cmd_or_print.ungrow_col(0)
            self.cmd_or_print.grow_col(1)
            self.cmd_or_print.Printer.layout()
        else:
            self.buttons.btn_save.Show()
            self.cmd_or_print.Command.Show()
            self.buttons.btn_print.Hide()
            self.cmd_or_print.Printer.Hide()
            self.cmd_or_print.ungrow_col(1)
            self.cmd_or_print.grow_col(0)
            self.cmd_or_print.Command.layout()

        self.buttons.layout()
        return

    if attrib == "poster":
        self.cmd_or_print.Printer.scale.Enable(self.imodel.poster)
</t>
<t tx="michael.20060918141622.70">def constitute(self, imodel):
    views.FormView.constitute(self, imodel)
    self.state_changed("filename")
    self.state_changed("unit")
    self.state_changed("poster")
</t>
<t tx="michael.20060918141622.71">class LimitsPrinterView(object):
    viewlimit = """
auto_scale&gt;
(viewlimit)&gt;
"""

    format_viewlimit = """
[View Limits:]
[Horizontal: ]|xmin|[ - ]|xmax
[Vertical: ]  |ymin|[ - ]|ymax|[]
--
"""

	@others
</t>
<t tx="michael.20060918141622.73">def _prepare_others(self):
    self.viewlimit.grow_col(-1)
    super(LimitsPrinterView, self)._prepare_others()
</t>
<t tx="michael.20060918141622.74">def create_controls(self):
    super(LimitsPrinterView, self).create_controls()
    self.auto_scale = self.get_button("Zoom To Extends")
    def zoom():
        self.imodel.zoom()

    self.auto_scale.attach(zoom)
</t>
<t tx="michael.20060918141622.75">class WidgetPrinterView(LimitsPrinterView):
    format_canvas = """
[Canvas Size:]
[Size: ]      |(size)
[Font size:]  |font_size|[  Resolution:] |dpi|[ dpi]
"""

    viewlimit = """
auto_scale&gt;
(viewlimit)&gt;"""

	@others
</t>
<t tx="michael.20060918141622.77">def _prepare_others(self):
    self.canvas.font_size.SetMaxLength(2)
    self.canvas.font_size.set_width("88")
    self.canvas.font_size.SetToolTipString(_("Size of standard font in Points"))
    super(WidgetPrinterView, self)._prepare_others()
</t>
<t tx="michael.20060918141622.78">class TimePrinterView(object):
    format_viewlimit = """
[View Limits:]
[Horizontal: ]|tmin|[ - ]|tmax
[Vertical: ]  |ymin|[ - ]|ymax
--
"""
</t>
<t tx="michael.20060918141622.80">class TimePlotPrinterView(TimePrinterView, LimitsPrinterView, PrinterView):
    __model__ = TimePlotPrinter
    __view_name__ = "default"    
</t>
<t tx="michael.20060918141622.82">class TimeWidgetPrinterView(TimePrinterView, WidgetPrinterView, PrinterView):
    __model__ = TimeWidgetPrinter
    __view_name__ = "default"    

</t>
<t tx="michael.20060918141622.84">class PointPrinterView(WidgetPrinterView, PrinterView):
    __model__ = PointPrinter
    __view_name__ = "default"    
</t>
<t tx="michael.20060918141622.86">class PrintChart(patches.PatchedDialog):
	@others
</t>
<t tx="michael.20060918141622.87">def __init__(self, parent, chart):
    wx.Dialog.__init__(self, parent, -1, _("Print Chart"),
                       style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)


    if isinstance(chart, charts.MatplotChart):
        try:
            axes = chart.widget_axes()
        except AttributeError:
            axes = chart.axes

        figure = axes.get_figure()
        kwargs = { "xlimits": axes.get_xlim(),
                   "ylimits": axes.get_ylim(),
                   "dpi": figure.get_dpi(),
                   "size": figure.get_size_inches(),
                   "type": "png" }
    else:
        kwargs = {}

    printer = chart.printer(**kwargs)

    if isinstance(printer, prnt.TimePlotPrinter):
        model = TimePlotPrinter

    elif isinstance(printer, prnt.TimeWidgetPrinter):
        model = TimeWidgetPrinter

    elif isinstance(printer, prnt.PointPrinter):
        model = PointPrinter

    else:
        model = ChartPrinter

    self.data = model(printer)
</t>
<t tx="michael.20060918141622.88">def simulate_modal(self, focused):
    container = views.ScrollViewContainer(self)
    view = self.data.constitute("default")(container)

    def resize():
        w, h = view.GetSize()
        container.SetClientSize((w + 10, h + 40))
        self.SetClientSize(container.GetSize())

    wx.CallAfter(resize)

    def end_dialog():
        self.data.printer.end()
        view.end_inspect()

    patches.PatchedDialog.simulate_modal(self, focused, end_dialog)
</t>
<t tx="michael.20060919144445">def _on_menu_open(self, event):
    menu = event.GetMenu()
    items = self.get_top_menu().items.values()

    for item in items:
        if item.wxobj == menu:
            title = item.title
            self.remove_temp_menus()
            for v in self.get_all_views():
                try:
                    v.on_make_menu(title)
                    break
                except AttributeError: pass
</t>
<t tx="michael.20060919150620">&lt;&lt; copy &amp; cut patch &gt;&gt;

menu(_("&amp;Undo\tCTRL-Z"), nrc(self.Undo), "undo16", pos=100)
menu(_("&amp;Redo\tCTRL-R"), nrc(self.Redo), "redo16", pos=200)
menu(_("Cut\tCTRL-X"), cut, "editcut16", pos=300)
menu(_("&amp;Copy\tCTRL-C"), nrc(copy), "editcopy16", pos=400)
menu(_("&amp;Paste\tCTRL-V"), nrc(self.Paste), "editpaste16", pos=500)
menu(_("Insert &amp;Date\tCTRL-D"), nrc(self.menu_insert_date), pos=550)
</t>
<t tx="michael.20060919150620.1">menu(_("Co&amp;mment\tCTRL-#"), self.menu_comment_selection, pos=600)
menu(_("&amp;Uncomment"), self.menu_uncomment_selection, pos=601)</t>
<t tx="michael.20060919150620.2">menu(_("&amp;Find\tCTRL-F"), self.menu_find_forward, "find16", pos=700)
menu(_("Find &amp;Backward\tCTRL-B"), self.menu_find_backward, pos=710)
menu(_("Replace"), self.menu_replace, pos=720)
menu(_("Goto &amp;Line\tCTRL-G"), self.menu_goto_line, pos=730)</t>
<t tx="michael.20060919150620.3">mb = menu(_("Start Macro Recording"), self.start_macro, pos=900)
ms = menu(_("Stop Macro Recording"), self.stop_macro, pos=901)
me = menu(_("Execute Macro\tCTRL-E"), self.execute_macro, pos=902)

self.menu_macro_start = mb
self.menu_macro_stop = ms
self.menu_macro_execute = me
if ctrl.macro:
    mb.enable(False)
    me.enable(False)
    ms.enable(True)
else:
    me.enable(bool(self.macro))
    mb.enable(True)
    ms.enable(False)</t>
<t tx="michael.20060919150620.4">def show_completion():
    wx.CallAfter(self.show_completion, True)

menu(_("Context..."), show_completion, pos=1010)</t>
<t tx="michael.20060919150620.5">def fmenu(level):
    def fold(): self.fold_to_level(level)
    fold_menu.make_item(owner,
                        _("To Level %i\tALT-%i") % (level, level),
                        fold)

map(fmenu, range(0, 10))</t>
<t tx="michael.20060919150620.6">edit_menu.make_separator(_("Co&amp;mment"), True)
edit_menu.make_separator(_("Toggle Bookmark"), True)
edit_menu.make_separator(_("Cut"), True)
edit_menu.make_separator(_("Find"), True)
edit_menu.make_separator(_("Fold"), True)
edit_menu.make_separator(_("Start Macro Recording"), True)</t>
<t tx="michael.20060919150828">help_menu.make_item(owner, _("Current Calltip\tCTRL-F1"),
                    self.show_call_tip, pos=10)</t>
<t tx="michael.20060919150828.1">try:
    main_buffer_editor = ctrl.session.main_buffer.editor
except AttributeError:
    main_buffer_editor = None

file_menu.make_item(owner, _("&amp;Create Snapshot..."),
    self.menu_snapshot, "stamp16", pos=45,
    help=_("Create a snapshot of the current project."))\
        .enable(main_buffer_editor is self.GetParent())</t>
<t tx="michael.20060919151956">def create_context_menu(self, menu, item):
    editor = self.GetParent().editor

    try:
        first_item = editor.code_items[0]
    except IndexError:
        #at least one code item has to be there
        return

    if item == self.imports:
        context.CImport(first_item).make_browser_menu(menu, ("create",))

    elif item == self.resources:
        context.CResource(first_item).make_browser_menu(menu, ("create",))

    elif item == self.tasks:
        context.CProjectDeclaration(first_item).make_browser_menu(menu, ("create",))

    elif item == self.evaluations:
        context.CEvaluation(first_item).make_browser_menu(menu, ("create",))

    elif item == self.observers:
        context.CObserver(first_item).make_browser_menu(menu, ("create",))

    else:
        code_item = self.GetPyData(item)
        action_filter = ("add", "edit", "extra")

        for c in context.Context.context_list:
            c = c.__class__(code_item)
            if c.make_browser_menu(menu, action_filter):
                break

        if is_project(code_item):
            self.append_display_eval_data_menu(code_item, item, menu)
</t>
<t tx="michael.20060919153708">project_menu = top.make_menu(_("&amp;Project"), pos=110)
project_menu.make_item(owner, _("Correct Code"), self.correct_code, pos=100, 
                       help=_("Tries to resolve broken references and renamed items"))
project_menu.make_separator(_("Correct Code"))</t>
<t tx="michael.20060919173141">def get_editors(self):
    return self.editors</t>
<t tx="michael.20060919173141.1">    @others</t>
<t tx="michael.20060919173151">def amend_browser_menu(self, menu, action_filter=None):
    code_item = self.code_item
    existing_attribs = code_item.editor.get_attribs(code_item)
    editors = self.get_editors()

    toadd = []
    toedit = []
    extra = []
    for pe in editors.iteritems():
        action = pe[1].apply_browser_menu(existing_attribs, code_item)
        if action_filter and action not in action_filter: continue
        if action == "add": toadd.append(pe)
        elif action == "edit": toedit.append(pe)
        elif action in ("extra", "create"): extra.append(pe)

    if extra:
        create_editor_menu(menu, self, extra)

    if toadd:
        &lt;&lt; insert "Add Attributes" menu &gt;&gt;

    if toedit:
        &lt;&lt; insert "Edit Attributes" menu &gt;&gt;
        &lt;&lt; insert "Remove Attributes" menu &gt;&gt;

</t>
<t tx="michael.20060919173151.1">add = menu.make_menu(_("Add Attributes"))
create_editor_menu(add, self, toadd)</t>
<t tx="michael.20060919173151.2">edit = menu.make_menu(_("Edit Attributes"))
create_editor_menu(edit, self, toedit)</t>
<t tx="michael.20060919173151.3">remove = menu.make_menu(_("Remove Attributes"))
editor = code_item.editor
def create_remove(line):
    def remove_attrib(): editor.replace_expression("", line, True)
    return remove_attrib

for p, edit in toedit:
    try:
        attrib = edit.attrib_name
        line = existing_attribs[attrib]
        remove.make_temp_item(attrib, create_remove(line))
    except KeyError:
        pass</t>
<t tx="michael.20060919202707">def on_make_menu(self, menu_title):
    if menu_title == _("&amp;Project"):
        top = controller().get_top_menu()
        project_menu = top.make_menu(_("&amp;Project"), pos=110)
        item = self.GetSelection()
        if item.IsOk():
            self.create_context_menu(project_menu, item)</t>
<t tx="michael.20060921000959">def append_display_eval_data_menu(self, code_item, item, menu):
    session = controller().session
    editor = self.GetParent().editor

    try:
        id_ = code_item.obj._idendity_()
    except AttributeError: return

    evals = [ (k, v) for k, v in session.evaluations.items() 
              if v._idendity_() == id_ ]
    if not evals: return

    displayed_eval_name = self.displayed_eval_map.get(id_)
    show_menu = menu.make_menu(_("&amp;Displayed Evaluation Data"))
    menu.make_separator(_("&amp;Displayed Evaluation Data"), True)

    def change_data_call(varname):
        def change_data(): 
            self.displayed_eval_map[id_] = varname
            self.idle_item = item

        return change_data

    for varname, eval in evals:
        check_item = False
        try:
            if displayed_eval_name == varname:
                check_item = True
        except AttributeError: pass

        mi = show_menu.make_temp_item(varname, 
                                      change_data_call(varname),
                                      check_item=check_item)
        if check_item: mi.check()
</t>
<t tx="michael.20060921011201"></t>
<t tx="michael.20060921012719">class SingletonEditor(db.Model, context.ItemEditor):
    title = ""

    @others</t>
<t tx="michael.20060921012719.1">class TaskRenamer(RenameEditor):
    title = _("Rename Task")
    __icon__ = "rename16"

    def correct_code(self, editor):
        editor.correct_task_code(self.context.code_item)</t>
<t tx="michael.20060921012812">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060921012921">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060921013128">def activate(self, context):
    """
    activates the editor.
    """
    if controller().is_processing(): return

    self.context = context
    self.init_attributes()
    dlg = editorlib.PatchedDialog(controller().frame,  -1, self.title,
            style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)

    dlg.SetClientSize((10, 10))
    view = self.constitute()(dlg)
    view.layout()
    dlg.simulate_modal(context.code_item.editor)
    return self
</t>
<t tx="michael.20060921013128.1">def init_attributes(self):
    raise RuntimeError("abstract")</t>
<t tx="michael.20060921013326"></t>
<t tx="michael.20060921013326.1"></t>
<t tx="michael.20060921013326.2">def cancel(self):
    del self.context
    self.detach_all()</t>
<t tx="michael.20060921013326.3"></t>
<t tx="michael.20060921135700">def get_display_eval_data(self, task):
    id_ = task.root._idendity_()
    evaluations = controller().session.evaluations
    try:
        eval_name = self.displayed_eval_map[id_]
        try:
            return evaluations[eval_name].get_task(task.path)
        except KeyError:
            del self.displayed_eval_map[id_]
    except KeyError: pass

    evaluations = evaluations.items()
    evaluations.sort()

    for varname, eval in evaluations:
        if eval._idendity_() == id_: 
            self.displayed_eval_map[id_] = varname
            return eval.get_task(task.path) or task

    return task</t>
<t tx="michael.20060921144552.1">class ResourceRenamer(RenameEditor):
    title = _("Rename Resource")
    __icon__ = "rename16"

    def correct_code(self, editor):
        editor.correct_resource_code(self.context.code_item)
</t>
<t tx="michael.20060921144959">def realize(self):
    self.realize_code()
    del self.context
    self.detach_all()</t>
<t tx="michael.20060921225151">registry = context.CObserver.editors
registry["Observer/Create...(100)"] = ObserverCreator()
registry["Observer/Rename...(110)"] = ObserverRenamer()
registry["Observer/Remove(120)"] = ObserverRemover()


</t>
<t tx="michael.20060921225322"></t>
<t tx="michael.20060921225442">class NameEditor(SingletonEditor):
    name = db.Text()
    @others</t>
<t tx="michael.20060921225442.1">def apply_browser_menu(self, existing_attribs, code_item):
    return "create"
</t>
<t tx="michael.20060921225442.2">def init_attributes(self):
    self.name = ""</t>
<t tx="michael.20060921225442.3">def check_constraints(self):
    if not reg_identifier.match(self.name):
        error = db.ConstraintError()    
        error.message["name"] = _("Name is not a valid identifier")
        raise error</t>
<t tx="michael.20060921225442.4">def realize_code(self):
    raise RuntimeError("abstract")

</t>
<t tx="michael.20060921225700">class NameEditorView(editorlib.MainView):
    __model__ = NameEditor
    __view_name__ = "default"

    format = _("""
[Name: ]|name&gt;
--&gt;
(buttons)&gt;
""")

    def prepare(self):
        self.grow_col(-1)
        self.grow_row(1)
        self.buttons.grow_col(0)
        self.name.set_width("X"*30)</t>
<t tx="michael.20060921230035">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060921230339">class ObserverRenamer(RenameEditor):
    title = _("Rename Observer")
    __icon__ = "rename16"
    
    def correct_code(self, editor):
        pass
    
</t>
<t tx="michael.20060921230629">class RenameEditor(NameEditor):
    @others
</t>
<t tx="michael.20060921230629.1">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060921230629.2">def init_attributes(self):
    self.name = self.context.code_item.name
</t>
<t tx="michael.20060921230629.3">def realize_code(self):
    code_item = self.context.code_item
    editor = code_item.editor
    editor.BeginUndoAction()
    code_item.rename(self.name)
    self.correct_code(editor)
    editor.EndUndoAction()

</t>
<t tx="michael.20060923124429">@doc
returns the code_item, the found line, and the start and end position
@code
def find_resource_references(self, resource_name):
    for ci in self.code_items:
        if is_task(ci) or is_project(ci):
            try:
                line = self.get_attribs(ci)["resource"]
            except KeyError: continue

            start, end = self.get_expression_range(line)
            try:
                self.GetTextRange(start, end).index(resource_name)
                yield ci, line, start, end
            except ValueError: pass

</t>
<t tx="michael.20060923124429.1">@doc
code_item has to be a reference on a task
@code
def find_task_references(self, code_item):
    try:
        task = code_item.obj
    except AttributeError: return

    #tasks and tasks children dependencies
    dependencies = reduce(lambda a, b: a + b, 
                          [ t._dependencies.values() for t in task ])

    for path_attrib_map in dependencies:
        for path_attrib in path_attrib_map.iterkeys():        
            path, attrib = ftask._split_path(path_attrib)
            dst = task.get_task(path)

            try:
                dst_item = dst._function.code_item
            except AttributeError: continue
            except weakref.ReferenceError: continue

            try:
                line = self.get_attribs(dst_item)[attrib]
            except KeyError: continue

            yield dst_item, attrib, line
</t>
<t tx="michael.20060923134450">class ReferencePrinter(object):
    __icon__ = "list16"

    @others</t>
<t tx="michael.20060923134450.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060923134450.2">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060923134450.3">def activate(self, context):
    print_resource_references(context.code_item)
</t>
<t tx="michael.20060923134450.4">def get_planbuffers(self):
    models = self.id_to_model.values()
    for m in models:
        if isinstance(m, PlanBuffer):
            yield m</t>
<t tx="michael.20060923140956">class TaskReferencePrinter(object):
    __icon__ = "list16"

    @others
</t>
<t tx="michael.20060923140956.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060923140956.2">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060923140956.3">def activate(self, context):
    print_task_references(context.code_item)
</t>
<t tx="michael.20060923141119">self.show_object = self.editor.show_object
self.sync_text = self.editor.sync_text
self.refresh = self.editor.refresh
self.find_resource_references = self.editor.find_resource_references
self.find_task_references = self.editor.find_task_references
self.get_module = self.editor.get_module</t>
<t tx="michael.20060923154026">attribs = self.get_attribs(code_item)
for attrib, source_path_attribs in task._sources.iteritems():
    try:
        line = attribs[attrib]
    except KeyError: continue

    expr = self.get_expression(line)

    for path_attrib in source_path_attribs:
        spath, attrib = ftask._split_path(path_attrib)
        stask = task.get_task(spath)

        try:
            sitem = stask._function.code_item
        except AttributeError: continue
        except weakref.ReferenceError: continue

        spath = get_code_item_path(sitem)
        rel_path = ftask.create_relative_path(path, spath)
        old_rel_path = ftask.create_relative_path(old_path, spath)
        expr = expr.replace(old_rel_path, rel_path)

    expr = "\n".join([s.strip() for s in expr.split("\n")]) #strip each line
    self.replace_expression(expr, line, move_cursor=False)
</t>
<t tx="michael.20060923154026.1">for dst_item, attrib, line in self.find_task_references(code_item):
    dst_path = get_code_item_path(dst_item)
    expr = self.get_expression(line)

    rel_path = ftask.create_relative_path(dst_path, path)
    old_rel_path = ftask.create_relative_path(dst_path, old_path)
    expr = expr.replace(old_rel_path, rel_path)
    expr = expr.replace(old_path, path)
    expr = "\n".join([s.strip() for s in expr.split("\n")]) #strip each line
    self.replace_expression(expr, line, move_cursor=False)
</t>
<t tx="michael.20060923160547">def print_resource_references(code_item, outstream=None):
    outstream = outstream or sys.stdout
    rname = code_item.name
    print &gt;&gt; outstream, _('The following lines reference the resource "%s":') % rname
    for m in controller().get_planbuffers():
        for ci, line, start, end in m.editor.find_resource_references(rname):
            print &gt;&gt; outstream, _('   object: "%s", File "%s", line %i') % (ci.name, m.path, line + 1)

    print &gt;&gt; outstream</t>
<t tx="michael.20060923160547.1">class ResourceRemover(object):
    __icon__ = "delete16"

    @others
</t>
<t tx="michael.20060923160547.2">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060923160547.3">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060923160547.4">def activate(self, context):
    references = False
    code_item = context.code_item
    rname = code_item.name
    for m in controller().get_planbuffers():
        if list(m.editor.find_resource_references(rname)):
            references = True
            break

    if references:
        print_resource_references(context.code_item, sys.stderr)
        print &gt;&gt; sys.stderr, _("You have to remove those references before removing the resource!\n")
    else:
        code_item.remove()
</t>
<t tx="michael.20060923161713">def print_task_references(code_item, outstream=None):
    outstream = outstream or sys.stdout
    tname = code_item.name
    print &gt;&gt; outstream, _('The following lines reference the task "%s":') % tname
    find_references = code_item.editor.find_task_references
    for ci, attrib, line in find_references(code_item):
        print &gt;&gt; outstream, '   task attribute: "%s.%s", File "%s", line %i' \
            % (ci.name, attrib, ci.editor.model.path, line + 1)

    print &gt;&gt; outstream</t>
<t tx="michael.20060923162103">class TaskRemover(object):
    __icon__ = "delete16"

    @others
</t>
<t tx="michael.20060923162103.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060923162103.2">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060923162103.3">def activate(self, context):
    code_item = context.code_item
    editor = code_item.editor

    if list(editor.find_task_references(code_item)):
        print_task_references(context.code_item, sys.stderr)
        print &gt;&gt; sys.stderr, _("You have to remove those references before removing the task!\n")
    else:
        code_item.remove()
</t>
<t tx="michael.20060927165817">def _on_change(self, event):
    editor = self.GetParent().editor

    &lt;&lt; define internal insert function &gt;&gt;
    &lt;&lt; split and sort changed items list &gt;&gt;

    for l, code_item in removed:
        &lt;&lt; remove item &gt;&gt;

    for l, code_item in inserted:
        &lt;&lt; insert item &gt;&gt;

    for l, code_item in changed:
        &lt;&lt; change item &gt;&gt;

    if self.idle_item:
        self.idle_item = self.imports
</t>
<t tx="michael.20060927165817.1">def insert(item):
    prev, next = editor.code_items_near(item.get_line() - 1)

    def get_parent(item):
        parent = self.GetItemParent(item.tree_obj)
        return self.GetPyData(parent)

    parent = prev
    prev = None

    while parent and not parent.is_parent(item):
        prev = parent
        parent = get_parent(parent)

    if not parent: 
        parent = self.get_section(item)
        prev = None
    else: 
        parent = parent.tree_obj

    if prev:
        child = self.InsertItem(parent, prev.tree_obj, item.name)
    else:
        child = self.PrependItem(parent, item.name)

    item.tree_obj = child
    self.SetPyData(child, item)
    self.modify_item(child)</t>
<t tx="michael.20060927171146">def bind_events(self):
    editor = self.GetParent().editor
    self.Bind(wx.EVT_TREE_SEL_CHANGED, self._on_sel_changed)
    self.Bind(wx.EVT_TREE_ITEM_EXPANDED, self._on_refresh)
    self.Bind(wx.EVT_TREE_ITEM_COLLAPSED, self._on_refresh)
    self.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self._on_right_click)
    self.Bind(wx.EVT_SIZE, self._on_size)
    self.Bind(wx.EVT_IDLE, self._on_idle)
    self.Bind(wx.EVT_TREE_BEGIN_DRAG, self._on_begin_drag)
    editor.Bind(pyeditor.EVT_CODE_ITEM_CHANGED, self._on_change)
</t>
<t tx="michael.20060927174723">registry = context.CEvaluation.editors
registry[_("Evaluation/Create Project...(1000)")] = ProjectCreator()
registry[_("Evaluation/Create BalancedProject...(1010)")] = BalancedProjectCreator()
registry[_("Evaluation/Create AdjustedProject...(1020)")] = AdjustedProjectCreator()
registry[_("Evaluation/Edit...(1000)")] = ProjectEditor()
registry[_("Evaluation/Edit...(1001)")] = BalancedProjectEditor()
registry[_("Evaluation/Edit...(1002)")] = AdjustedProjectEditor()
registry[_("Evaluation/Show References...(1900)")] = EvaluationReferencePrinter()
registry[_("Evaluation/Remove...(1020)")] = EvaluationRemover()

registry = context.CImport.editors
registry[_("Import/Remove...(1020)")] = ImportRemover()
registry[_("Import/Import Gantt Charts(100)")] = ImportCreator("import faces.lib.gantt as gantt")
registry[_("Import/Import Workbreakdown Charts(110)")] = ImportCreator("import faces.lib.workbreakdown as workbreakdown")
registry[_("Import/Import Resource Charts(120)")] = ImportCreator("import faces.lib.resource as resource_charts")
registry[_("Import/Import Reports(130)")] = ImportCreator("import faces.lib.report as report")

del registry

</t>
<t tx="michael.20060927185257">self.project_map = {}
editor = imodel.context.code_item.editor
module = editor.get_module()
ismodule = inspect.ismodule
val_name_map = dict([ (v, k) for k, v in module.__dict__.iteritems() 
                      if ismodule(v)])

for m in controller().get_planbuffers():
    if editor.model.path != m.path:
        import_module = m.editor.get_module()
        try:
            # get modules import name            
            prefix = val_name_map[import_module] + "."
        except KeyError:
            continue
    else:
        prefix = ""

    for item in m.editor.editor.code_items:
        if item.indent == 0 \
            and item.obj_type == pyeditor.FUNCTION \
            and not item.get_args():
            try:
                if not isinstance(item.obj, ftask._ProjectBase): continue
            except AttributeError: pass
            self.project_map[prefix + item.name] = item

projects = self.project_map.keys()
projects.sort()
self.project.Clear()
for p in projects:
    self.project.Append(p)</t>
<t tx="michael.20060927190516">class ProjectCreator(SingletonEditor):
    name = db.Text()
    scenario = db.Text()
    id = db.Text()
    project = db.Text()
    title = _("Create Project")

    @others
</t>
<t tx="michael.20060927190516.1">class ProjectView(editorlib.MainView):
    __model__ = ProjectCreator
    __view_name__ = "default"

    format = _("""
[Project: ] |project(Combo)&gt;
[Scenario: ]|scenario(Combo)&gt;
[Name: ]    |name&gt;
[Id: ]      |id&gt;
--&gt;
(buttons)&gt;
""")

    @others</t>
<t tx="michael.20060927192936">def apply_browser_menu(self, existing_attribs, code_item):
    return "create"</t>
<t tx="michael.20060927192936.1">def init_attributes(self):
    self.scenario = "_default"
    self.project = ""
    self.name = ""
    self.id = ""

</t>
<t tx="michael.20060927193132"></t>
<t tx="michael.20060927193132.1">def _construct_name(self, project=None, scenario=None):
    project = project or self.project
    scenario = scenario or self.scenario
    if scenario == "_default": scenario = "default"
    if not project: return ""
    return "%s.%s" % (project, scenario)</t>
<t tx="michael.20060927193132.2">def _set_project(self, value):
    if not self.name or self.name == self._construct_name():
        self.name = self._construct_name(project=value)

    if self.id == self.project or not self.id:
        self.id = value

    return value
</t>
<t tx="michael.20060927193132.3">def _set_scenario(self, value):
    if not self.name or self.name == self._construct_name():
        self.name = self._construct_name(scenario=value)

    return value</t>
<t tx="michael.20060927193132.5">def check_constraints(self):
    error = db.ConstraintError()
    if not reg_path.match(self.name):
        error.message["name"] = _("Name is not a valid identifier")

    if not reg_path.match(self.project):
        error.message["project"] = _("project is not a valid identifier")

    if not reg_identifier.match(self.id):
        error.message["id"] = _("id is not a valid identifier")

    if error.message:
        raise error</t>
<t tx="michael.20060927193132.6">def realize_code(self):
    code = str(self)
    context = self.context.__class__(self.context.get_last_code_item())
    context.append_item(code, 0, prespace="\n")</t>
<t tx="michael.20060927203751">def prepare(self):
    self.grow_col(-1)
    self.grow_row(-2)
    self.buttons.grow_col(0)</t>
<t tx="michael.20060927203751.1">def constitute(self, imodel):
    super(ProjectView, self).constitute(imodel)

    &lt;&lt; fill project combo &gt;&gt;

    self.scenario.Clear()
    self.scenario.Append("_default")</t>
<t tx="michael.20060927203751.2">def state_changed(self, attrib):
    if attrib == "project":
        self.scenario.Clear()
        try:
            item = self.project_map[self.imodel.project]
        except KeyError:
            self.scenario.Append("_default")
        else:
            try:
                all_scenarios = list(item.obj.all_scenarios)
            except AttributeError:
                self.scenario.Append("_default")
            else:
                all_scenarios.sort()
                for s in all_scenarios:
                    self.scenario.Append(s)</t>
<t tx="michael.20060927203751.3">class BalancedProjectCreator(ProjectCreator):
    balance = db.Enumerate(ftask._allocator_strings)
    performed = db.Text()
    title = _("Create BalancedProject")

    @others</t>
<t tx="michael.20060927204614">def check_constraints(self):
    try:
        super(BalancedProjectCreator, self).check_constraints()
    except db.ConstraintError, error:
        pass
    else:
        error = db.ConstraintError()

    if self.performed and not reg_path.match(self.performed):
        error.message["performed"] = _("performed is not a valid identifier")

    if error.message:
        raise error</t>
<t tx="michael.20060927204614.1">class BalancedProjectView(ProjectView):
    __model__ = BalancedProjectCreator
    __view_name__ = "default"

    format = _("""
[Project: ]  |project(Combo)&gt;
[Scenario: ] |scenario(Combo)&gt;
[Name: ]     |name&gt;
[Balance: ]  |balance
[Id: ]       |id&gt;
[Performed: ]|performed&gt;
--&gt;
(buttons)&gt;
""")
</t>
<t tx="michael.20060927204924">def __str__(self):
    balance = ftask._allocator_strings[self.balance]
    if self.performed:
        return '%s = BalancedProject(%s, "%s", "%s", %s, %s)' \
                % (self.name, self.project, self.scenario, 
                   self.id, balance, self.performed)
    else:
        return '%s = BalancedProject(%s, "%s", "%s", %s)' \
                % (self.name, self.project, self.scenario, 
                   self.id, balance)

</t>
<t tx="michael.20060927205317">class ProjectEditor(ProjectEditorMixin, ProjectCreator):
    title = _("Edit Project")

    @others</t>
<t tx="michael.20060927211426">class ProjectEditorMixin(object):
    __icon__ = "edit16"

    @others

</t>
<t tx="michael.20060927211706">def apply_browser_menu(self, existing_attribs, code_item):
    if classifiers.is_evaluation(code_item): 
        expr = code_item.editor.get_expression(code_item.get_line())
        if re.search(r"\WProject\W", expr): return "extra"
    return ""</t>
<t tx="michael.20060927211820">class BalancedProjectEditor(ProjectEditorMixin, BalancedProjectCreator):
    title = _("Edit BalancedProject")
    @others</t>
<t tx="michael.20060927211820.1">def init_attributes(self):
    obj = super(BalancedProjectEditor, self).init_attributes()
    if obj:
        self.balance = obj.balance
    else:
        self.balance = ftask.SMART

    self.performed = ""
    args = self.context.code_item.get_args()
    try:
        self.performed = args[4]
    except IndexError:
        for a in args:
            if a.startswith("performed"):
                self.performed = a.split("=")[-1].strip()
                break
</t>
<t tx="michael.20060927212238">def init_attributes(self):
    super(BalancedProjectCreator, self).init_attributes()
    self.balancing = ftask.SMART
    self.performed = ""
</t>
<t tx="michael.20060929085858">def init_attributes(self):
    code_item = self.context.code_item
    self.name = code_item.name

    editor = code_item.editor
    expr = editor.get_expression(code_item.get_line())
    dict = editor.eval_expression(expr, context=self.context)

    try:
        module = editor.get_module()
        obj = eval("module.%s" % code_item.name)
    except AttributeError:
        try:
            obj = dict[code_item.name]
        except KeyError:
            obj = None


    if obj:
        self.scenario = obj.scenario
        self.project = obj._function.__name__
        self.id = obj.id
    else:
        self.scenario = "_default"
        self.project = ""

    return obj

</t>
<t tx="michael.20060929085928">def apply_browser_menu(self, existing_attribs, code_item):
    if classifiers.is_evaluation(code_item): 
        expr = code_item.editor.get_expression(code_item.get_line())
        if re.search(r"\WBalancedProject\W", expr): return "extra"
    return ""</t>
<t tx="michael.20060929093150">def __str__(self):
    return '%s = Project(%s, "%s", "%s")' \
            % (self.name, self.project, self.scenario, self.id)
</t>
<t tx="michael.20060929093303">def realize_code(self):
    code = str(self)
    code_item = self.context.code_item
    editor = code_item.editor
    editor.BeginUndoAction()
    if code_item.name != self.name:
        #name has changed ==&gt; change the name in all references
        old_name = code_item.name

        iterator = editor.find_evaluation_references(code_item)
        refs = dict([ (line, ci) for ci, line in iterator ])
        for line in refs.keys():
            start = editor.PositionFromLine(line)
            end = editor.GetLineEndPosition(line)
            editor.SetTargetStart(start)
            editor.SetTargetEnd(end)
            text = editor.GetTextRange(start, end)
            editor.ReplaceTarget(text.replace(old_name, self.name))

    code_item.editor.replace_expression(code, code_item.get_line())

    editor.EndUndoAction()
</t>
<t tx="michael.20060929093536"></t>
<t tx="michael.20060929093536.1">def _set_project(self, value):
    return value</t>
<t tx="michael.20060929093536.2">def _set_scenario(self, value):
    return value</t>
<t tx="michael.20060929220600">#scincilla has to format the text before we can correctly autoindent
self.Colourise(start, start + len(text))
self.SetLineIndentation(start_line, start_indent)
line = start_line
for line, line_text in enumerate(lines[1:]):
    line += start_line + 1
    self.autoindent(self.PositionFromLine(line), False)</t>
<t tx="michael.20060929220600.2">#scincilla has to format the text before we can correctly autoindent
self.Colourise(start, start + len(text))
for line, line_text in enumerate(lines):
    line += start_line
    self.autoindent(self.PositionFromLine(line), False)</t>
<t tx="michael.20060929224036">class AdjustedProjectCreator(SingletonEditor):
    name = db.Text()
    base = db.Text()
    title = _("Create AdjustedProject")

    @others
</t>
<t tx="michael.20060929225058">def apply_browser_menu(self, existing_attribs, code_item):
    return "create"</t>
<t tx="michael.20060929225128">def init_attributes(self):
    self.scenario = "_default"
    self.project = ""
    self.name = ""
    self.id = ""

    #code_item = self.context.code_item
    #if classifiers.is_evaluation(code_item):


</t>
<t tx="michael.20060929225233">def realize_code(self):
    code = str(self)
    context = self.context.__class__(self.context.get_last_code_item())
    context.append_item(code, 0, prespace="\n")</t>
<t tx="michael.20060929230703">class AdjustedProjectView(editorlib.MainView):
    __model__ = AdjustedProjectCreator
    __view_name__ = "default"

    format = _("""
[Name: ]            |name&gt;
[Base Evaluation: ] |base(Combo)&gt;
--&gt;
(buttons)&gt;
""")

    @others</t>
<t tx="michael.20060929230703.1">def prepare(self):
    self.grow_col(-1)
    self.grow_row(-2)
    self.buttons.grow_col(0)</t>
<t tx="michael.20060929230703.2">def constitute(self, imodel):
    super(AdjustedProjectView, self).constitute(imodel)

    &lt;&lt; fill base combo &gt;&gt;
</t>
<t tx="michael.20060929230703.3">balanced_projects = []
editor = imodel.context.code_item.editor
module = editor.get_module()
ismodule = inspect.ismodule
val_name_map = dict([ (v, k) for k, v in module.__dict__.iteritems() 
                      if ismodule(v)])


for m in controller().get_planbuffers():
    if editor.model.path != m.path:
        import_module = m.editor.get_module()
        try:
            # get modules import name
            prefix = val_name_map[import_module] + "."
        except KeyError:
            continue
    else:
        prefix = ""

    for item in m.editor.editor.code_items:
        if item.obj_type == classifiers.EVALUATION:
            expr = m.editor.editor.get_expression(item.get_line())
            try:
                expr.index("BalancedProject")
            except ValueError:
                continue
            else:
                balanced_projects.append(prefix + item.name)

balanced_projects.sort()
self.base.Clear()
for p in balanced_projects:
    self.base.Append(p)</t>
<t tx="michael.20060929231103">def __str__(self):
    return '%s = AdjustedProject(%s)' % (self.name, self.base)
</t>
<t tx="michael.20060929231203">def check_constraints(self):
    error = db.ConstraintError()
    if not reg_path.match(self.name):
        error.message["name"] = _("Name is not a valid identifier")

    if not reg_path.match(self.base):
        error.message["base"] = _("base is not a valid identifier")

    if error.message:
        raise error</t>
<t tx="michael.20060929231329">class AdjustedProjectEditor(AdjustedProjectCreator):
    title = _("Edit AdjustedProject")    
    __icon__ = "edit16"

    @others
</t>
<t tx="michael.20060929231415">def apply_browser_menu(self, existing_attribs, code_item):
    if classifiers.is_evaluation(code_item): 
        expr = code_item.editor.get_expression(code_item.get_line())
        if re.search(r"\WAdjustedProject\W", expr): return "extra"
    return ""</t>
<t tx="michael.20060929231534">def init_attributes(self):
    self.name = self.context.code_item.name
    try:
        self.base = self.context.code_item.get_args()[0]
    except IndexError:
        self.base = 0
</t>
<t tx="michael.20060929232917">@doc
returns the code_item and the found line
@code
def find_evaluation_references(self, code_item):
    evaluation_name = code_item.name
    start = self.PositionFromLine(code_item.get_line() + 1)
    end = self.GetLength()
    while True:
        start = self.FindText(start, end, evaluation_name, \
                              wx.stc.STC_FIND_MATCHCASE\
                              |wx.stc.STC_FIND_WHOLEWORD)
        if start &lt; 0: break
        line = self.LineFromPosition(start)
        start += 1
        text = self.GetLine(line)
        try:
            #comments are no references
            if text.index("#") &lt; text.index(evaluation_name): continue
        except ValueError: pass

        yield self.code_item_at(line), line


</t>
<t tx="michael.20060929233107">def print_evaluation_references(code_item, outstream=None):
    outstream = outstream or sys.stdout
    ename = code_item.name
    m = code_item.editor.model
    print &gt;&gt; outstream, _('The following lines reference to "%s":') % ename
    for ci, line, in code_item.editor.find_evaluation_references(code_item):
        print &gt;&gt; outstream, _('   object: "%s", File "%s", line %i') % (str(ci), m.path, line + 1)

    print &gt;&gt; outstream</t>
<t tx="michael.20060929233300">class EvaluationReferencePrinter(object):
    __icon__ = "list16"

    @others
</t>
<t tx="michael.20060929233300.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060929233300.2">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060929233300.3">def activate(self, context):
    print_evaluation_references(context.code_item)
</t>
<t tx="michael.20060929234312">class EvaluationRemover(object):
    __icon__ = "delete16"

    @others</t>
<t tx="michael.20060929234312.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060929234312.2">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060929234312.3">def activate(self, context):
    code_item = context.code_item

    if list(code_item.editor.find_evaluation_references(code_item)):
        print_evaluation_references(context.code_item, sys.stderr)
        print &gt;&gt; sys.stderr, _("You have to remove those references before removing the evaluation!\n")
    else:
        code_item.remove()
</t>
<t tx="michael.20060930013205">instrumentation_cache = {}
balancing_cache = {}

def clear_cache():
    instrumentation_cache.clear()
    balancing_cache.clear()</t>
<t tx="michael.20060930032329">def _clean_up_dragging(self, e=None):
    self.ReleaseMouse()
    self.SetCursor(wx.NullCursor)

    self.Unbind(wx.EVT_KEY_DOWN)
    self.Unbind(wx.EVT_RIGHT_DOWN)
    self.Unbind(wx.EVT_LEFT_UP)
    self.drag_item = None


def _on_begin_drag(self, event):
    item = event.GetItem()
    code_item = self.GetPyData(item)

    if is_task(code_item):  
        self.drag_item = code_item
        hand_cursor = wx.StockCursor(wx.CURSOR_HAND)
        self.SetCursor(hand_cursor)
        self.CaptureMouse()
        drag_item = self.drag_item
        &lt;&lt; define temporary event handlers &gt;&gt;
        self.SetFocus()
        self.Bind(wx.EVT_KEY_DOWN, on_key_down)
        self.Bind(wx.EVT_LEFT_UP, self._on_end_drag)
        self.Bind(wx.EVT_RIGHT_DOWN, self._clean_up_dragging)


def _on_end_drag(self, event):
    if not self.drag_item: return
    drag_item = self.drag_item    

    self._clean_up_dragging()

    pos = event.GetPosition()
    item, flag, col = self.HitTest(pos)
    &lt;&lt; check if drag_item is moved to a valid position &gt;&gt;

    children = tuple(drag_item.get_children(True))
    editor = self.GetParent().editor
    editor.BeginUndoAction()
    &lt;&lt; move drag_item &gt;&gt;
    &lt;&lt; copy extended CodeItem attributes to new items &gt;&gt;

    editor.should_be_corrected = True

    editor.EndUndoAction()
    wx.CallAfter(self.update_selection, new_item)
</t>
<t tx="michael.20060930115815"></t>
<t tx="michael.20060930115917">class ImportRemover(object):
    __icon__ = "delete16"

    @others
</t>
<t tx="michael.20060930115917.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060930115917.2">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20060930115917.3">def activate(self, context):
    code_item = context.code_item.remove()
</t>
<t tx="michael.20060930120528">class ImportCreator(object):
    @others</t>
<t tx="michael.20060930120528.1">def __init__(self, import_string):
    self.import_string = import_string</t>
<t tx="michael.20060930120528.2">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20060930120528.3">def apply_browser_menu(self, existing_attribs, code_item):
    return "create"
</t>
<t tx="michael.20060930120528.4">def activate(self, context):
    context = context.__class__(context.get_last_code_item())
    context.append_item(self.import_string, 0, prespace="\n")</t>
<t tx="michael.20060930134539">class ObserverCreator(SingletonEditor):
    name = db.Text()
    description = db.Text(multi_line=True)
    data = db.Model.type()
    observer = None
    observer_name = None
    title = _("Create Observer")

    @others</t>
<t tx="michael.20061002003849">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

__all__ = ("Standard",)

@others

faces.observer.clear_cache_funcs[Standard] = Standard._color_dict.clear
</t>
<t tx="michael.20061002003849.1">import faces.charting.charts as charts
import faces.observer
import faces.task
import faces.resource
import faces.charting.timescale as timescale
import faces.charting.widgets as widget
import faces.charting.patches as patches
import faces.charting.shapes as shapes
import faces.plocale
import matplotlib.font_manager as font
import locale
from faces.charting.tools import *

</t>
<t tx="michael.20061002003849.2">class Standard(charts.TimeAxisWidgetChart):
    """
    A standard resource chart.

    @var load_factor:
    Specifies the height of a load 1.0 bar in units of
    the default font size. If the load_factor is 12 and
    the default font size is 12 pt, the height of load 1.0 bar
    will be 12 * 12 = 144 pt. The default value is 12.

    @var start:
    The left start date of the chart. If KW{None} it is calculated
    automatically.

    @var end:
    The right end date of the chart. If KW{None} it is calculated
    automatically.

    @var title_attrib:
    A string value specifying the name of the task attribute that 
    should be displayed at the gantt object, to identify the task.

    @var color_index:
    A list of tuples defining the facecolor and fontcolor for
    the booking bars.
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20061002003849.3">__type_image__ = "resources"
__editor__ = ("faces.gui.edit_chart", "Resource")

color_index = ( ("navy", "white"),
                ("seagreen", "white"),
                ("indianred", "white"),
                ("violet", "white"),
                ("skyblue", "white"),
                ("purple", "white"),
                ("forestgreen", "white"),
                ("limegreen", "white"),
                ("darkorchid", "white"),
                ("rosybrown", "white") )

properties = { "title.weight" : "bold",
               "title.color" : "white",
               "row.edgecolor" : "black",
               "title.edgecolor" : "black",
               "title.facecolor" : "black",
               "title.linewidth" : 1,
               "title.fill" : 1,
               "title.antialiased" : True }

_color_dict = { }
_cindex = 0
load_factor = 12
show_rowlines = True
start = None
end = None
title_attrib = "title"

__attrib_completions__ = charts.TimeAxisWidgetChart.__attrib_completions__.copy()
__attrib_completions__.update({\
    "color_index" : 'color_index = [ ("navy", "white"), ("seagreen", "white") ]',
    "title_attrib" : 'title_attrib = "title"',
    "load_factor" : 'load_factor = 12',
    "show_rowlines" : 'show_rowlines = False',
    "start" : 'start = "|"',
    "end" : 'end = "|"',
    "def modify_row" : """def modify_row(self, row_widget, res):
self.add_load_line(row_widget, 1.0, edgecolor="red")
""",
    "def modify_bar" : \
    """def modify_bar(self, bar_widget, row_widget, task):
bar_widget.text("effort: %s\\nlength: %s" \\
% (task.to_string.effort,
task.to_string.length),
LEFT + 2*HSEP, TOP - 2*VSEP,
horizontalalignment="left",
verticalalignment="top",
color="white")
"""})


</t>
<t tx="michael.20061002003849.4">def __init__(self, *args, **kwargs):
    charts.TimeAxisWidgetChart.__init__(self, *args, **kwargs)
</t>
<t tx="michael.20061002003849.5">def create_all_widgets(self, start_row):
    data = self.data

    widgets = []

    try:
        if isinstance(data, faces.task.Task):
            if not self.start: self.start = self.data.start
            if not self.end: self.end = self.data.end
            self.calendar = self.data.root.calendar
            data = data.all_resources()
        elif isinstance(data, faces.resource.Resource):
            data = ( data, )
        elif issubclass(data, faces.resource.Resource):
            data = ( data(), )
    except TypeError:
        raise ValueError("the data attribute is not valid")

    if not self.start or not self.end:
        raise RuntimeError("You have to specify 'start' and 'end'")

    self.time_scale = timescale.TimeScale(self.calendar)
    self.start = self.time_scale.to_num(self.start)
    self.end = self.time_scale.to_num(self.end)

    for resource in iter(data):
        row = self.create_row(resource)
        bars = self.create_bars(resource(), row)
        if bars:
            widgets.extend(bars)
        else:
            # to ensure that the row will be there
            dumy = widget.TimeWidget(self.start, self.end, resource, row)
            dumy.set_shape(shapes.bar, "bar")
            dumy.set_visible(False)
            widgets.append(dumy)

    if not widgets:
        #no resource allocated
        raise RuntimeError("no resources defined")

    rows = self._finalize_row_widgets(widgets, start_row)
    widgets.extend(rows)
    return widgets
</t>
<t tx="michael.20061002003849.6">def create_row(self, resource):
    row = widget.Row()
    row.top_sep = 9
    row.bottom_sep = 0
    row.fobj = resource

    name = resource.name
    if resource.title != name:
        name += "(%s)" % resource.title

    kwargs = make_properties(self.get_property, "title")
    row.add_artist(patches.Rectangle((LEFT, TOP - 8 * VSEP),
                                     RIGHT - LEFT, 7 * VSEP,
                                     **kwargs))

    row.text(name, LEFT + 2 * HSEP, TOP - 3 * VSEP,
             verticalalignment="top",
             horizontalalignment ="left",
             fontproperties="title")

    row.text(name, RIGHT - 2 * HSEP, TOP - 3 * VSEP,
             verticalalignment="top",
             horizontalalignment ="right",
             fontproperties="title")

    self.modify_row(row, resource)
    return row
</t>
<t tx="michael.20061002003849.7">def modify_row(self, row_widget, resource):
    """
    Overwrite this method, to decorate a resource row.
    """
    pass
</t>
<t tx="michael.20061002003849.8">def add_load_line(self, row_widget, load, **kwargs):
    """
    Adds a horizontal line at a specific load.
    """

    offset = self.load_offset(load)
    row_widget.add_artist(patches.Polygon(((LEFT, BOTTOM + offset),
                                           (RIGHT, BOTTOM + offset)),\
                                          **kwargs))

    row_widget.text("load %0.2f" % load, 
                    RIGHT - 2*HSEP, BOTTOM + offset - 2*VSEP,
                    horizontalalignment="right",
                    verticalalignment="top",
                    fontproperties="left.load_line")

    row_widget.text("load %0.2f" % load, 
                    LEFT + 2*HSEP, BOTTOM + offset - 2*VSEP,
                    horizontalalignment="left",
                    verticalalignment="top",
                    fontproperties="right.load_line")
</t>
<t tx="michael.20061002003849.9">add_load_line.__call_completion__ = 'add_load_line(row_widget, 1.0, edgecolor="red")'


def load_offset(self, load):
    """
    returns the y position of a specific load.
    """
    return load * self.load_factor * font.fontManager.get_default_size()
</t>
<t tx="michael.20061002003849.10">def create_bar(self, task, row, start, end, load, offset):
    widget.ResourceBarWidget.load_factor = self.load_factor
    facecolor, text_color = self.get_color(task)
    props = { "bar.inside.color" : text_color,
              "facecolor" : facecolor }
    bar = widget.ResourceBarWidget(task, row, start, end, 
                                   load, offset, props)
    bar.inside_text("%s (%.2f)" % (getattr(task, self.title_attrib), load),
                    inside_properties="bar.inside")
    self.modify_bar(bar, row, task)
    return bar
</t>
<t tx="michael.20061002003849.11">def modify_bar(self, bar_widget, row_widget, task):
    """
    Overwrite this method, to decorate a var widget.
    """
    pass
</t>
<t tx="michael.20061002003849.12">def get_color(cls, task):
    id_ = task._idendity_()
    if not id_:
        #vacations have always the same color
        return ("gold", "black")

    color = cls._color_dict.get(id_)
    if not color:
        color = cls._color_dict[id_] = cls.color_index[cls._cindex]
        cls._cindex += 1
        if cls._cindex &gt;= len(cls.color_index):
            cls._cindex = 0

    return color
</t>
<t tx="michael.20061002003849.13">get_color = classmethod(get_color)


def create_bars(self, resource, row):
    to_num = self.time_scale.to_num
    widgets = []
    dstart = self.start
    dend = self.end

    tasks = resource.get_bookings_at(dstart, dend, self.data.scenario)

    def make_item(task):
        start = to_num(min(task.start, task.book_start))
        end = to_num(max(task.end, task.book_end))
        return (start, -(end - start), -task.load, task.book_start, task)

    book_items = map(make_item, tasks)
    book_items.sort()
    load_offsets = faces.resource.ResourceCalendar()
    used_tasks = {}

    def break_booking(start, end):
        #breaks a booking into parts with different load offsets
        spos, epos, offsets = load_offsets.get_bookings(start, end)
        offsets = map(lambda o: (max(to_num(o[0]), start), o[1] / 10000.0),
                      offsets[spos:epos])
        #returns the following sequence:
        #[(offset[0], offset[1]), (offset[1], offset[2]), ...]
        return zip(offsets, offsets[1:] + [(end,0)])

    def feq(f1, f2):
        "float equal"
        return ("%.3f" % f1) == ("%.3f" % f2)

    for s, le, lo, bs, t in book_items:
        load = -lo

        start = max(to_num(t.book_start), dstart)
        end = min(to_num(t.book_end), dend)

        breaks = break_booking(start, end)
        for sl, el in breaks:
            start, offset = sl
            end = el[0]
            last = used_tasks.get(t._idendity_())

            if last and feq(last.offset, offset) and feq(last.load, load):
                cal_last_end = self.calendar.EndDate(last.end)
                cal_start = self.calendar.EndDate(start)
                if cal_last_end &gt;= cal_start:
                    #connect the two objects
                    load_offsets.add_load(last.end, end, load)
                    last.end = end
                    continue                    

            load_offsets.add_load(start, end, load)
            obj = self.create_bar(t, row, start, end, load, offset)
            widgets.append(obj)
            used_tasks[t._idendity_()] = obj

    return widgets
</t>
<t tx="michael.20061002003849.14">def get_tip(self, tipobj):
    if not self.show_tips: return

    if isinstance(tipobj, widget.ResourceBarWidget):
        formats = faces.task.Task.formats
        to_minute = self.time_scale.chart_calendar.Minutes
        duration = tipobj.fobj.book_end - tipobj.fobj.book_start
        duration = to_minute(duration, True)
        work_time = to_minute(tipobj.fobj.work_time)
        lines = [
            (_("Name"), tipobj.fobj.title),
            (_("Load"), locale.format("%.2f", tipobj.load, True)),
            (_("Worktime"),  work_time.strftime(formats["length"])),
            (_("Timeframe"), "%s - %s" %
             (tipobj.fobj.book_start.strftime(formats["start"]),
              tipobj.fobj.book_end.strftime(formats["end"]))),
             (_("Duration"), duration.strftime(formats["duration"], True)),
            (_("State"), tipobj.fobj.actual and _("actual") or _("planned"))
            ]

        return lines

    return None
</t>
<t tx="michael.20061002004356">def register_editors(cls, registry):
    super(Standard, cls).register_editors(registry)
    registry.Boolean(_("Chart/show_rowlines..."), True)
    registry.Float(_("Chart/load_factor..."), 12)
    registry.Date(_("Chart/start..."))
    registry.Date(_("Chart/end..."))
    registry.String(_("Shape/title_attrib..."), "title")
    registry.Evaluation(_("Chart/data..."))
    registry.TwoColorSet(_("Chart/color_index..."), cls.color_index)


register_editors = classmethod(register_editors)

def create_property_groups(cls, property):
    property.set_default_groups()
    property.fill_font_group("title")
    property.fill_font_group("left.load_line")
    property.fill_font_group("right.load_line")
    property.fill_font_group("load_line")
    property.fill_font_group("bar.inside")    


create_property_groups = classmethod(create_property_groups)</t>
<t tx="michael.20061002010322"></t>
<t tx="michael.20061002010322.1">class TwoColor(db.Model):
    face = db.Text()
    text = db.Text()

    def __str__(self):
        return '("%s", "%s")' % (self.face, self.text)

</t>
<t tx="michael.20061002010322.2">class TwoColorGrid(grid.EditGrid, views.GridView):
    __model__ = TwoColor
    columns = (("face(Color)", _("Face")),
               ("text(Color)", _("Text")))
    resize_col = 1</t>
<t tx="michael.20061002010322.3">class TwoColorSet(db.Model):
    def __init__(self, code_item, attrib, value):
        super(TwoColorSet, self).__init__()
        for face, text in value or ():
            self.colors.insert(TwoColor(face=face, text=text))


    def __str__(self):
        return "[%s]" % ",\n".join(map(str, self.colors))


db.Relation("colors",
            db.End(TwoColor, "colors", multi='*'),
            db.End(TwoColorSet))</t>
<t tx="michael.20061002010322.4">class TwoColorSetView(views.FormView):
    __model__ = TwoColorSet
    __view_name__ = "default"
    vgap = 0
    format = """
colors&gt;
delete
"""
    def create_controls(self):
        self.colors = self.get_control("colors(ColorGrid)")
        self.delete = self.colors.get_delete_button(self)

    def prepare(self):
        self.grow_col(0)
        self.grow_row(0)</t>
<t tx="michael.20061002011136">def realize_code(self):
    raise RuntimeError("abstract")
</t>
<t tx="michael.20061002015044">def check_constraints(self):
    if len(self.evals) == 0:
        error = db.ConstraintError()
        error.message["evals"] = _("You have to input at least one evaluation data.")
        raise error</t>
<t tx="michael.20061002020357"></t>
<t tx="michael.20061002020357.1">def apply_browser_menu(self, existing_attribs, code_item):
    return "create"</t>
<t tx="michael.20061002020357.2">def init_attributes(self):
    self.name = ""
    self.observer = None
    self.data = None</t>
<t tx="michael.20061002020357.3">def realize_code(self):
    now = datetime.datetime.now().strftime("%x %H:%M:%S")
    code = 'class %s(%s):\n"Inserted at %s"' \
             % (self.name, self.observer_name, now)
             
    if self.data:
        code += "\ndata = %s" % str(self.data)
    
    context = self.context.__class__(self.context.get_last_code_item())
    context.append_item(code, 0)</t>
<t tx="michael.20061002020357.4">def check_constraints(self):
    if not reg_identifier.match(self.name):
        error = db.ConstraintError()
        error.message["name"] = _("Name is not a valid Identifier")
        raise error</t>
<t tx="michael.20061002020357.5">def set_observer(self, observer, name):
    code_item = self.context.code_item
    description = docparser.ClassDoc(observer).description

    registry = EditorRegistry()
    observer.register_editors(registry)

    for e in registry.editors.itervalues():
        if e.attrib_name == "data" \
            and e.edit_model in (Evaluation, MultiEvaluation):
            self.data = e.edit_model(code_item, "data", None)
            break
    else:
        self.data = None

    self.observer_name = name
    self.observer = observer
    self.description = description or _("No Description")</t>
<t tx="michael.20061002020357.6">class ObserverCreatorView(editorlib.MainView):
    __model__ = ObserverCreator
    __view_name__ = "default"
    
    format = _("""
lbl_error               
observer_list&gt;|[Description:]
   ""         |description&gt;
   ""         |[Name: ]
   ""         |name&gt;
   ""         |data_label
   ""         |data&gt;
--&gt;
(buttons)&gt;
""")

    @others</t>
<t tx="michael.20061002020357.7">def create_controls(self):
    self.observer_list = wx.ListCtrl(self, wx.NewId(), 
                                     style=wx.LC_ICON \
                                           |wx.LC_SINGLE_SEL \
                                           |wx.LC_ALIGN_TOP \
                                           |wx.SUNKEN_BORDER)
    self.observer_list.Bind(wx.EVT_LIST_ITEM_SELECTED, self._on_select_item)
    self.data_label = self.get_label(_("Data:"))</t>
<t tx="michael.20061002020357.8">def prepare(self):
    self.grow_col(-1)
    self.grow_row(2)
    self.buttons.grow_col(0)
    self.description.set_width("X" * 40)</t>
<t tx="michael.20061002020357.9">def constitute(self, imodel):
    super(ObserverCreatorView, self).constitute(imodel)
    
    self.observer_map = {}
    
    &lt;&lt; fill observer list &gt;&gt;
</t>
<t tx="michael.20061002020357.10">img_list = wx.ImageList(32, 32)
img_name_index_map = {}

observers = []
&lt;&lt; find observers &gt;&gt;
&lt;&lt; fill list control &gt;&gt;
self.observer_list.Arrange()
w, h = self.observer_list.GetViewRect().GetSize()
border = self.observer_list.GetSize() \
         - self.observer_list.GetClientSize()
self.observer_list.CacheBestSize((w + border.width, 
                                  (height + 40) * 7))
self.observer_list.SetItemState(0, wx.LIST_STATE_SELECTED, 
                                wx.LIST_STATE_SELECTED)
</t>
<t tx="michael.20061002020357.11">module = imodel.context.code_item.editor.get_module()
ismodule = inspect.ismodule
for k, v in module.__dict__.iteritems():
    &lt;&lt; filter out non valid modules &gt;&gt;
    &lt;&lt; get public attribs of module &gt;&gt;
    for attrib in attribs:
        obj = getattr(v, attrib, None)
        try:
            if not issubclass(obj, fobserver.Observer):
                continue
        except TypeError: continue
        
        &lt;&lt; add observer image in img_list &gt;&gt;
        self.observer_map["%s.%s" % (k, attrib)] = obj
        observers.append(("%s.%s" % (k, attrib), img_index))
</t>
<t tx="michael.20061002020357.12">if not ismodule(v): continue

try:
    if not v._is_source_: continue
except AttributeError: continue</t>
<t tx="michael.20061002020357.13">try:
    attribs = v.__all__
except AttributeError:
    attribs = dir(v)</t>
<t tx="michael.20061002020357.14">img_name = obj.__type_image__
if img_name:
    try:
        img_index = img_name_index_map[img_name]
    except KeyError:
        bmp = ResourceManager.load_bitmap(img_name, (32, 32))
        img_index = img_name_index_map[img_name]\
             = img_list.Add(bmp)
else:
    img_index = -1</t>
<t tx="michael.20061002020357.15">observers.sort()
self.observer_list.AssignImageList(img_list, wx.IMAGE_LIST_NORMAL)
insert_image = self.observer_list.InsertImageStringItem
insert = self.observer_list.InsertStringItem
extent = self.observer_list.GetTextExtent

height = 0
for name, img_index in observers:
    w, h = extent(name + "XXX")
    height = max(h, height)
    if img_index &gt;= 0:
        insert_image(sys.maxint, name, img_index)
    else:
        insert(sys.maxint, name)</t>
<t tx="michael.20061002020357.16">def state_changed(self, attrib):
    if attrib == "data":
        if self.imodel.data: 
            self.data.Show()
        else:
            self.data.Hide()
            
        if isinstance(self.imodel.data, Evaluation):
            self.data_label.Show()
        else:
            self.data_label.Hide()
            
        self.layout()</t>
<t tx="michael.20061002020357.17">def _on_select_item(self, event):
    name = event.GetItem().GetText()
    observer = self.observer_map[name]
    self.imodel.set_observer(observer, name)</t>
<t tx="michael.20061002022123">class ObserverRemover(object):
    __icon__ = "delete16"
    
    @others
</t>
<t tx="michael.20061002022123.1">def apply(self, expression, code_item):
    return False
</t>
<t tx="michael.20061002022123.2">def apply_browser_menu(self, existing_attribs, code_item):
    return "extra"
</t>
<t tx="michael.20061002022123.3">def activate(self, context):
    context.code_item.remove()

        </t>
<t tx="michael.20061002030802">try:
    func = faces.generator.create_generate_html
except AttributeError:
    pass
else:
    menu = top.make_menu(_("&amp;Tools"), pos=9980)
    menu.make_item(owner, _("Generate HTML..."), func(self), "run16", pos=10)</t>
<t tx="michael.20061018160639">if code_item.tree_obj.IsOk():
    parent = self.GetItemParent(code_item.tree_obj)
    self.Delete(code_item.tree_obj)
    &lt;&lt; reinsert still existing children under new parent &gt;&gt;
    self.modify_item(parent)</t>
<t tx="michael.20061018160639.1">first_child = None
for c in code_item.get_children(True):
    first_child = first_child or c
    insert(c)

if first_child:
    self.modify_item(self.GetItemParent(first_child.tree_obj))</t>
<t tx="michael.20061018160639.2">try:
    if code_item.tree_obj.IsOk():
        tree_parent = self.GetItemParent(code_item.tree_obj)
        item_parent = code_item.get_parent()
        if tree_parent == item_parent.tree_obj:
            #this can happen, in drag operations
            continue
except AttributeError: pass

insert(code_item)
&lt;&lt; insert children and modify their old parent &gt;&gt;
self.modify_item(self.GetItemParent(code_item.tree_obj))    </t>
<t tx="michael.20061018160639.3">last_parent = None
for c in code_item.get_children(True):
    try:
        tree_obj = c.tree_obj
    except AttributeError: pass
    else:
        if tree_obj.IsOk():
            parent = self.GetItemParent(tree_obj)
            if not last_parent: last_parent = parent
            self.Delete(tree_obj)

    insert(c)

if last_parent:
    self.modify_item(last_parent)
    self.modify_item(code_item.tree_obj)</t>
<t tx="michael.20061018160639.4">expanded = self.IsExpanded(code_item.tree_obj)
last_parent = self.GetItemParent(code_item.tree_obj)

#remove item
self.Delete(code_item.tree_obj)

#reinsert with children
insert(code_item)
for c in code_item.get_children(True):
    insert(c)

self.modify_item(self.GetItemParent(code_item.tree_obj))
self.modify_item(last_parent)
if expanded:
    self.Expand(code_item.tree_obj)</t>
<t tx="michael.20061018180317">def on_key_down(evt):
    if evt.GetKeyCode() == wx.WXK_ESCAPE:
        self._clean_up_dragging()

</t>
<t tx="michael.20061018180317.1">if not flag &amp; (wx.TREE_HITTEST_ONITEMICON | wx.TREE_HITTEST_ONITEMLABEL):
    return

ci = self.GetPyData(item)
if not is_task(ci): return</t>
<t tx="michael.20061018180317.2">l, t, w, h = self.GetBoundingRect(item)
q = t + h / 2

if pos.y &lt; q:
    new_line = drag_item.move_before(ci)
else:
    if self.IsExpanded(item):
        item = self.GetNextVisible(item)
        ci = self.GetPyData(item)
        new_line = drag_item.move_before(ci)
    else:
        new_line = drag_item.move_after(ci)
</t>
<t tx="michael.20061018180317.3">new_item = editor.code_item_at(new_line)
try:
    new_item.obj = drag_item.obj
    new_item.task_path = drag_item.task_path
    new_item.obj._function.code_item = weakref.proxy(new_item)
except AttributeError: pass

tasks_to_check = list(new_item.get_children(True))
for i, c in enumerate(tasks_to_check):
    old = children[i]
    try:
        c.obj = old.obj
        c.task_path = old.task_path
        c.obj._function.code_item = weakref.proxy(c)
    except AttributeError: pass

tasks_to_check.append(new_item)</t>
<t tx="michael.20061026113601"></t>
<t tx="michael.20061026113601.1"></t>
<t tx="michael.20061026114634">class ProjectTaskCreator(NameEditor):
    title = _("Add Project")

    @others</t>
<t tx="michael.20061026114839">def apply_browser_menu(self, existing_attribs, code_item):
    return "create"
</t>
<t tx="michael.20061026124000">def realize_code(self):
    now = datetime.datetime.now().strftime("%x")
    code = 'def %s():\nstart = "%s"' % (self.name, now)
    ci = self.context.get_last_code_item()
    context = self.context.__class__(ci)
    start_line, end_line = context.append_item(code, 0)
    ci.editor.check_code_updates(start_line, end_line)
    ci = ci.editor.code_item_at(start_line)
    def dumy(): start = "1.1.2006"
    ci.obj = ftask.Project(dumy)
</t>
<t tx="michael.20061026125228">class ProjectTaskRenamer(RenameEditor):
    title = _("Rename Project")
    __icon__ = "rename16"

    @others
</t>
<t tx="michael.20061026130909">def __str__(self):
    return "def %s():" % self.name</t>
<t tx="michael.20061026133329">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

_is_source = True
_to_datetime = pcalendar.to_datetime
_ = plocale.get_gettext()

@others
</t>
<t tx="michael.20061026133329.1">import pcalendar
import datetime
import utils
import string
import bisect
import plocale
</t>
<t tx="michael.20061026133329.2">@doc is used to find snapshot attributes
@code
def _isattrib(obj, a):
    return a[0] != "_" \
           and not callable(getattr(obj, a)) \
           and not a.endswith("_members") \
           and a not in ("name")
</t>
<t tx="michael.20061026133329.3">class ResourceCalendar(object):
    """
    The resource calendar saves the load time of a resource.
    Is ia sequence of time intervals of loads. An example of
    such a sequence is:
        [ (datetime.min, 0),
          (2006/1/1, 1.0),
          (2006/1/10, 0.5),
          (2006/1/15, 0) ]

    That means the resource:
        is free till january the first 2006
        is fully booked from january the first to january 10th
        is half booked from january 10th to january 15th
        is free since january 15th
    """

	@others
</t>
<t tx="michael.20061026133329.4">def __init__(self, src=None):
    if src:
        self.bookings = list(src.bookings)
    else:
        self.bookings = [ (datetime.datetime.min, 0) ]
</t>
<t tx="michael.20061026133329.5">def __str__(self):
    return str(self.bookings)
</t>
<t tx="michael.20061026133329.6">def __repr__(self):
    return "&lt;ResourceCalendar %s&gt;" % (str(self))
</t>
<t tx="michael.20061026133329.7">def add_load(self, start, end, load):
    start = _to_datetime(start)
    end = _to_datetime(end)

    bookings = self.bookings

    # the load will be converted in an integer to avoid
    # rouning problems
    load = int(load * 10000) 

    start_item = (start, 0)
    start_pos = bisect.bisect_left(bookings, start_item)

    left_load = 0
    left_load = bookings[start_pos - 1][1]

    if start_pos &lt; len(bookings) and bookings[start_pos][0] == start:
        prev_load = bookings[start_pos][1]
        if prev_load + load == left_load:
            del bookings[start_pos]
        else:
            bookings[start_pos] = (start, prev_load + load)
            start_pos += 1
    else:
        bookings.insert(start_pos, (start, load + left_load))
        start_pos += 1

    item = (datetime.datetime.min, 0)
    for i in range(start_pos, len(bookings)):
        end_pos = i
        item = bookings[i]
        if item[0] &gt;= end: break
        bookings[i] = (item[0], item[1] + load)
    else:
        end_pos = len(bookings)

    left_load = bookings[end_pos - 1][1]
    if item[0] == end:
        if item[1] == left_load:
            del bookings[end_pos]
    else:
        bookings.insert(end_pos, (end, left_load - load))
</t>
<t tx="michael.20061026133329.8">def end_of_booking_interval(self, date):
    date = _to_datetime(date)
    bookings = self.bookings
    date_item = (date, 999999)
    date_pos = bisect.bisect_left(bookings, date_item) - 1
    next_date = datetime.datetime.max
    load = 0

    try:
        book_item = bookings[date_pos]
        load = bookings[date_pos][1] / 10000.0
        next_date = bookings[date_pos + 1][0]
    except:
        pass

    return next_date, load
</t>
<t tx="michael.20061026133329.9">def find_free_time(self, start, length, load, max_load):
    bookings = self.bookings

    if isinstance(start, datetime.datetime):
        adjust_date = _to_datetime
    else:
        adjust_date = start.calendar.EndDate

    start = _to_datetime(start)
    load = int(load * 10000)
    max_load = int(max_load * 10000)
    lb = len(bookings)

    def next_possible(index):
        while index &lt; lb:
            sd, lo = bookings[index]
            if lo + load &lt;= max_load:
                break

            index += 1

        sd = adjust_date(max(start, sd))
        ed = sd + length
        end = _to_datetime(ed)

        index += 1
        while index &lt; lb:
            date, lo = bookings[index]

            if date &gt;= end:
                #I found a good start date
                return None, sd

            if lo + load &gt; max_load:
                return index + 1, None

            index += 1

        return None, sd

    start_item = (start, 1000000)
    i = bisect.bisect_left(bookings, start_item) - 1

    next_start = None
    while not next_start and i &lt; lb:
        i, next_start = next_possible(i)

    assert(next_start is not None)
    return next_start
</t>
<t tx="michael.20061026133329.10">def get_bookings(self, start, end):
    start = _to_datetime(start)
    end = _to_datetime(end)
    bookings = self.bookings
    start_item = (start, 0)
    start_pos = bisect.bisect_left(bookings, start_item)
    if start_pos &gt;= len(bookings) or bookings[start_pos][0] &gt; start:
        start_pos -= 1

    end_item = (end, 0)
    end_pos = bisect.bisect_left(bookings, end_item)
    return start_pos, end_pos, bookings
</t>
<t tx="michael.20061026133329.11">def get_load(self, date):
    date = _to_datetime(date)
    bookings = self.bookings
    item = (date, 100000)
    pos = bisect.bisect_left(bookings, item) - 1
    return bookings[pos][1] / 10000.0
</t>
<t tx="michael.20061026133329.12">class _ResourceBase(object):
    pass

</t>
<t tx="michael.20061026133329.13">class _MetaResource(type):
    doc_template = """
    A resource class. The resources default attributes can 
    be changed when the class ist instanciated, i.e. 
    %(name)s(max_load=2.0)

    @var max_load:
    Specify the maximal allowed load sum of all simultaneously
    allocated tasks of a resource. A ME{max_load} of 1.0 (default)
    means the resource may be fully allocated. A ME{max_load} of 1.3
    means the resource may be allocated with 30%% overtime.

    @var title:
    Specifies an alternative more descriptive name for the task.

    @var efficiency:
    The efficiency of a resource can be used for two purposes. First
    you can use it as a crude way to model a team. A team of 5 people
    should have an efficiency of 5.0. Keep in mind that you cannot
    track the member of the team individually if you use this
    feature. The other use is to model performance variations between
    your resources.

    @var vacation:
    Specifies the vacation of the resource. This attribute is
    specified as a list of date literals or date literal intervals.
    Be aware that the end of an interval is excluded, i.e. it is
    the first working date.
    """

	@others
</t>
<t tx="michael.20061026133329.14">def __init__(self, name, bases, dict_):
    super(_MetaResource, self).__init__(name, bases, dict_)
    self.name = name
    self.title = dict_.get("title", name)
    self._calendar = { None: ResourceCalendar() }
    self._tasks = { }
    self.__set_vacation()
    self.__add_resource(bases[0])
    self.__doc__ = dict_.get("__doc__", self.doc_template) % locals()
</t>
<t tx="michael.20061026133329.15">def __or__(self, other):
    return self().__or__(other)
</t>
<t tx="michael.20061026133329.16">def __and__(self, other):
    return self().__and__(other)
</t>
<t tx="michael.20061026133329.17">def __cmp__(self, other):
    return cmp(self.name, getattr(other, "name", None))
</t>
<t tx="michael.20061026133329.18">def __repr__(self):
    return "&lt;Resource %s&gt;" % self.name
</t>
<t tx="michael.20061026133329.19">def __str__(self):
    return repr(self)
</t>
<t tx="michael.20061026133329.20">def __set_vacation(self):
    vacation = self.vacation

    if isinstance(vacation, (tuple, list)):
        for v in vacation:
            if isinstance(v, (tuple, list)):
                self.add_vacation(v[0], v[1])
            else:
                self.add_vacation(v)
    else:
        self.add_vacation(vacation)
</t>
<t tx="michael.20061026133329.21">def __add_resource(self, base):
    if issubclass(base, _ResourceBase):
        members = getattr(base, base.__name__ + "_members", [])
        members.append(self)
        setattr(base, base.__name__ + "_members", members)
</t>
<t tx="michael.20061026133329.22">def get_members(self):
    return getattr(self, self.__name__ + "_members", [])
</t>
<t tx="michael.20061026133329.23">def add_vacation(self, start, end=None):
    start_date = _to_datetime(start)

    if not end:
        end_date = start_date.replace(hour=23, minute=59)
    else:
        end_date = _to_datetime(end)

    for cal in self._calendar.itervalues():
        cal.add_load(start_date, end_date, 1)

    tp = Booking()
    tp.start = start_date
    tp.end = end_date
    tp.book_start = start_date
    tp.book_end = end_date
    tp.work_time = end_date - start_date
    tp.load = 1.0
    tp.name = tp.title = _("(vacation)")
    tp._id = ""
    self._tasks.setdefault("", []).append(tp)
</t>
<t tx="michael.20061026133329.24">def make_team(resource):
    members = resource.get_members()
    if not members:
        return resource

    result = make_team(members[0])
    for r in members[1:]:
        result = result &amp; make_team(r)

    return result
</t>
<t tx="michael.20061026133329.25">class Booking(object):
    """
    A booking unit for a task.
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20061026133329.26">book_start = datetime.datetime.min
book_end = datetime.datetime.max
actual = False
_id = ""

</t>
<t tx="michael.20061026133329.27">def __init__(self, task=None):
    self.__task = task
</t>
<t tx="michael.20061026133329.28">def __cmp__(self, other):
    return cmp(self._id, other._id)
</t>
<t tx="michael.20061026133329.29">def path(self):
    first_dot = self._id.find(".")
    return "root" + self._id[first_dot:]

path = property(path)</t>
<t tx="michael.20061026133329.30">def _idendity_(self):
    return self._id
</t>
<t tx="michael.20061026133329.31">def __getattr__(self, name):
    if self.__task:
        return getattr(self.__task, name)

    raise AttributeError("'%s' is not a valid attribute" % (name))
</t>
<t tx="michael.20061026133329.32">class ResourceList(list):
	@others
</t>
<t tx="michael.20061026133329.33">def __init__(self, *args):
    if args: self.extend(args)
</t>
<t tx="michael.20061026133329.34">class Resource(_ResourceBase):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20061026133329.35">__metaclass__ = _MetaResource
__attrib_completions__ = {\
    "max_load": 'max_load = ',
    "title":  'title = "|"',
    "efficiency": 'efficiency = ',
    "vacation": 'vacation = [("|2002-02-01", "2002-02-05")]' }

__type_image__ = "resource16"

max_load = None # the maximum sum load for all task
vacation = ()
efficiency = 1.0


</t>
<t tx="michael.20061026133329.36">def __init__(self, **kwargs):
    for k, v in kwargs.iteritems():
        setattr(self, k, v)
</t>
<t tx="michael.20061026133329.37">def _idendity_(cls):
    return "resource:" + cls.__name__

_idendity_ = classmethod(_idendity_)
</t>
<t tx="michael.20061026133329.38">def __repr__(self):
    return "&lt;Resource %s&gt;" % self.__class__.__name__
</t>
<t tx="michael.20061026133329.39">def __str__(self):
    return repr(self)
</t>
<t tx="michael.20061026133329.40">def __call__(self):
    return self
</t>
<t tx="michael.20061026133329.41">def __hash__(self):
    return hash(self.__class__)
</t>
<t tx="michael.20061026133329.42">def __cmp__(self, other):
    return cmp(self.name, other.name)
</t>
<t tx="michael.20061026133329.43">def __or__(self, other):
    if type(other) is _MetaResource:
        other = other()

    result = Resource()
    result._subresource = _OrResourceGroup(self, other)
    return result
</t>
<t tx="michael.20061026133329.44">def __and__(self, other):
    if type(other) is _MetaResource:
        other = other()

    result = Resource()
    result._subresource = _AndResourceGroup(self, other)
    return result
</t>
<t tx="michael.20061026133329.45">def _permutation_count(self):
    if hasattr(self, "_subresource"):
        return self._subresource._permutation_count()

    return 1
</t>
<t tx="michael.20061026133329.46">def _get_resources(self, state):
    if hasattr(self, "_subresource"):
        result = self._subresource._get_resources(state)

        if self.name != "Resource":
            result.name = self.name

        if self.title != "Resource":
            result.title = self.title

        return result

    result = ResourceList(self)
    return result
</t>
<t tx="michael.20061026133329.47">def all_members(self):
    if hasattr(self, "_subresource"):
        return self._subresource.all_members()

    return [ self.__class__ ]
</t>
<t tx="michael.20061026133329.48">def unbook_tasks_of_project(cls, project_id, scenario):
    try:
        task_list = cls._tasks[scenario]
    except KeyError:
        return

    add_load = cls.calendar(scenario).add_load
    for task_id, bookings in task_list.items():
        if task_id.startswith(project_id):
            for item in bookings:
                add_load(item.book_start, item.book_end, -item.load)

            del task_list[task_id]

    if not task_list:
        del cls._tasks[scenario]

unbook_tasks_of_project = classmethod(unbook_tasks_of_project)
</t>
<t tx="michael.20061026133329.49">def unbook_task(cls, task):
    identdity = task._idendity_()
    scenario = task.scenario

    try:
        task_list = cls._tasks[scenario]
        bookings = task_list[identdity]
    except KeyError:
        return

    add_load = cls.calendar(scenario).add_load
    for b in bookings:
        add_load(b.book_start, b.book_end, -b.load)

    del task_list[identdity]
    if not task_list:
        del cls._tasks[scenario]

unbook_task = classmethod(unbook_task)
</t>
<t tx="michael.20061026133329.50">def correct_bookings(cls, task):
    #correct the booking data with the actual task data
    try:
        tasks = cls._tasks[task.scenario][task._idendity_()]
    except KeyError:
        return

    for t in tasks:
        t.start = task.start.to_datetime()
        t.end = task.end.to_datetime()

correct_bookings = classmethod(correct_bookings)
</t>
<t tx="michael.20061026133329.51">def book_task(cls, task, start, end, load, work_time, actual):
    if not work_time: return

    start = _to_datetime(start)
    end = _to_datetime(end)

    identdity = task._idendity_()
    task_list = cls._tasks.setdefault(task.scenario, {})
    bookings = task_list.setdefault(identdity, [])
    add_load = cls.calendar(task.scenario).add_load

    tb = Booking(task)
    tb.book_start = start
    tb.book_end = end
    tb._id = identdity
    tb.load = load
    tb.start = _to_datetime(task.start)
    tb.end = _to_datetime(task.end)
    tb.title = task.title
    tb.name = task.name
    tb.work_time = int(work_time)
    tb.actual = actual
    bookings.append(tb)
    result = add_load(start, end, load)
    return result

book_task = classmethod(book_task)
</t>
<t tx="michael.20061026133329.52">def length_of(cls, task):
    cal = task.root.calendar
    bookings = cls.get_bookings(task)
    return sum(map(lambda b: task._to_delta(b.work_time).round(), bookings))

length_of = classmethod(length_of)
</t>
<t tx="michael.20061026133329.53">def done_of(self, task):
    cal = task.root.calendar
    now = cal.now
    bookings = self.get_bookings(task)

    if task.__dict__.has_key("effort"):
        efficiency = self.efficiency * task.efficiency
    else:
        efficiency = 1

    def book_done(booking):
        if booking.book_start &gt;= now:
            return 0

        factor = 1
        if booking.book_end &gt; now:
            start = task._to_start(booking.book_start)
            end = task._to_end(booking.book_end)
            cnow = task._to_start(now)
            factor = float(cnow - start) / ((end - start) or 1)

        return factor * booking.work_time * efficiency

    return task._to_delta(sum(map(book_done, bookings)))
</t>
<t tx="michael.20061026133329.54">def todo_of(self, task):
    cal = task.root.calendar
    now = cal.now

    bookings = self.get_bookings(task)
    if task.__dict__.has_key("effort"):
        efficiency = self.efficiency * task.efficiency
    else:
        efficiency = 1

    def book_todo(booking):
        if booking.book_end &lt;= now:
            return 0

        factor = 1
        if booking.book_start &lt; now:
            start = task._to_start(booking.book_start)
            end = task._to_end(booking.book_end)
            cnow = task._to_start(now)
            factor = float(end - cnow) / ((end - start) or 1)

        return factor * booking.work_time * efficiency

    return task._to_delta(sum(map(book_todo, bookings)))
</t>
<t tx="michael.20061026133329.55">def get_bookings(cls, task):
    return cls._tasks.get(task.scenario, {}).get(task._idendity_(), ())

get_bookings = classmethod(get_bookings)
</t>
<t tx="michael.20061026133329.56">def get_bookings_at(cls, start, end, scenario):
    result = []

    try:
        items = cls._tasks[scenario].iteritems()
    except KeyError:
        return ()

    for task_id, bookings in items:
        result += [ booking for booking in bookings 
                    if booking.book_start &lt; end
                    and booking.book_end &gt; start ]

    vacations = cls._tasks.get("", ())
    result += [ booking for booking in vacations
                if booking.book_start &lt; end
                and booking.book_end &gt; start ]

    return result

get_bookings_at = classmethod(get_bookings_at)
</t>
<t tx="michael.20061026133329.57">def find_free_time(cls, start, length, load, max_load, scenario):
    return cls.calendar(scenario).find_free_time(start, length, load, max_load)

find_free_time = classmethod(find_free_time)
</t>
<t tx="michael.20061026133329.58">def get_load(cls, date, scenario):
    return cls.calendar(scenario).get_load(date)

get_load = classmethod(get_load)
</t>
<t tx="michael.20061026133329.59">def end_of_booking_interval(cls, date, task):
    return cls.calendar(task.scenario).end_of_booking_interval(date)

end_of_booking_interval = classmethod(end_of_booking_interval)
</t>
<t tx="michael.20061026133329.60">def snapshot(self):
    from task import _as_string
    def isattrib(a):
        if a == "max_load" and self.max_load is None: return False
        if a in ("name", "title", "vacation"): return False
        return _isattrib(self, a)

    attribs = filter(isattrib, dir(self))
    attribs = map(lambda a: "%s=%s" % (a, _as_string(getattr(self, a))),
                  attribs)

    return self.name + "(%s)" % ", ".join(attribs)
</t>
<t tx="michael.20061026133329.61">

class _ResourceGroup(object):
	@others
</t>
<t tx="michael.20061026133329.62">def __init__(self, *args):
    self.resources = []
    for a in args:
        self.__append(a)
</t>
<t tx="michael.20061026133329.63">def all_members(self):
    group = reduce(lambda a, b: a + b.all_members(),
                   self.resources, [])
    group = map(lambda r: (r, True), group)
    group = dict(group)
    group = group.keys()
    return group
</t>
<t tx="michael.20061026133329.64">def _permutation_count(self):
    abstract
</t>
<t tx="michael.20061026133329.65">def _refactor(self, arg):
    pass
</t>
<t tx="michael.20061026133329.66">def __append(self, arg):
    if isinstance(arg, self.__class__):
        self.resources += arg.resources
        for r in arg.resources:
            self._refactor(r)
        return
    elif isinstance(arg, Resource):
        subresources = getattr(arg, "_subresource", None)
        if subresources:
            self.__append(subresources)
            return
        else:
            self.resources.append(arg)
    else:
        assert(isinstance(arg, _ResourceGroup))
        self.resources.append(arg)

    self._refactor(arg)
</t>
<t tx="michael.20061026133329.67">def __str__(self):
    op = lower(self.__class__.__name__[0:-13])
    return "(" + \
           string.join([str(r) for r in self.resources],
                       " " + op + " ") + \
           ")"
</t>
<t tx="michael.20061026133329.68">

class _OrResourceGroup(_ResourceGroup):
	@others
</t>
<t tx="michael.20061026133329.69">def _get_resources(self, state):
    for r in self.resources:
        c = r._permutation_count()
        if c &lt;= state:
            state -= c
        else:
            return r._get_resources(state)

    assert(0)
</t>
<t tx="michael.20061026133329.70">def _permutation_count(self):
    return sum([ r._permutation_count() for r in self.resources])
</t>
<t tx="michael.20061026133329.71">

class _AndResourceGroup(_ResourceGroup):
	@others
</t>
<t tx="michael.20061026133329.72">def __init__(self, *args):
    self.factors = [ 1 ]
    _ResourceGroup.__init__(self, *args)
</t>
<t tx="michael.20061026133329.73">def _refactor(self, arg):
    count = arg._permutation_count()
    self.factors = [ count * f for f in self.factors ]
    self.factors.append(1)
</t>
<t tx="michael.20061026133329.74">    #print "AndResourceGroup", count, arg, self.factors


def _permutation_count(self):
    return self.factors[0]
</t>
<t tx="michael.20061026133329.75">def _get_resources(self, state):
    """delivers None when there are duplicate resources"""
    result = []
    for i in range(1, len(self.factors)):
        f = self.factors[i]
        substate = state / f
        state %= f
        result.append(self.resources[i - 1]._get_resources(substate))

    result = ResourceList(*list(utils.flatten(result)))
    dupl_test = { }
    for r in result:
        if dupl_test.has_key(r):
            return None
        else:
            dupl_test[r] = 1

    return result
</t>
<t tx="michael.20061026133329.76">def _has_duplicates(self, state):
    resources = self._get_resources(state)
    tmp = { }
    for r in resources:
        if tmp.has_key(r):
            return True

        tmp[r] = 1

    return False
</t>
<t tx="michael.20061026224624"></t>
<t tx="michael.20061027120904">def to_value_wrapper(a):
    if isinstance(a, _ValueWrapper):
        return a

    return _ValueWrapper(a, [(None, None)])

def my_max(*args):
    return max(map(to_value_wrapper, args))

def my_min(*args):
    return min(map(to_value_wrapper, args))

globals_["me"] = me_instance

if self._is_compiled:
    globals_["up"] = self.up
    globals_["root"] = self.root
else:
    globals_["up"] = _Path(self.up, "up")
    globals_["root"] = _Path(self.root, "root")

globals_["Delta"] = self._to_delta
globals_["Date"] = self._to_start
globals_["max"] = my_max
globals_["min"] = my_min
globals_["add_attrib"] = me_instance.add_attrib</t>
<t tx="michael.20061027120904.2">@
Is used for functions like YearlyMax, MonthlyMax, ....
@code
for name in self._function.global_names:
    try:
        obj = globals_[name]
        if isinstance(obj, types.FunctionType):
            fg = obj.func_globals
            if not fg.has_key("me") and "me" in obj.func_code.co_names:
                restore_globals.append(fg)
                fg["me"] = me_instance
    except KeyError: continue</t>
<t tx="michael.20061027120904.3">if do_raise:
    try:
        self._function()
        self._is_compiled = True
    except _IncompleteError, e:
        src = e.args[1]
        if src is not self:
            self.__at_compile = e.args[1:]
            src._compile([], True)

        raise
else:
    try:
        self._function()
        self._is_compiled = True
    except AttributeError, e:
        #print "AttributeError:", e, self.name, e.is_frozen, do_raise
        deferred.append(self)
    except _IncompleteError:
        #print "_IncompleteError:", id(self), self.name, do_raise
        deferred.append(self)
    except RecursionError:
        self._is_parent_referer = True
        deferred.append(self)</t>
<t tx="michael.20061027121652">try:
    cal = me.calendar
except NameError:
    cal = pcalendar._default_calendar

time_diff = cal.Minutes(value)</t>
<t tx="michael.20061027224620">def _set_hook(cls, attrib_name, function=None):
    if function:
        cls._setting_hooks[attrib_name] = function
    else:
        try:
            del cls._setting_hooks[attrib_name]
        except KeyError: pass


_set_hook = classmethod(_set_hook)</t>
<t tx="michael.20061028111855">def apply(self, expression, code_item):
    if not expression: return False

    mo = reg_identifier_assignment.search(expression)
    if not mo: return False

    pname = mo.groupdict()["project"]
    return self.__class__.__name__.startswith(pname)


</t>
<t tx="michael.20061028114303">def apply(self, expression, code_item):
    return not expression
</t>
<t tx="michael.20061028120746">def activate(self, editor, line, prev, next, inside):
    """
    try to activate the context
    """
    can_activate = is_evaluation(prev) and line &lt;= prev.get_last_line() + 1
    if can_activate:
        self.code_item = inside or prev
        return True
    else:
        self.code_item = None
        return False</t>
<t tx="michael.20061028124110">def prepare_draw_stage2(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    registry = {}
    for cell in self.widest_cells:
        self.axes.add_widget(cell)
        registry[cell] = True

    for r, row in enumerate(self.cells):
        for c, cell in enumerate(row):
            if not cell or cell in registry: continue
            self.axes.add_widget(cell)

    return True, True
</t>
<t tx="michael.20061028124110.1">def set_pos(self, x, y):
    Point = mtrans.Point
    BBox = mtrans.Bbox
    left = x = Lazy(x)
    y = Lazy(y)
    w = self.width
    h = self.height
    bbox = self.bbox = BBox(Point(x.val, y.val), Point(x.val + w.val, y.val + h.val))

    ry = Lazy(bbox.ur().y())

    widest_cells = self.widest_cells
    highest_cells = self.highest_cells

    for r, row in enumerate(self.cells):
        height = highest_cells[r].height
        ry -= height
        cx = Lazy(left)
        for c, cell in enumerate(row):
            width = widest_cells[c].width
            ocx = cx
            cx += width

            if not cell: continue
            w, h  = cell.width, cell.height 
            if cell._valign == "top":
                y = ry + height - h
            elif cell._valign == "center":
                y = ry + (height - h) / 2
            else:
                y = ry.get()

            if cell._halign == "right":
                x = ocx + width - w
            elif cell._halign == "center":
                x = ocx + (width - w) / 2
            else:
                x = ocx

            cell.set_pos(x, y)

</t>
<t tx="michael.20061028145753"></t>
<t tx="michael.20061028151207">class ShortConnector(widgets.Widget):
    """
    A connector that connects two arbitrary widgets on the shortes path
    """
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="michael.20061028151207.1">properties = {
    "connector.linewidth" : 1,
    "connector.edgecolor" : "black",
    "connector.arrow.width" : 3,
    "connector.arrow.height" : 3,
    "connector.arrow.edgecolor" : "darkslategray",
    "connector.arrow.facecolor" : "darkslategray",
    "connector.arrow.open" : False,
    "connector.directed" : True
    }

zorder = -100

</t>
<t tx="michael.20061028151207.2">def __init__(self, src, dest, properties=None):
    widgets.Widget.__init__(self, properties)
    self.src = src
    self.dest = dest

    #fetch all properties
    self.get_patch("connector")
</t>
<t tx="michael.20061028151207.3">def get_bounds(self, renderer):
    return self.bbox
</t>
<t tx="michael.20061028151207.4">def contains(self, x, y):
    return False
</t>
<t tx="michael.20061028151207.5">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    HSEP.set(VSEP.get())
    Point = mtrans.Point
    BBox = mtrans.Bbox
    Value = mtrans.Value
    Half = Value(0.5)

    src_box = self.src.bbox
    dst_box = self.dest.bbox

    src_x = (src_box.ur().x() + src_box.ll().x()) * Half
    src_y = (src_box.ur().y() + src_box.ll().y()) * Half
    dst_x = (dst_box.ur().x() + dst_box.ll().x()) * Half
    dst_y = (dst_box.ur().y() + dst_box.ll().y()) * Half

    self.bbox = BBox(Point(src_x, src_y), Point(dst_x, dst_y))


    if self.get_property("connector.directed"):
        &lt;&lt; calc arrow position &gt;&gt;

    return True, True</t>
<t tx="michael.20061028151207.6">def draw(self, renderer, data_box):
    if not self.get_visible() or not self.overlaps(data_box): return False
    transform = self.get_transform()

    gc = renderer.new_gc()
    if self.get_clip_on():
        gc.set_clip_rectangle(self.clipbox.get_bounds())

    self.set_gc(gc, "connector")

    x, y, w, h = self.bbox.get_bounds()
    draw_lines(renderer, gc, (x, x + w), (y, y + h), transform)

    if self.get_property("connector.directed"):
        &lt;&lt; draw arrow &gt;&gt;

    return False</t>
<t tx="michael.20061028160826">def intersect(l1, l2):
    """
    Intersects two lines:
        l = (p, d) == p + a * d

        p1 + a * d1 = p2 + b * d2

        returns a, b
    """
    &lt;&lt; extract coordinates &gt;&gt;
    l1x = p1x, d1x
    l1y = p1y, d1y
    l2x = p2x, d2x
    l2y = p2y, d2y

    &lt;&lt; define calc &gt;&gt;

    try:
        a, b = calc(l1x, l1y, l2x, l2y)
        return a, b
    except ZeroDivisionError: pass

    try:
        a, b = calc(l1y, l1x, l2y, l2x)
        return a, b
    except ZeroDivisionError: pass

    try:
        b, a = calc(l2x, l2y, l1x, l1y)
        return a, b
    except ZeroDivisionError: pass

    try:
        b, a = calc(l2y, l2x, l1y, l1x)
        return a, b
    except ZeroDivisionError:
        #lines are parallel
        return mtrans.Value(-1), mtrans.Value(-1)
</t>
<t tx="michael.20061028180706">p1, d1 = l1
p2, d2 = l2

p1x, p1y = p1
d1x, d1y = d1

p2x, p2y = p2
d2x, d2y = d2</t>
<t tx="michael.20061028180706.1">def calc(mx, my, nx, ny):
    ax, bx = mx
    ay, by = my
    cx, dx = nx
    cy, dy = ny

    rf = bx / by
    n = ((cx - ax - rf * (cy - ay))) 
    d = rf * dy - dx
    beta = n / d
    beta.get()

    if bx.get():
        alpha = (cx + beta * dx - ax) / bx
    else:
        alpha = (cy + beta * dy - ay) / by

    return alpha, beta</t>
<t tx="michael.20061028180926">self.dx = dx = dst_x - src_x
self.dy = dy = dst_y - src_y

&lt;&lt; calc line equations &gt;&gt;

#find the intersection point
ips = [ intersect(connector, l) for l in (left, right, top, bottom) ]
min_a = min([ (a.get(), a) for a, b in ips if 0 &lt;= b.get() &lt;= 1.0 ])[1]

# arrow stuff
self.len = dx * dx + dy * dy
self.cos = Lazy(1)
self.sin = Lazy(0)

prop = self.get_property
awidth = prop("connector.arrow.width")
aheight = prop("connector.arrow.height")

self.arrow = get_arrow(self.cos, self.sin,
                       src_x + min_a * dx,
                       src_y + min_a * dy,
                       awidth, aheight)</t>
<t tx="michael.20061028180926.1">connector = ((src_x, src_y), (dx, dy))
left = ((dst_box.ll().x(), dst_box.ll().y()),
        (Value(0), dst_box.ur().y() - dst_box.ll().y()))
right = ((dst_box.ur().x(), dst_box.ll().y()),
         (Value(0), dst_box.ur().y() - dst_box.ll().y()))
top = ((dst_box.ll().x(), dst_box.ur().y()),
       (dst_box.ur().x() - dst_box.ll().x(), Value(0)))
bottom = ((dst_box.ll().x(), dst_box.ll().y()),
          (dst_box.ur().x() - dst_box.ll().x(), Value(0)))</t>
<t tx="michael.20061028180926.2">l = math.sqrt(self.len.get()) or 1.0
self.cos.set(-self.dx.get() / l)
self.sin.set(-self.dy.get() / l)

self.set_gc(gc, "connector.arrow")
if self.get_property("connector.arrow.open"):
    draw_lines(renderer, gc,
               map(lambda a: a[0], self.arrow),
               map(lambda a: a[1], self.arrow),
               transform)
else:
    face = self.get_property("connector.arrow.facecolor")
    face = _colorConverter.to_rgb(face)
    try:
        arrow = transform.seq_xy_tups(self.arrow)
    except ZeroDivisionError:
        print "ZeroDivisionError"
        #for c, a in enumerate(self.arrow):
        #    print "  ", c, a[0].get(), a[1].get()
    else:
        renderer.draw_polygon(gc, face, arrow)</t>
<t tx="michael.20061028181551">class BoxedTextWidget(Widget):
    """
    A boxed text widget. The constructor accepts the following
    arguments:

    Why check_font_factor and all the complicated stuff:
    The text width of LazyText does not scale linear, resulting
    in text overlapping boxes. check_font_factor calculates a
    newbounding box, for a new font_factor

    """

	@others</t>
<t tx="michael.20061028181551.1">def __init__(self, text, fobj, properties=None,
             fattrib=None, left=4, right=4,
             top=4, bottom=4, **kwargs):
    super(BoxedTextWidget, self).__init__(properties)

    self.fobj = fobj
    self.fattrib  = fattrib
    self.left = left
    self.right = right
    self.top = top
    self.bottom = bottom
    kwargs = self._extend_text_properties(kwargs)
    self.text = LazyText(LEFT + self.left, BOTTOM + self.bottom, 
                         text, **kwargs)
    self.artists.append(self.text)


</t>
<t tx="michael.20061028181551.2">def get_bounds(self, renderer):
    self.check_font_factor(renderer)
    return self.bbox
</t>
<t tx="michael.20061028181551.3">def prepare_draw(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)

    bbox = self.calc_bounding_box(renderer)
    Point = mtrans.Point
    BBox = mtrans.Bbox
    x = Lazy(0)
    y = Lazy(0)
    self.width = w = Lazy(0)
    self.height = h = Lazy(0)
    self.bbox = BBox(Point(x.val, y.val), Point(x.val + w.val, y.val + h.val))
    self.width.set(bbox.width())
    self.height.set(bbox.height())
    self.prepare_draw = self.prepare_draw_stage2
    return True, True</t>
<t tx="michael.20061028181551.4">def prepare_draw_stage2(self, renderer, point_to_pixel, fig_point_to_pixel):
    self.set_font_factor(point_to_pixel, fig_point_to_pixel)
    self.font_factor = Lazy(point_to_pixel / fig_point_to_pixel)
    return True, True
</t>
<t tx="michael.20061028181551.5">def set_pos(self, x, y):
    Point = mtrans.Point
    BBox = mtrans.Bbox
    x = Lazy(x)
    y = Lazy(y)
    w = self.width
    h = self.height
    self.bbox = BBox(Point(x.val, y.val), Point(x.val + w.val, y.val + h.val))
</t>
<t tx="michael.20061028181551.6">def draw(self, renderer, data_box):
    if not self.get_visible() or not self.overlaps(data_box): return False
    self.check_font_factor(renderer)
    set_helpers(self.bbox, self.bbox)
    for a in self.all_artists(): a.draw(renderer)
    return True
</t>
<t tx="michael.20061028181843">def set_cell(self, row, col, widget, valign="center", halign="center"):
    self.cells[row][col] = widget
    widget._valign = valign
    widget._halign = halign</t>
<t tx="michael.20061031174101">def correct_resource_code(self, code_item):
    try:
        if code_item.obj.name == code_item.name: return
    except AttributeError: return

    refs = self.find_resource_references(code_item.obj.name)
    for ci, line, start, end in refs:
        text = self.GetTextRange(start, end)
        self.SetTargetStart(start)
        self.SetTargetEnd(end)
        self.ReplaceTarget(text.replace(code_item.obj.name,
                                        code_item.name))

    code_item.obj.name = code_item.name
</t>
<t tx="michael.20061031174101.1">def correct_task_code(self, code_item):
    self.BeginUndoAction()
    try:
        task = code_item.obj
        old_path = code_item.task_path
    except AttributeError: return

    path = get_code_item_path(code_item)
    if path == old_path: return

    code_item.task_path = path
    &lt;&lt; change all relative paths of my sources &gt;&gt;
    &lt;&lt; change the path in all tasks that depend on me &gt;&gt;
    self.EndUndoAction()
</t>
<t tx="michael.20061031175127">def correct_code(self, editor):
    editor.correct_code()</t>
<t tx="michael.20061106013825">def check_for_correction(self):
    to_correct = [ model.editor.editor
                   for model in controller().get_planbuffers()
                   if model.editor.editor.should_be_corrected ]
    if to_correct:
        answer = wx.MessageBox(_("Should I try to correct your project?"),
                               _("Recalc Project"),
                               wx.YES_NO|wx.CANCEL|wx.ICON_QUESTION)
        if answer == wx.YES:
            for editor in to_correct:
                editor.should_be_corrected = False
                editor.correct_code()
        else:
            for editor in to_correct:
                editor.should_be_corrected = False</t>
<t tx="michael.20061109163439">def get_main_completion_list(self):
    compl = super(CTask, self).get_main_completion_list()
    &lt;&lt; add user defined task completions &gt;&gt;
    return compl    </t>
<t tx="michael.20061109173515">try:
    tc = self.code_item.editor.task_completions
    if tc: compl += tc
except AttributeError: pass</t>
<t tx="michael.20061109181208">def _refsum(refs):
    return reduce(lambda a, b: a + b, refs, [])</t>
<t tx="michael.20061109182534">try:
    task = self.__dict__[name]
except KeyError:
    task = Task(value, name, self, len(self.children) + 1)
    self.children.append(task)
    setattr(self, task.name, task)
return</t>
<t tx="michael.20061109182534.1">if type(value) == types.DictionaryType:
    self.root.all_scenarios.update(value.keys())
    value = value.get(self.scenario, value["_default"])

self.__set_sources(name, value)
self._original_values[name] = value
set_method(_val(value))</t>
<t tx="michael.20061109182534.2">if callable( getattr(self.__class__, name, None)):
    raise NameError('You may not use "%s" as attribute' % name)

setattr(self, name, value)
self._properties[name] = True
self.__set_sources(name, value)</t>
<t tx="michael.20061109182534.3">def make_ref(val):
    if isinstance(val, _ValueWrapper):
        return val._ref

    if isinstance(val, Task):
        return [(val, "")]

    return []

if isinstance(value, (list, tuple)):
    sources = _refsum(map(make_ref, value))
else:
    sources = make_ref(value)</t>
<t tx="michael.20061110182612">menu(_("Toggle Bookmark\tCTRL-F2"), self.toggle_bookmark, pos=650)
menu(_("Next Bookmark\tF2"), self.goto_next_bookmark, pos=651)
menu(_("Previous Bookmark\tSHIFT-F2"), self.goto_prev_bookmark, pos=652)</t>
<t tx="michael.20061110184924">def toggle_bookmark(self): 
    line = self.GetCurrentLine()
    if self.MarkerGet(line) &amp; 4:
        self.MarkerDelete(line, 2)
    else:
        self.MarkerAdd(line, 2)</t>
<t tx="michael.20061110184924.1">def goto_next_bookmark(self):
    next = self.MarkerNext(self.GetCurrentLine() + 1, 4)
    if next &lt; 0:
        next = self.MarkerNext(0, 4)

    if next &gt;= 0:
        self.GotoLine(next)
</t>
<t tx="michael.20061110184924.2">def goto_prev_bookmark(self):
    prev = self.MarkerPrevious(self.GetCurrentLine() - 1, 4)
    if prev &lt; 0:
        prev = self.MarkerPrevious(self.GetLineCount(), 4)

    if prev &gt;= 0:
        self.GotoLine(prev)
</t>
<t tx="michael.20061113154308.1">set_helpers(bbox, bbox)
bbox = self.text.get_window_extent(renderer)
bbox = inverse(self.get_transform(), bbox)

xmin, xmax = bbox.intervalx().get_bounds()
bbox.intervalx().set_bounds(xmin, xmax + self.left + self.right)
ymin, ymax = bbox.intervaly().get_bounds()
bbox.intervaly().set_bounds(ymin, ymax + self.top + self.bottom)
</t>
<t tx="michael.20061113154308.2">set_helpers(bbox, bbox)
extends = [ t.get_window_extent(renderer) for t in self.artists ]
if extends:
    bb_all = mtrans.bbox_all(extends)
    bb_all = inverse(self.get_transform(), bb_all)
    bbox = mtrans.bbox_all((bb_all, bbox))</t>
<t tx="michael.20061114113543">def find_object(self, name):
    """
    Find an object by name.
    """
    editor = self.code_item.editor
    attribs = editor.get_attribs(self.code_item)
    try:
        expression = editor.get_expression(attribs[name])
        attribs = editor.eval_expression(expression, context=self)
        return attribs[name]
    except Exception, e: pass

    obj = self.get_object()
    try:
        return getattr(obj, name)
    except AttributeError, e:
        return None
</t>
<t tx="michael.20061114193915">def calc_bounding_box(self, renderer):
    inverse = mtrans.inverse_transform_bbox
    bbox = mtrans.unit_bbox()

    &lt;&lt; calculate bbox based on self.text &gt;&gt;
    &lt;&lt; calculate bbox with all artists &gt;&gt;
    return bbox</t>
<t tx="michael.20061114193915.1">__last_font_factor = 0    
def check_font_factor(self, renderer):
    font_factor = self.font_factor.get()
    if self.__last_font_factor != font_factor:
        self.__last_font_factor = font_factor
        bbox = self.calc_bounding_box(renderer)
        self.width.set(bbox.width())
        self.height.set(bbox.height())
</t>
<t tx="michael.20061114194524">def check_font_factor(self, renderer):
    for c in self.widest_cells:
        c.check_font_factor(renderer)

</t>
<t tx="michael.20061118232041">inspect_path = to_inspect.path + "."
sources = _get_tasks_of_sources(to_inspect)
sources = [ s + "." for s in sources
            if not inspect_path.startswith(s) ]

# the if in the later line ignores assignments like
# like start = up.start (i.e. references to parents)
# this will be handled in the second if of inspect_depends_on
# and can cause errors otherwise

def inspect_depends_on(task):
    cmp_path = task.path + "."
    for src in sources:
        if cmp_path.startswith(src):
            #task is a source of to_inspect
            return True

    if inspect_path.startswith(cmp_path):
        #to_inspect is a child of task
        return True

    return False</t>
<t tx="michael.20061119042333">changed = event.changed
removed = [ (-ci.get_line(), ci) for op, ci in changed if op == "removed" ]
inserted = [ (ci.get_line(), ci) for op, ci in changed if op == "inserted" ]
changed = [ (ci.get_line(), ci) for op, ci in changed if op == "changed" ]
removed.sort()
inserted.sort()
changed.sort()</t>
<t tx="michael.20061119143304">def __iter__(self):
    return iter(self.task)</t>
<t tx="michael.20061119143714">def __iter__(self):
    return iter(self._task)</t>
<t tx="michael.20061121143813"></t>
<t tx="michael.20061121143813.1">def _set_done(self, value):
    raise AttributeError("The attribute 'done' is readonly.")</t>
<t tx="michael.20061121143813.2">def _set_performed_work_time(self, value):
    raise AttributeError("The attribute 'performed_work_time' is readonly.")</t>
<t tx="michael.20061121143813.3">def _set_booked_resource(self, value):
    raise AttributeError("The attribute 'booked_resource' is readonly.")</t>
<t tx="michael.20061121143813.4">def _set_performed_effort(self, value):
    raise AttributeError("The attribute 'performed_effort' is readonly.")</t>
<t tx="michael.20061121143813.5">def _set_children(self, value):
    raise AttributeError("The attribute 'children' is readonly.")</t>
<t tx="michael.20061121143813.6">def _set_depth(self, value):
    raise AttributeError("The attribute 'depth' is readonly.")</t>
<t tx="michael.20061121143813.7">def _set_index(self, value):
    raise AttributeError("The attribute 'index' is readonly.")</t>
<t tx="michael.20061121143813.8">def _set_scenario(self, value):
    raise AttributeError("The attribute 'scenario' is readonly.")</t>
<t tx="michael.20061121143813.9">def _set_buffer(self, value):
    raise AttributeError("The attribute 'buffer' is readonly.")</t>
<t tx="michael.20061123163317">def __getitem__(self, slice): 
    return self.__class__(self._value[slice], self._ref)</t>
<t tx="michael.20061129124501">@
A performed path can have sub activities appended to the task path.
like:

  root.parent1.parent2.task.subactivity

here rhe correct task path is:

    root.parent1.parent2.task

@code
orpath = rpath
while not task:
    #path can specify a sub module
    #find the correct path to the module
    try:
        last_dot = rpath.rindex(".", 0, len(rpath))
    except ValueError:
        break

    rpath = rpath[:last_dot]
    task = self.get_task(rpath)

item = list(item)
item.append(orpath[len(rpath):])</t>
<t tx="michael.20061201004146">def __calc_estimated_effort(self):
    if self.children:
        return self._to_delta(sum([ t.estimated_effort for t in self.children ]))

    return self.effort

estimated_effort = _TaskProperty(__calc_estimated_effort)
</t>
<t tx="michael.20061230152555">def __calc_performed_effort(self):
    if self.children:
        return self._to_delta(sum([ t.performed_effort for t in self.children ]))

    return pcalendar.Minutes(0)

performed_effort = _TaskProperty(__calc_performed_effort)
</t>
<t tx="michael.20061230173452"></t>
<t tx="michael.20061230173452.1">@doc

</t>
<t tx="michael.20061230174132">@
- Neuer Code Browser ausprobieren. Der folgendermaen luft:
    1. Luft in einem extra thread
    2. komplettes parsen des files in einer neue strutkur
    3. Mittel diff algorithmus die alte strukutur in die neue umwandeln und dabei die obj attribute behalten.
    4. Der explorer wird integriert im python editor
    5. Der Explorer ist voll drag and drop fhig (auch mit mehreren selektieren eintrgen)
    6. Alles kommt nach metapie


- Netzwerk graphiken

- Referenz Dokumentation umstellen: (wird gelesen aus den Source Files)

- Tutorial steuerung

- Release Package: Zusammenfassung von funktionen zur Erzeugung von Software releases.
    </t>
<t tx="michael.20070112120451">def VariableLoad(limit=0):
    """
    Allocates the resource with maximal possible load.
    If limit is given, a the load is at least limit or more.
    """
    try:
        balance = me.balance
    except NameError:
        balance = SLOPPY

    if balance != SLOPPY:
        raise RuntimeError("You may specify variable_load only with balance=SLOPPY")

    return -limit
</t>
<t tx="michael.20070115161719">def __unicode__(self): return unicode(self._value)</t>
<t tx="michael.20070115170252">@language python
&lt;&lt; Copyright &gt;&gt;
"""
Patched versions of buggy wxpython objects
"""
&lt;&lt; Imports &gt;&gt;

_is_source_ = True

@others</t>
<t tx="michael.20070115170327">import wx
from wx.__version__ import VERSION
from metapie.gui import controller</t>
<t tx="michael.20070115204524">def unicode(self, *args): 
    if isinstance(self._value, str):
        return unicode(self._value, *args)

    return unicode(self._value)</t>
<t tx="michael.20070115204909">def unicode(self, *args):
    value = self.value
    try:
        return value.unicode(*args)
    except AttributeError:
        pass

    if isinstance(value, str):
        return unicode(value, *args)

    return unicode(value)
</t>
<t tx="michael.20070116023524">if self.text.find("efficency") &gt;= 0:
    answer = wx.MessageBox(_("The file %s has a misspelled efficiency attribute."\
                             "Sould I correct it?") % path,
                           _("Misspelling Bug"),
                           wx.YES_NO|wx.ICON_QUESTION)
    if answer == wx.YES:
        self.text = self.text.replace("efficency", "efficiency")</t>
<t tx="michael.20070116120608">def move(self, x, y):
    self.MoveXY(x, y)
    self.Hide()
    self.Show()</t>
<t tx="michael.20070116154322">if indent(line(pos)) &gt;= child_indent:
    pos = find(pos - 1, 0, ":")
    continue</t>
<t tx="michael.20070117163707">def unicode(self, *args): 
    if isinstance(self._value, str):
        return unicode(self._value, *args)

    return repr(self)</t>
<t tx="michael.20070421153201">class TaskBarIcon(wx.TaskBarIcon):
    TBMENU_RESTORE = wx.NewId()
    TBMENU_CLOSE   = wx.NewId()

    def __init__(self, frame):
        wx.TaskBarIcon.__init__(self)
        self.frame = frame

        # Set the image
        icon = wx.IconFromBitmap(ResourceManager.load_bitmap("gantt"))
        self.SetIcon(icon, "Faces")
        self.imgidx = 1
        print "taskbar"
        # bind some events
        self.Bind(wx.EVT_TASKBAR_LEFT_DCLICK, self.OnTaskBarActivate)
        self.Bind(wx.EVT_MENU, self.OnTaskBarActivate, id=self.TBMENU_RESTORE)
        self.Bind(wx.EVT_MENU, self.OnTaskBarClose, id=self.TBMENU_CLOSE)


    def CreatePopupMenu(self):
        menu = wx.Menu()
        menu.Append(self.TBMENU_RESTORE, _("Restore Faces"))
        menu.Append(self.TBMENU_CLOSE,   _("Close Faces"))
        return menu


    def MakeIcon(self, img):
        """
        The various platforms have different requirements for the
        icon size...
        """
        if "wxMSW" in wx.PlatformInfo:
            img = img.Scale(16, 16)
        elif "wxGTK" in wx.PlatformInfo:
            img = img.Scale(22, 22)
        # wxMac can be any size upto 128x128, so leave the source img alone....
        icon = wx.IconFromBitmap(img.ConvertToBitmap() )
        return icon


    def OnTaskBarActivate(self, evt):
        if self.frame.IsIconized():
            self.frame.Iconize(False)
        if not self.frame.IsShown():
            self.frame.Show(True)
        self.frame.Raise()


    def OnTaskBarClose(self, evt):
        self.frame.Close()
</t>
<t tx="michael.20070710231245">def calendar(self, scenario):
    try:
        return self._calendar[scenario]
    except KeyError:
        cal = self._calendar[scenario] = ResourceCalendar(self._calendar[None])
        return cal

</t>
<t tx="michael.20070716145002">@language python
&lt;&lt; Copyright &gt;&gt;

import matplotlib as _mp

try:
    import matplotlib.transforms as _mtrans
except NameError:
    _mp.rcParams['numerix'] = "numpy"
    import matplotlib.transforms as _mtrans

_mp.use("Agg")

_is_source = True
</t>
<t tx="michael.20070926121838"></t>
<t tx="michael.20070926130714">#self.Copy and self.Cut fill the clipoard only the second time
#when they are called. ==&gt; this is annyoing an they are replaced
#by wxPython clipboard functions
def copy(clear=False):
    txt = self.GetSelectedText()
    if txt:
        clipboard = wx.Clipboard_Get()
        if clipboard.Open():
            clipboard.SetData(wx.TextDataObject(txt))
            clipboard.Close()
            if clear:
                self.ReplaceSelection("")

def cut():
    copy(True)
</t>
<t tx="michael.20071111221700">def build_mark(self, interval, scale, transform):
    format = self._get_format(interval, transform)
    date = scale.to_num(int(interval[0])).to_datetime()
    quater = 1 + (date.month - 1) / 3
    decade = 10 * (date.year / 10)
    f = format.replace("%Q", str(quater))
    f = f.replace("%D", str(decade))
    return strftime(date, f)</t>
<t tx="michael.20080106130453">def strftime(dt, format):
    """
    an extended version of strftime, that introduces some new
    directives: 
    %IW   iso week number
    %IY   iso year
    %IB   full month name appropriate to iso week
    %ib   abbreviated month name appropriate to iso week
    %im   month as decimal number appropriate to iso week
    """
    iso = dt.isocalendar()
    if iso[0] != dt.year:
        iso_date = dt.replace(day=1, month=1)
        format = format \
                 .replace("%IB", iso_date.strftime("%B"))\
                 .replace("%ib", iso_date.strftime("%b"))\
                 .replace("%im", iso_date.strftime("%m"))
    else:
        format = format \
                 .replace("%IB", "%B")\
                 .replace("%ib", "%b")\
                 .replace("%im", "%m")

    format = format \
             .replace("%IW", str(iso[1]))\
             .replace("%IY", str(iso[0]))\

    return dt.strftime(format)
</t>
<t tx="mr7771.20060608154252"></t>
<t tx="mr7771.20060608164004">@doc
Base modules of faces. These are the only modules to run a simple faces file.
</t>
<t tx="mr7771.20060608164004.452">@doc
library of observers.</t>
<t tx="mr7771.20060608164004.453">@doc
package of chart base functionality.</t>
<t tx="mr7771.20060608164004.454"></t>
<t tx="mr7771.20060608165446"></t>
<t tx="mr7771.20060608165446.4">@language python
&lt;&lt; Copyright &gt;&gt;
"""
Different editor contexts, they depend on the 
source code environemnt of a cursor position.
"""
&lt;&lt; Imports &gt;&gt;

_is_source = True
_ = faces.plocale.get_gettext()

@others</t>
<t tx="mr7771.20060609151433">############################################################################
#   Copyright (C) 2005, 2006, 2007, 2008 by Reithinger GmbH
#   mreithinger@web.de
#
#   This file is part of faces.
#                                                                         
#   faces is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   faces is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the
#   Free Software Foundation, Inc.,
#   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
############################################################################

</t>
<t tx="mr7771.20060609151433.1">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others
</t>
<t tx="mr7771.20060609151433.2">from browser import Browser
from editor import Editor
from metapie.gui import controller
from metapie.navigator import View
import weakref
import ConfigParser
import wx
import faces.plocale
import faces.gui.editor.task
import faces.gui.editor.resource</t>
<t tx="mr7771.20060609151433.3">def is_bool_option(name, default=True):
    try:
        return controller().config.getboolean("DEFAULT", name)
    except ConfigParser.NoOptionError:
        return default
</t>
<t tx="mr7771.20060609151433.4">class PlanEditor(wx.SplitterWindow):
	@others
</t>
<t tx="mr7771.20060609151433.5">def __init__(self, model):
    wx.SplitterWindow.__init__(self, controller().hidden_parent, 
                               -1, style=wx.SP_3DSASH)
    self.browser_menu = None
    self.browser = Browser(self)
    self.editor = Editor(model, self)
    self.browser.bind_events()
    self.Initialize(self.editor)
    &lt;&lt; redirect methods &gt;&gt;
    self.editor.SetMinSize((0, 0))
    self.Bind(wx.EVT_SPLITTER_UNSPLIT, self._on_unsplit)
    self.Bind(wx.EVT_SPLITTER_SASH_POS_CHANGING, self._on_shash_pos_change)

    if is_bool_option("show_browser"):
        wx.CallAfter(self.toggle_browser)</t>
<t tx="mr7771.20060609151433.7">def _on_unsplit(self, event):
    if event.GetWindowBeingRemoved() is self.browser:
        self.browser.open_width = self.browser.GetSize()[0]
        self.browser_menu.check(False)
    else:
        raise RuntimeError("editor may not unsplit")

</t>
<t tx="mr7771.20060609151433.8">def toggle_browser(self, show=None):
    if show is None:
        show = not self.browser.IsShown()

    if show:
        try:
            width = self.browser.open_width
        except AttributeError:
            width = self.browser.width

        if self.IsSplit():
            self.SetSashPosition(width)
        else:
            self.browser.Show()
            self.SplitVertically(self.browser, self.editor, width)

        self.browser.update_menus()
        self.SetSashGravity(0.0)
    elif self.IsSplit():
        self.browser.open_width = self.browser.GetSize()[0]
        self.Unsplit(self.browser)
        self.browser.Hide()

    try:
        self.browser_menu.check(show)
    except AttributeError: pass

    controller().config.set("DEFAULT", "show_browser", str(show))
</t>
<t tx="mr7771.20060609151433.9">def goto_line(self, line):
    editor = self.editor
    pos = editor.PositionFromLine(line - 1)
    editor.GotoPos(pos)
    editor.SetFocus()
</t>
<t tx="mr7771.20060609151433.10">def find_in_source(self, obj):
    self.editor.show_object(obj)
    self.editor.SetFocus()
</t>
<t tx="mr7771.20060609152050">@language python
&lt;&lt; Copyright &gt;&gt;
&lt;&lt; Imports &gt;&gt;
_is_source_ = True
_ = faces.plocale.get_gettext()

@others
</t>
<t tx="mr7771.20060609152050.1">import faces.observer
import wx
import matplotlib.backends.backend_wxagg as wxagg
import matplotlib.backend_bases as bases
import matplotlib.transforms as mtrans
import matplotlib.numerix as numerix
import matplotlib.font_manager as font
import matplotlib.figure as figure
import matplotlib.numerix as numerix
import metapie.navigator as navigator
from metapie.gui import controller
import datetime
import faces.task
import faces.charting.tools as tools
import faces.charting.charts as charts
import faces.gui.editor.context as context
import faces.plocale
import taskfuncs
import sys
import matplot_patches as mpatch
import math
from tipwindow import TipWindow
import print_chart



</t>
<t tx="mr7771.20060609152050.2">def _cint(x):
    return int(math.ceil(x))
</t>
<t tx="mr7771.20060609152050.3">def _nop():
    pass
</t>
<t tx="mr7771.20060609152050.4">tools.set_default_size(6)

def _chart_factory(title, chart, model):
    return lambda parent: ChartView(parent, chart, model, title)
</t>
<t tx="mr7771.20060609152050.5">def _timechart_factory(title, chart, model):
    return lambda parent: TimeChartView(parent, chart, model, title)
</t>
<t tx="mr7771.20060609152050.6">

faces.observer.factories["matplot_chart"] = _chart_factory
faces.observer.factories["matplot_pointchart"] = _chart_factory
faces.observer.factories["matplot_timechart"] = _timechart_factory


cursord = {
    bases.cursors.MOVE : wx.CURSOR_HAND,
    bases.cursors.HAND : wx.CURSOR_HAND,
    bases.cursors.POINTER : wx.CURSOR_ARROW,
    bases.cursors.SELECT_REGION : wx.CURSOR_CROSS,
    }


class _ErrorChart(charts.TimeAxisWidgetChart):
	&lt;&lt; class _ErrorChart declarations &gt;&gt;
	@others
</t>
<t tx="mr7771.20060609152050.7">data = True
scroll_bars = False

</t>
<t tx="mr7771.20060609152050.8">def create(self):
    self.set_time_axis()
    fig = self.figure
    fig.clf()        
    fig.text(0.5, 0.5, 'Error in chart',
             fontsize='xx-large',
             color='red',
             horizontalalignment='center',
             verticalalignment='center')

    pprop = self.get_patch
    self.axes.set_frame_on(False)
    self.time_axis.time_scale = self.time_scale
    self.time_axis.show_scale = False
    self.time_axis.show_grid = False
    self.axes.set_time_axis(self.time_axis)
    self.axes.xaxis_timescale(self.time_scale)
    self.axes.set_marker(pprop("focused.marker"), pprop("marker"))

    xmin = self.time_scale.to_num("1.1.2005")
    xmax = self.time_scale.to_num("10.1.2005")
    self.axes.set_time_lim(xmin, xmax)
    self.axes.dataLim.intervalx().set_bounds(xmin, xmax)
    self.axes.dataLim.intervaly().set_bounds(0, 1)
</t>
<t tx="mr7771.20060609152050.9">class Toolbar(bases.NavigationToolbar2):
	@others
</t>
<t tx="mr7771.20060609152050.10">def _init_toolbar(self):
    view = self.canvas.GetParent()
    self.create_menus()
</t>
<t tx="mr7771.20060609152050.11">def create_menus(self):
    view = self.canvas.GetParent()
    ctrl = controller()
    toolbar = ctrl.get_toolbar()

    def hzin(): view.horz_zoom(2)
    def hzout(): view.horz_zoom(-2)
    def vzin(): view.vert_zoom(2)
    def vzout(): view.vert_zoom(-2)

    toolbar.make_tool(view, "home", self.home, "home",
                      short=_("Home"))
    self.back_tool = toolbar.make_tool(view, "back",
                                       self.back, "back",
                                       short=_("Back"))
    self.fore_tool = toolbar.make_tool(view, "forward",
                                       self.forward, 'forward',
                                      short=_("Forward"))
    self.pan_tool = toolbar.make_tool(view, "move", self.pan, "move",
                                      kind=wx.ITEM_CHECK,
                                      short=_("Move Tool"))
    self.zoom_tool = toolbar.make_tool(view, "zoom", self.zoom,
                                       "zoom_to_rect",
                                       kind=wx.ITEM_CHECK,
                                      short=_("Zoom Tool"))
    toolbar.make_separator("home", True)
    toolbar.make_tool(view, "x-fit", view.zoom_to_fit, "viewmagfit22",
                      short=_("zoom to fit"))
    toolbar.make_tool(view, "x-zoomout", hzout, "mag-horz22",
                      short=_("zoom out horizontally"))
    toolbar.make_tool(view, "x-zoomin", hzin, "mag+horz22",
                      short=_("zoom in horizontally"))
    toolbar.make_tool(view, "y-zoomout", vzout, "mag-vert22",
                      short=_("zoom out vertically"))
    toolbar.make_tool(view, "y-zoomin", vzin, "mag+vert22",
                      short=_("zoom in vertically"))
    toolbar.make_separator("x-fit", True)
    self.refresh_buttons()
    self.make_menu()
</t>
<t tx="mr7771.20060609152050.12">def make_menu(self, popup=False):
    ctrl = controller()
    view = self.canvas.GetParent()

    if popup:
        chart_menu = ctrl.make_menu()
    else:
        top = ctrl.get_top_menu()
        chart_menu = top.make_menu(_("&amp;Chart"), pos=200)

    menu = lambda *args, **kw: chart_menu.make_item(view, *args, **kw)

    def find_in_source(): view.model.find_in_source(view.chart.__class__)

    def menu_print_chart():
        dlg = print_chart.PrintChart(controller().frame,
                                     self.canvas.GetParent().chart)
        dlg.simulate_modal(self.canvas.GetParent())


    menu(_("Print Chart..."), menu_print_chart, "print16", pos=100)

    if not popup:
        def hzin(): view.horz_zoom(2)
        def hzout(): view.horz_zoom(-2)
        def vzin(): view.vert_zoom(2)
        def vzout(): view.vert_zoom(-2)
        menu(_("Horizontal Zoom In\tCTRL-."), hzin, "mag+horz16", pos=10)
        menu(_("Horizontal Zoom Out\tCTRL-,"), hzout, "mag-horz16", pos=20)
        menu(_("Fit in Window"), view.zoom_to_fit, pos=30)
        chart_menu.make_separator(_("Fit in Window"))

    menu(_("Duplicate Chart"), view.duplicate, "duplicate_view16", pos=120)\
                      .enable(not hasattr(view, "_original"))
    menu(_("Find in Source"), find_in_source, "findsource16", pos=130)
    self.link_menu = menu(_("&amp;Link Chart"), view.change_link, 
                          check_item=True, pos=140)
    self.link_menu.check(view.link_view)

    chart_menu.make_separator(_("&amp;Link Chart"))
    return chart_menu

</t>
<t tx="mr7771.20060609152050.13">def refresh_buttons(self):
    if self.pan_tool.is_pressed() != (self._active == 'PAN'):
        self.pan_tool.toggle(self._active == 'PAN')

    if self.zoom_tool.is_pressed() != (self._active == 'ZOOM'):
        self.zoom_tool.toggle(self._active == 'ZOOM')
</t>
<t tx="mr7771.20060609152050.14">def set_history_buttons(self):
    can_backward = (self._views._pos &gt; 0)
    can_forward = (self._views._pos &lt; len(self._views._elements) - 1)
    self.back_tool.enable(can_backward)
    self.fore_tool.enable(can_forward)
</t>
<t tx="mr7771.20060609152050.15">def set_cursor(self, cursor):
    cursor = wx.StockCursor(cursord[cursor])
    self.canvas.SetCursor(cursor)
</t>
<t tx="mr7771.20060609152050.16">__last_rect = None
def draw_rubberband(self, event, x0, y0, x1, y1):
    #take from backend_wx
    canvas = self.canvas
    dc = wx.ClientDC(canvas)

    # Set logical function to XOR for rubberbanding
    dc.SetLogicalFunction(wx.XOR)

    wbrush = wx.Brush(wx.Colour(255,255,255), wx.TRANSPARENT)
    wpen = wx.Pen(wx.Colour(200, 200, 200), 1, wx.SOLID)
    dc.SetBrush(wbrush)
    dc.SetPen(wpen)

    dc.ResetBoundingBox()
    dc.BeginDrawing()
    height = self.canvas.figure.bbox.height()
    y1 = height - y1
    y0 = height - y0

    if y1 &lt; y0: y0, y1 = y1, y0
    if x1 &lt; y0: x0, x1 = x1, x0

    w = x1 - x0
    h = y1 - y0

    rect = (int(x0), int(y0), int(w), int(h))
    if self.__last_rect: dc.DrawRectangle(*self.__last_rect) #erase last
    self.__last_rect = rect
    dc.DrawRectangle(*rect)
    dc.EndDrawing()
</t>
<t tx="mr7771.20060609152050.17">def release(self, event):
    self.__last_rect = None
</t>
<t tx="mr7771.20060609152050.18">def mouse_move(self, event):
    bases.NavigationToolbar2.mouse_move(self, event)
    self.canvas.GetParent().mouse_over(event)
</t>
<t tx="mr7771.20060609152050.19">class ChartView(wx.PyScrolledWindow, navigator.View):
	@others
</t>
<t tx="mr7771.20060609152050.20">def __init__(self, parent, chart, model, title):
    wx.PyScrolledWindow.__init__(self, parent, -1)

    tmpdc = wx.ClientDC(parent)
    dpi = tmpdc.GetPPI()[0]
    del tmpdc
    self.dpi = float(dpi)
    self.has_focus = False
    self.canvas = None
    self.chart = None
    self.model = model
    self.marked_widget = None
    self._is_ready = False
    self.timer = wx.Timer(self)
    self.deferred_func = None
    self.deferred_args = None
    self.link_view = True
    self.toolbar = None
    self.replace_data(chart)
</t>
<t tx="mr7771.20060609152050.21">def Destroy(self):
    self.timer.Stop()
    wx.PyScrolledWindow.Destroy(self)
</t>
<t tx="mr7771.20060609152050.22">def replace_data(self, chart):
    if self.canvas:
        self.figure.clf()
        self.canvas.Destroy()

    last_trans = None
    if self.chart and not isinstance(self.chart, _ErrorChart):
        last_trans = self.chart._trans_data

    self.figure = figure.Figure(dpi=self.dpi)
    self.canvas = mpatch.FigureCanvasWx(self, -1, self.figure)
    self.canvas.mpl_connect('button_press_event', self.mouse_button)
    charts._figure_manager.canvas = self.canvas
    self.SetTargetWindow(self.canvas)
    self.create_chart(chart)

    if self.toolbar:
        views = self.toolbar._views
        self.toolbar = Toolbar(self.canvas)
        self.toolbar._views = views
    else:
        self.toolbar = Toolbar(self.canvas)

    self.show_horz_bar = self.show_vert_bar = self.chart.scroll_bars
    self.link_view = not self.chart.link_view
    self.change_link()
    self.init_scrolling()

    if self.is_visible():
        self.become_visible(last_trans)
</t>
<t tx="mr7771.20060609152050.23">def init_scrolling(self):
    get_bbox_transform = mtrans.get_bbox_transform
    unit_bbox = mtrans.unit_bbox
    dlim = self.chart._data_lim.deepcopy()
    dlim.intervalx().set_bounds(dlim.xmin(), dlim.xmax())
    dlim.intervaly().set_bounds(dlim.ymax(), dlim.ymin())
    self.scroll_trans = get_bbox_transform(dlim, unit_bbox())
</t>
<t tx="mr7771.20060609152050.24">def scale_figure(self, trans):
    if trans:
        self._on_size(None)
        self.check_limits()
        vb = self.chart._bbox
        xmin, ymin = trans.inverse_xy_tup((vb.xmin(), vb.ymin()))
        xmax, ymax = trans.inverse_xy_tup((vb.xmax(), vb.ymax()))
        self.chart._set_xlim(xmin, xmax)
        self.chart._set_ylim(ymin, ymax)
    else:
        self.SetScrollbar(wx.VERTICAL, 0, 1, 10, False)
        self.SetScrollbar(wx.HORIZONTAL, 0, 1, 10, False)
        self._on_size(None)
        self.check_limits()
        self.chart._autoscale_view()

    self.setup_scrolling()
</t>
<t tx="mr7771.20060609152050.25">def check_limits(self):
    self.chart._check_limits()
</t>
<t tx="mr7771.20060609152050.26">def create_chart(self, chart):
    save_execute = controller().session.save_execute
    self.chart = save_execute(chart, self.figure)
    if not self.chart: self.chart = _ErrorChart(self.figure)
</t>
<t tx="mr7771.20060609152050.27">def _setup_events(self):
    wx.EVT_TIMER(self, -1, self._on_timer)
    wx.EVT_SIZE(self, self._on_size)
    wx.EVT_IDLE(self, self._on_idle)
    wx.EVT_SET_FOCUS(self, self._on_set_focus)
    wx.EVT_KILL_FOCUS(self, self._on_kill_focus)
</t>
<t tx="mr7771.20060609152050.28">def become_visible(self, last_trans=None):
    if not last_trans:
        self._setup_events()
        self._is_ready = True

    self.scale_figure(last_trans)
    #force update (inclusive scrolling)
    self._last_data_bounds = (0, 0, 0, 0)             
    self.update_state()
</t>
<t tx="mr7771.20060609152050.29">def duplicate(self):
    class Unshared(self.chart.__class__):
        sharex = datetime.datetime.today() # should never be shared

    org_chart = id(self.chart.__class__)

    def is_duplicate(view):
        return isinstance(view, ChartView) \
               and getattr(view, "_original", 0) == org_chart

    duplicates = filter(is_duplicate, controller().get_all_views())
    if duplicates:
        duplid = max(map(lambda v: v._duplid, duplicates)) + 1
    else:
        duplid = 1

    model = self.model
    title = self._nav_title + "(%i)" % duplid
    factory_args = (self.__class__, Unshared, model, title) 
    view = controller().produce_view(model, title, factory_args)
    view._original = org_chart
    view._duplid = duplid
</t>
<t tx="mr7771.20060609152050.30">def zoom_to_fit(self):
    self.chart._autoscale_view()
    self.update_state(True)
</t>
<t tx="mr7771.20060609152050.31">def horz_zoom(self, step):
    self.chart._zoomx(step)
    self.update_state(True)
</t>
<t tx="mr7771.20060609152050.32">def vert_zoom(self, step):
    self.chart._zoomy(step)
    self.update_state(True)
</t>
<t tx="mr7771.20060609152050.33">def scroll(self, direction, delta):
    if direction == wx.HORIZONTAL:
        self._scroll_adjustments[4] = self.GetScrollPos(direction) + delta
    else:
        self._scroll_adjustments[5] = self.GetScrollPos(direction) + delta

    self.SetScrollbars(*self._scroll_adjustments)
</t>
<t tx="mr7771.20060609152050.34">def change_link(self):
    self.link_view = not self.link_view
    self.toolbar.link_menu.check(self.link_view)
</t>
<t tx="mr7771.20060609152050.35">def deferred(self, time_out, func, *args):
    self.deferred_func = func
    self.deferred_args = args
    self.timer.Start(time_out, wx.TIMER_ONE_SHOT)
</t>
<t tx="mr7771.20060609152050.36">def _on_timer(self, event):
    self.timer.Stop()
    if self.deferred_func:
        self.deferred_func(*self.deferred_args)
        self.deferred_args = None
        self.deferred_func = None
</t>
<t tx="mr7771.20060609152050.37">def mouse_over(self, event):
    if event.xdata is None: return
    widget = self.chart._widget_at(event.xdata, event.ydata)
    if not TipWindow.get().is_widget_active(widget):
        self.deferred(1000, self._show_info)

    try:
        date = event.inaxes.time_scale.to_num(int(event.xdata))
        controller().status_bar.SetStatusText(repr(date), 2)
    except AttributeError:
        pass
</t>
<t tx="mr7771.20060609152050.38">def mark_widget(self, widget, axes=None):
    self.marked_widget = widget
    return self.chart._mark_widget(widget)
</t>
<t tx="mr7771.20060609152050.39">def mouse_button(self, event):
    if self.toolbar._active: return

    if event.button in (1, 3):
        #mark widget
        try:
            axes = event.inaxes
            widget = self.chart._widget_at(event.xdata, event.ydata)
            if self.mark_widget(widget, axes): self.draw()
        except AttributeError:
            widget = None

        fobj = getattr(widget, "fobj", None)
        fattrib = getattr(widget, "fattrib", None)

        if isinstance(fobj, faces.task.Task):
            taskfuncs.make_menu_task_clipboard(controller(), fobj)
        else:
            taskfuncs.remove_menu_task_clipboard(controller())

        if self.link_view and fobj:
            self.model.show_object(self, fobj, fattrib)


    if event.button == 3:
        # context menu
        self.timer.Stop()
        menu = self.toolbar.make_menu(True)

        if fobj:
            try:
                code_item = fobj._function.code_item
            except AttributeError:
                pass
            else:
                taskfuncs.make_menu_task_clipboard(controller(), fobj, menu, 500)
                action_filter = ("add", "edit", "extra")
                for c in context.Context.context_list:
                    c = c.__class__(code_item)
                    if c.make_browser_menu(menu, action_filter):
                        break


        self.PopupMenu(menu.wxobj, (event.x,
                                    self.GetClientSizeTuple()[1] - event.y))


</t>
<t tx="mr7771.20060609152050.40">def _on_size(self, event):
    if self.canvas:
        self.canvas.SetSize(self.GetClientSizeTuple())
</t>
<t tx="mr7771.20060609152050.41">def _show_info(self):
    x, y = self.mouse_pos_data()
    if x is None: return
    widget = self.chart._widget_at(x, y)
    if widget:
        info = self.chart.get_tip(widget)
        if info:
            TipWindow.get().set_info(info, widget)
</t>
<t tx="mr7771.20060609152050.42">def mouse_pos_data(self):
    x, y = self.ScreenToClientXY(*wx.GetMousePosition())
    w, h = self.GetClientSizeTuple()
    if 0 &lt;= x &lt; w and 0 &lt;= y &lt; h:
        y = h - y
        return self.chart._trans_data.inverse_xy_tup((x, y))

    return None, None
</t>
<t tx="mr7771.20060609152050.43">_yscroll = 0
_xscroll = 0
def setup_scrolling(self):
    sdata = self.scroll_trans.get_bbox1()
    vlim = mtrans.transform_bbox(self.chart._trans_data, sdata)
    sview = self.scroll_trans.get_bbox2()

    width = _cint(vlim.width())
    height = _cint(-vlim.height())

    sview.intervalx().set_bounds(0, width)
    sview.intervaly().set_bounds(0, height)
    self.SetVirtualSize((width, height))

    xrate = self.show_horz_bar and 20 or 0
    yrate = self.show_vert_bar and 20 or 0

    vlim = self.chart._view_lim
    x, y = self.scroll_trans.xy_tup((vlim.xmin(), vlim.ymax()))
    self._xscroll = _cint(x / 20)
    self._yscroll = _cint(y / 20)
    self._scroll_adjustments = [xrate, yrate, 10+width/20, 10+height/20,
                                self._xscroll, self._yscroll, True]

    self.SetScrollbars(*self._scroll_adjustments)
    self.AdjustScrollbars()
    self.EnableScrolling(False, False)
</t>
<t tx="mr7771.20060609152050.44">def _on_set_focus(self, event):
    self.has_focus = True
    self.toolbar.create_menus()
    self.chart._set_focused_on()
    self.draw()
</t>
<t tx="mr7771.20060609152050.45">def _on_kill_focus(self, event):
    self.has_focus = False
    self.chart._set_focused_off()
    self.draw()
</t>
<t tx="mr7771.20060609152050.46">    #controller().status_bar.SetStatusText("", 2)


_last_data_bounds = (0, 0, 0, 0)
_last_view_bounds = (0, 0, 1, 1)
def update_state(self, push_view=False):
    if not self._is_ready: return

    def calc_scale(data, view):
        return (int(100 * float(data[2]) / (view[2] or 1.0)),\
                int(100 * float(data[3]) / (view[3] or 1.0)))

    result = False
    trans = self.chart._trans_data
    data_box = trans.get_bbox1()

    data_bounds = map(int, data_box.get_bounds())
    view_bounds = map(int, trans.get_bbox2().get_bounds())

    if self._last_data_bounds != data_bounds or \
       self._last_view_bounds != view_bounds:
        self.check_limits()
        data_bounds = map(int, data_box.get_bounds())
        last_scale = calc_scale(self._last_data_bounds,
                                self._last_view_bounds)
        scale = calc_scale(data_bounds, view_bounds)
        if last_scale != scale:
            try:
                self.deferred(1000, self.chart._speed_up, 1024*1024*30)
                self.chart._clear_speed_cache()
            except AttributeError:
                pass

        self.draw()
        self.setup_scrolling()
        if push_view: self.toolbar.push_current()
        self._last_view_bounds = view_bounds
        self._last_data_bounds = data_bounds


    x, y = self.GetViewStart()
    if y != self._yscroll or x != self._xscroll:
        xt, yt = self.scroll_trans.inverse_xy_tup((x * 20, y * 20))
        if x != self._xscroll and self.show_horz_bar:
            self.chart._set_xlim(xt, xt + data_box.width())

        if y != self._yscroll and self.show_vert_bar:
            self.chart._set_ylim(yt - data_box.height(), yt)
</t>
<t tx="mr7771.20060609152050.47">def _on_idle(self, event):
    try:
        if self.has_focus: self.toolbar.refresh_buttons()
        self.update_state()
    except:
        pass
</t>
<t tx="mr7771.20060609152050.48">def show_object(self, fobj, attrib=None, caller=None):
    if not self.link_view: return
    widget = self.chart._find_widget(fobj)
    self.deferred(300, self._show_widget, widget, caller)
</t>
<t tx="mr7771.20060609152050.49">def _show_widget(self, widget, caller):
    if widget:
        if self.show_x_coord(caller):
            self.chart._widget_x_visible(widget)

        self.chart._widget_y_visible(widget)

    if self.mark_widget(widget):
        self._last_view_bounds = (0, 0, 1, 1) # force update
        self.update_state()
</t>
<t tx="mr7771.20060609152050.50">def show_x_coord(self, caller):
    return True
</t>
<t tx="mr7771.20060609152050.51">def accept_sibling(self, new_view):
    import editor
    if isinstance(new_view, editor.PlanEditorProxy):
        return navigator.SIBLING_BELOW

    import repview
    if isinstance(new_view, repview.ReportView):
        return navigator.SIBLING_BELOW

    if isinstance(new_view, ChartView):
        return navigator.SIBLING_BELOW

    return False
</t>
<t tx="mr7771.20060609152050.52">def draw(self):
    self.check_limits()
    self.canvas.draw()
</t>
<t tx="mr7771.20060609152050.53">


class TimeViewManager(object):
	&lt;&lt; class TimeViewManager declarations &gt;&gt;
	@others
</t>
<t tx="mr7771.20060609152050.54">_managers = { }

</t>
<t tx="mr7771.20060609152050.55">def get_manager(view, chart_class):
    key = str(chart_class.sharex)
    if not key:
        key = chart_class.__name__

    manager = TimeViewManager._managers.get(key)
    if not manager: 
        manager = TimeViewManager(key)
        manager._managers[key] = manager

    manager.register(view)
    return manager
</t>
<t tx="mr7771.20060609152050.56">get_manager = staticmethod(get_manager)

def __init__(self, key):
    self.key = key
    self.views = []
    self.main_axes = None
    self.xmin = sys.maxint
    self.xmax = -sys.maxint
</t>
<t tx="mr7771.20060609152050.57">def register(self, view):
    self.views.append(view)
</t>
<t tx="mr7771.20060609152050.58">def unregister(self, view, refresh=True):
    del self.views[self.views.index(view)]
    if not self.views:
        del self._managers[self.key]
    elif refresh:
        self.update_siblings(view)
</t>
<t tx="mr7771.20060609152050.59">def update_siblings(self, caller_view):
    if not self.main_axes:
        self.main_axes = self.views[0].chart._share_axes

    if self.views[0] == caller_view:
        v = self.views[0]
        axes = v.chart._share_axes
        axes.unshare()

        show_scale = axes.time_axis.show_scale
        if getattr(v, "_show_scale", show_scale) != show_scale:
            axes.time_axis.show_scale = v._show_scale
            axes.update_time_axis()
            v.draw()

        v._current_show_scale = show_scale
        v.show_horz_bar = v.show_vert_bar
        self._update_scroll_info()
        return

    ctrl = controller()
    pos_views = map(lambda v: (ctrl.get_active_view_pos(v), v), self.views)
    pos_views.sort()

    first = pos_views[0][1]
    last = pos_views[-1][1]
    for p, v in pos_views:
        if not hasattr(v, "_show_scale"):
            v._show_scale = v.chart.show_scale

        axes = v.chart._share_axes
        axes.time_axis.show_scale = v == first
        axes.update_time_axis()

        v.show_horz_bar = v == last
        v.setup_scrolling()

    self._update_scroll_info()
</t>
<t tx="mr7771.20060609152050.60">def _update_scroll_info(self):
    for v in self.views:
        if v.show_horz_bar:
            interval = v.scroll_trans.get_bbox1().intervalx()
            interval.set_bounds(self.xmin, self.xmax)
            v.setup_scrolling()
            return
</t>
<t tx="mr7771.20060609152050.61">def update_xlim(self, xmin, xmax):
    self.xmin = min(self.xmin, xmin)
    self.xmax = max(self.xmax, xmax)
</t>
<t tx="mr7771.20060609152050.62">def shared(self):
    return self.main_axes
</t>
<t tx="mr7771.20060609152050.63">def get_sibling_pos(self, view):
    key = view.manager.key
    if key &lt; self.key:
        return navigator.SIBLING_ABOVE

    return navigator.SIBLING_BELOW
</t>
<t tx="mr7771.20060609152050.64">


class TimeChartView(ChartView):
	@others
</t>
<t tx="mr7771.20060609152050.65">def __init__(self, parent, chart, model, title):
    self.manager = None
    ChartView.__init__(self, parent, chart, model, title)
</t>
<t tx="mr7771.20060609152050.66">def create_chart(self, chart):
    if self.manager: self.manager.unregister(self, self.show_horz_bar)
    self.manager = TimeViewManager.get_manager(self, chart)
    save_execute = controller().session.save_execute
    self.chart = save_execute(chart, self.figure,
                              sharex=self.manager.shared())
    if not self.chart: self.chart = _ErrorChart(self.figure)
</t>
<t tx="mr7771.20060609152050.67">def scale_figure(self, trans):
    try:
        self.manager.update_siblings(self)
    except AttributeError:
        #can happen in windows if you click to fast
        #for shared charts.
        self.show_horz_bar = True # make sure the view can scroll

    ChartView.scale_figure(self, trans)
</t>
<t tx="mr7771.20060609152050.68">def Destroy(self):
    if self.manager:
        self.manager.unregister(self)
        self.manager = None

    controller().status_bar.SetStatusText("", 2)
    ChartView.Destroy(self)
</t>
<t tx="mr7771.20060609152050.69">def accept_sibling(self, new_view):
    import editor
    if isinstance(new_view, editor.PlanEditorProxy):
        return navigator.SIBLING_BELOW

    import repview
    if isinstance(new_view, repview.ReportView):
        return navigator.SIBLING_BELOW

    if isinstance(new_view, TimeChartView):
        return self.manager.get_sibling_pos(new_view)

    return False
</t>
<t tx="mr7771.20060609152050.70">def show_x_coord(self, caller):
    return caller not in self.manager.views
</t>
<t tx="mr7771.20060609152050.71">def init_scrolling(self):
    get_bbox_transform = mtrans.get_bbox_transform
    unit_bbox = mtrans.unit_bbox
    dlim = self.chart._data_lim.deepcopy()
    self.scroll_trans = get_bbox_transform(dlim, unit_bbox())
    dlim.intervaly().set_bounds(dlim.ymax(), dlim.ymin())
    self.manager.update_xlim(dlim.xmin() - dlim.width(),
                             dlim.xmax() + dlim.width())
</t>
<t tx="mr7771.20060609154937">@language python
&lt;&lt; Copyright &gt;&gt;
"""
Project Browser
"""
&lt;&lt; Imports &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others
</t>
<t tx="mr7771.20060609154937.1">import wx
import wx.stc
import wx.gizmos
import metapie.gui.pyeditor as pyeditor
import itertools
import faces.task as ftask
import faces.resource as fresource
import faces.observer as fobserver
import locale
import weakref
import metapie.gui.pyeditor as pyeditor
import context
from metapie.gui.controller import controller, ResourceManager
import faces.plocale
from classifiers import *


</t>
<t tx="mr7771.20060609154937.2">class Browser(wx.gizmos.TreeListCtrl):
	&lt;&lt; declarations &gt;&gt;
	@others</t>
<t tx="mr7771.20060609154937.3">img_size = (16, 16)
left_sep = 4 # a work around for the wrong indent
last_item = None
</t>
<t tx="mr7771.20060609154937.4">@doc
displayed_eval_map:
  maps a project._idendity_() to the currently displayed evaluation data
@code
def __init__(self, parent):
    wx.gizmos.TreeListCtrl.__init__(self, parent, -1,
                                    style= wx.TR_SINGLE | \
                                    wx.TR_HAS_BUTTONS | \
                                    wx.TR_HIDE_ROOT | \
                                    wx.LC_NO_HEADER |\
                                    wx.TR_FULL_ROW_HIGHLIGHT)

    self.Hide()
    self.idle_item = None
    self.drag_item = None
    self.image_map = {}
    self.displayed_eval_map = {} 
    self.init_tree()
    self.update_menus()

</t>
<t tx="mr7771.20060609154937.5">def get_image_index(self, path):
    try:
        return self.image_map[path]
    except KeyError:
        if path is None: return -1
        bmp = ResourceManager.load_bitmap(path, self.img_size)
        r = self.image_map[path] = self.image_list.Add(bmp)
        return r
</t>
<t tx="mr7771.20060609154937.7">def set_image(self, item, closed=None, opened=None):
    if closed:
        self.SetItemImage(item, self.get_image_index(closed),
                          which=wx.TreeItemIcon_Normal)

    if opened:
        self.SetItemImage(item, self.get_image_index(opened),
                          which=wx.TreeItemIcon_Expanded)
</t>
<t tx="mr7771.20060609154937.8">def get_item_font(self, item):
    font = self.GetItemFont(item)
    if not font.Ok(): font = self.GetFont()
    return font
</t>
<t tx="mr7771.20060609154937.10">def modify_item(self, tree_item):
    item = self.GetPyData(tree_item)
    if not item: return

    iclosed = None
    iopened = None

    if is_project(item) or is_task(item):
        &lt;&lt; make task &gt;&gt;

    elif is_resource(item):
        &lt;&lt; make resource &gt;&gt;

    elif is_observer(item):
        &lt;&lt; make observer &gt;&gt;

    if not iclosed:
        if item.obj_type == pyeditor.FUNCTION:
            iopened = iclosed = "exec16"
        elif item.obj_type == pyeditor.CLASS:
            iopened = iclosed = "class16"

    self.set_image(tree_item, iclosed, iopened)
</t>
<t tx="mr7771.20060609154937.11">def get_section(self, code_item):
    if is_import(code_item): return self.imports
    if is_resource(code_item): return self.resources
    if is_project(code_item): return self.tasks
    if is_evaluation(code_item): return self.evaluations
    if is_observer(code_item): return self.observers
    return self.miscellaneous</t>
<t tx="mr7771.20060609154937.12">def refresh(self):
    #optimization the module has not changed the browser will not change
    editor = self.GetParent().editor
    self.idle_item = None
    self.Freeze()

    &lt;&lt; Delete children &gt;&gt;

    &lt;&lt; Declarations &gt;&gt;
    &lt;&lt; Insert Nodes &gt;&gt;

    self.Thaw()

    self.width = width + offset
    #start idleing at self.imports
    self.idle_item = self.imports

    item = editor.current_code_item()
    if item: self.update_selection(item)
</t>
<t tx="mr7771.20060609154937.14">def init_tree(self):
    img = self.get_image_index
    append = self.AppendItem
    self.Freeze()

    self.width = 0
    self.image_list = wx.ImageList(*self.img_size)
    self.get_image_index("move")
    self.AssignImageList(self.image_list)
    self.GetHeaderWindow().Hide()

    &lt;&lt; Create Columns &gt;&gt;
    &lt;&lt; Insert Header Nodes &gt;&gt;
    &lt;&lt; Set Header Node Fonts &gt;&gt;
    &lt;&lt; Set Header Node Titles &gt;&gt;

    self.imports = imports
    self.miscellaneous = miscellaneous
    self.resources = resources
    self.tasks = tasks
    self.evaluations = evaluations
    self.observers = observers

    self.SelectItem(imports)
    self.Thaw()

</t>
<t tx="mr7771.20060609154937.15">def calc_column_widths(self, item=None):
    item = item or self.GetFirstChild(self.tasks)[0]
    if not item.IsOk(): return

    hidden_window = self.GetHeaderWindow()
    extent = hidden_window.GetTextExtent

    hidden_window.SetFont(self.get_item_font(item))
    for i, cw in enumerate(self.col_width):
        width = extent(self.GetItemText(item, i + 2))[0]
        self.col_width[i] = max(cw, width + 10)
</t>
<t tx="mr7771.20060609154937.17">def _on_size(self, event):
    w, h = self.GetClientSize()
    self.GetMainWindow().SetDimensions(0, 0, w, h)
    self.SetColumnWidth(0, self.left_sep)

    if w &gt; self.width:
        self.SetColumnWidth(1, self.width)
        sw = self.width
        fit_col = 1
        fit_width = sw
        for i, cw in enumerate(self.col_width):
            sw += cw
            if sw &lt; w:
                fit_col = i + 1
                fit_width += cw
            else:
                self.SetColumnWidth(i + 2, 0)

        additional = (w - fit_width) / fit_col
        for i in range(fit_col):
            cw = self.col_width[i]
            self.SetColumnWidth(i + 2, cw + additional)
            sw += cw


    else:
        self.SetColumnWidth(1, w)
        for i in range(2, self.GetColumnCount()):
            self.SetColumnWidth(i, 0)
</t>
<t tx="mr7771.20060609154937.18">def _on_refresh(self, event):
    self.Refresh()
</t>
<t tx="mr7771.20060609154937.19">def _on_sel_changed(self, event):
    if not self.drag_item:
        self.select_item(event.GetItem())
</t>
<t tx="mr7771.20060609154937.20">def select_item(self, item):
    try:
        editor = self.GetParent().editor
        item = self.GetPyData(item)
        if editor.context.code_item is item: return

        line = item.get_line()
        editor.LineScroll(0, line - editor.GetFirstVisibleLine())
        editor.GotoPos(editor.PositionFromLine(line))
        wx.CallAfter(editor.SetFocus)
    except: pass
</t>
<t tx="mr7771.20060609154937.21">def update_selection(self, item):
    try:
        if not item.tree_obj:
            print "error no item.tree_obj", item.name
            return

        if item.tree_obj.IsOk():
            self.SelectItem(item.tree_obj)
        return
    except AttributeError: pass
</t>
<t tx="mr7771.20060609154937.22">def _on_right_click(self, event):
    menu = controller().make_menu()
    self.create_context_menu(menu, event.GetItem())
    if menu:    
        self.PopupMenu(menu.wxobj, event.GetPoint())</t>
<t tx="mr7771.20060609154937.23">def move_caret_to_end(self, treeitem):
    editor = self.GetParent().editor
    last = treeitem
    code_item = None
    while last.IsOk():
        code_item = self.GetPyData(last) or code_item
        last = self.GetLastChild(last)

    if code_item:
        line = code_item.get_last_line()
    else:
        #the section has no child ==&gt; set the caret before the first child
        #of the next section
        next = treeitem
        line = -1
        while True:
            next = self.GetNextSibling(next)
            if next.IsOk():
                child = self.GetFirstChild(next)
                if not child.IsOk(): continue
                code_item = self.GetPyData(child)
                if code_item:
                    line = code_item.get_line() - 1
                    break
            else:
                break

        if line &lt; 0: line = editor.GetLineCount() - 1

    editor.LineScroll(0, line - editor.GetFirstVisibleLine())
    editor.GotoLine(line)</t>
<t tx="mr7771.20060609155425"></t>
<t tx="mr7771.20060609155616"></t>
<t tx="mr7771.20060609160624"></t>
<t tx="mr7771.20060609165227.2">@ 
Workarround for not implemented GetPrevVisible
@c
def get_prev_visible(self, item):
    before = item
    next = self.GetItemParent(item)
    while next.IsOk() and next != item:
        before = next
        next = self.GetNextVisible(next)

    if before == self.GetRootItem(): return item
    return before</t>
<t tx="mr7771.20060609175617">def _on_idle(self, event):
    event.Skip()
    if not self.idle_item:
        return

    if not self.idle_item.IsOk():
        self.idle_item = None
        self.calc_column_widths()
        return

    if controller().is_processing(): 
        #dont't block another task
        return

    self.modify_item(self.idle_item)
    self.idle_item = self.GetNext(self.idle_item)
    event.RequestMore()

    if (self.idle_item and self.idle_item.IsOk()):
        code_item = self.GetPyData(self.idle_item)
    else:
        code_item = None

</t>
<t tx="mr7771.20060609222057">self.DeleteChildren(self.imports)
self.DeleteChildren(self.miscellaneous)
self.DeleteChildren(self.resources)
self.DeleteChildren(self.tasks)
self.DeleteChildren(self.evaluations)
self.DeleteChildren(self.observers)</t>
<t tx="mr7771.20060609222057.1">img = self.get_image_index
append = self.AppendItem

hidden_window = self.GetHeaderWindow()
extent = hidden_window.GetTextExtent

font = self.GetFont()
hidden_window.SetFont(font)

triangle = 12
space = 6
offset = self.GetIndent() + triangle \
         + 2 * space + self.img_size[0] \
         + self.left_sep

depth_width = self.GetIndent() + triangle</t>
<t tx="mr7771.20060609222057.2">hierachy = []
width = 0

for item in editor.code_items:
    item_line = item.get_line()

    while hierachy:
        parent, last_line = hierachy[-1]
        if last_line &gt; item.get_line(): break
        hierachy.pop()
    else:
        parent = self.get_section(item)

    child = append(parent, item.name)
    width = max(width, extent(item.name)[0] \
                + len(hierachy) * depth_width)

    item.tree_obj = child
    self.SetPyData(child, item)

    hierachy.append((child, item.get_last_line()))</t>
<t tx="mr7771.20060609222452">import metapie.gui.pyeditor as pyeditor
import faces.observer as fobserver
import faces.resource as fresource
import faces.task as ftask
import faces.plocale
import weakref
import types
import inspect
from classifiers import *
from metapie.gui import controller
</t>
<t tx="mr7771.20060609223152">class CTask(CStructureContext):
    editors = {}
    @others

Context.context_list.append(CTask())
</t>
<t tx="mr7771.20060609223152.1">class CProjectDeclaration(CTask):
    editors = {}
    @others

Context.context_list.append(CProjectDeclaration())
</t>
<t tx="mr7771.20060609223152.2">class CImport(Context):
    editors = {}
    @others

Context.context_list.append(CImport())</t>
<t tx="mr7771.20060609223152.3">self.AddColumn(_(""))
self.AddColumn(_("Name"))
self.AddColumn(_("Start"))
self.AddColumn(_("End"))
self.AddColumn(_("Length"))
self.AddColumn(_("Effort"))
self.SetMainColumn(1)
self.col_width = [ 0 ] * (self.GetColumnCount() - 2)</t>
<t tx="mr7771.20060609223152.4">root = self.AddRoot("root")
imports = append(root, _("Imports"), img("import16"))
miscellaneous = append(root, _("Miscellaneous"), img("misc16"))
resources = append(root, _("Resources"), img("resources16"))
tasks = append(root, _("Tasks"))
evaluations = append(root, _("Evaluations"), img("evaluations16"))
observers = append(root, _("Observers"), img("camera16"))#</t>
<t tx="mr7771.20060609223152.5">header_font = self.get_item_font(imports)
header_font.SetWeight(wx.FONTWEIGHT_BOLD)

self.SetItemFont(imports, header_font)
self.SetItemFont(miscellaneous, header_font)
self.SetItemFont(resources, header_font)
self.SetItemFont(tasks, header_font)
self.SetItemFont(evaluations, header_font)
self.SetItemFont(observers, header_font)</t>
<t tx="mr7771.20060609223152.6">self.SetItemText(resources, _("Efficiency"), 2)
self.calc_column_widths(resources)

self.set_image(tasks, "tasks16", "tasks_open16")
self.SetItemText(tasks, _("Start"), 2)
self.SetItemText(tasks, _("End"), 3)
self.SetItemText(tasks, _("Length"), 4)
self.SetItemText(tasks, _("Effort"), 5)
self.calc_column_widths(tasks)</t>
<t tx="mr7771.20060609224238.1">def can_activate(self, editor, line, prev, next, inside):
    return is_import(prev) and line &lt;= prev.get_last_line() + 1 \
           or is_import(next) and line &gt;= next.get_line() - 1

</t>
<t tx="mr7771.20060609224238.2">class CMisc(Context):
    editor = None
    @others

Context.default = CMisc()
</t>
<t tx="mr7771.20060609224238.3">class CResource(CStructureContext):
    editors = {}
    @others

Context.context_list.append(CResource())    </t>
<t tx="mr7771.20060609224238.4">class CEvaluation(Context):
    editors = {}

    @others

Context.context_list.append(CEvaluation())
</t>
<t tx="mr7771.20060609224238.5">class CObserver(CStructureContext):
    editors = {}
    @others

Context.context_list.append(CObserver())</t>
<t tx="mr7771.20060609225045">class Context(object):
    context_list = []
    code_item = None
    editors = {} # attribute editors


    def __init__(self, code_item=None):
        self.code_item = code_item


    def __repr__(self):
        return self.__class__.__name__

@others</t>
<t tx="mr7771.20060609231152">@language python
&lt;&lt; Copyright &gt;&gt;
"""
The Editor Control
"""
&lt;&lt; Imports &gt;&gt;
&lt;&lt; Editor Completions &gt;&gt;

_is_source_ = True
_ = faces.plocale.get_gettext()

@others
</t>
<t tx="mr7771.20060609231152.1">import wx
import wx.lib.buttons as buttons
import re
import bisect
import faces
import faces.plocale
import faces.task as ftask
import faces.resource
import faces.gui.snapshot
import faces.generator
import docparser
import inspect
import weakref
import sys
import itertools
from classifiers import *
import metapie.gui.pyeditor as pyeditor
from context import Context, PTask
from metapie.gui import controller, ResourceManager
from dialogs import CalendarDialog

</t>
<t tx="mr7771.20060609231152.2">class SearchTool(pyeditor.SearchControl):
	@others
</t>
<t tx="mr7771.20060609231152.3">def __init__(self, parent, id, editor, forward=True):
    pyeditor.SearchControl.__init__(self, parent, id, editor, forward)
    top = controller().get_top_menu()
    edit_menu = top.make_menu(_("&amp;Edit"), pos=100)
    menu = lambda *args, **kw: edit_menu.make_item(self, *args, **kw)
    menu(_("&amp;Find\tCTRL-F"), self.menu_find_forward)
    menu(_("Find &amp;Backward\tCTRL-B"), self.menu_find_backward)
    self.SetToolTip(wx.ToolTip(_("Press Ctrl-F for next and Ctrl-B for "\
                                 "Prev\n and Ctrl-W for word")))
</t>
<t tx="mr7771.20060609231152.4">class _EditorBase(pyeditor.PythonEditCtrl):
    &lt;&lt; _parse_evaluation &gt;&gt;

class Editor(DimmerStyler, _EditorBase):
	&lt;&lt; declarations &gt;&gt;
	@others
</t>
<t tx="mr7771.20060609231152.5">show_call_tips = True
task_completions = None

_patterns = _EditorBase._patterns \
            + tuple(map(lambda p: ("[a-zA-Z0-9_.]+[ ]*=[ ]*%s(" % p, \
                                   _EditorBase._parse_evaluation), \
                        project_names))

</t>
<t tx="mr7771.20060609231152.7">def __init__(self, model, parent):
    _EditorBase.__init__(self, parent, wx.SUNKEN_BORDER)
    DimmerStyler.__init__(self)

    self.model = weakref.proxy(model)
    self.macro = None
    self.last_char = None
    self.should_be_corrected = False

    self.context = Context.default
    self.context.activate(self, 0, None, None, False)
    self.context_button = ContextButton(self)
    self.context_button.hide()

    self.MarkerDefine(2, wx.stc.STC_MARK_ROUNDRECT, "blue", "blue")
    self.SetMarginWidth(1, 12)
    self.SetMarginMask(1, 5)

    self.SetModEventMask(wx.stc.STC_MOD_INSERTTEXT | \
                         wx.stc.STC_MOD_DELETETEXT | \
                         wx.stc.STC_MOD_CHANGEFOLD | \
                         wx.stc.STC_PERFORMED_UNDO | \
                         wx.stc.STC_PERFORMED_USER | \
                         wx.stc.STC_PERFORMED_REDO)

    &lt;&lt; Editor Adjustments &gt;&gt;
    &lt;&lt; Bind Events &gt;&gt;
</t>
<t tx="mr7771.20060609231152.9"></t>
<t tx="mr7771.20060609231152.10">def _on_get_focus(self, event):
    event.Skip()

    try:
        parent = event.GetWindow().GetParent()
    except AttributeError:
        parent = None

    my_parent = self.GetParent()
    while parent:
        if parent is my_parent: return
        parent = parent.GetParent()

    self.set_menus()
</t>
<t tx="mr7771.20060609231152.11">__change_count = 0
def _on_change(self, event):
    if not self.GetModify(): return

    mod_type = event.GetModificationType()
    line = self.GetCurrentLine()

    if mod_type &amp; (wx.stc.STC_MOD_INSERTTEXT | 
                   wx.stc.STC_MOD_DELETETEXT):
        &lt;&lt; make backup if necessary &gt;&gt;
        &lt;&lt; change the context button if neccessary &gt;&gt;
        self.move_context_button()

    if mod_type &amp; wx.stc.STC_MOD_CHANGEFOLD:
        line = self.GetCurrentLine()
        if line == event.GetLine():
            &lt;&lt; renew the context &gt;&gt;

    _EditorBase._on_change(self, event)
    self.check_modified()
</t>
<t tx="mr7771.20060609231152.13">def _on_find_close(self, event):
    event.GetDialog().Destroy()
    self.EndUndoAction()
</t>
<t tx="mr7771.20060609231152.14">def _on_find(self, event):
    findstr = event.GetFindString()
    replacestr = event.GetReplaceString()
    ev_type = event.GetEventType()
    flags = event.GetFlags()

    macro = self.macro

    self.macro = None
    self.__find(findstr, replacestr, ev_type, flags)
    self.macro = macro
    if macro:
        macro.add_command(self.__find, findstr,
                          replacestr, ev_type, flags)
</t>
<t tx="mr7771.20060609231152.15">def _on_right_down(self, event):
    top = controller().get_top_menu()
    menu = top.make_menu(_("&amp;Edit"))
    self.PopupMenu(menu.wxobj, event.GetPosition())
</t>
<t tx="mr7771.20060609231152.16">def _on_new_char(self, event):
    key_ascii = unichr(event.GetKey())
    self.last_char = key_ascii
    _EditorBase._on_new_char(self, event)
    self.show_completion()
</t>
<t tx="mr7771.20060609231152.17">def _on_macro_notify(self, event):
    if self.macro:
        msg = event.GetMessage()
        if msg == 2170: # == REPLACE_SEL
            self.macro.add_command(self.smart_replace_selection,
                                   self.last_char)
        else:
            self.macro.add_command(self.CmdKeyExecute, msg)
</t>
<t tx="mr7771.20060609231152.18">def _on_insert_completion(self, event):
    start_pos = event.GetListType() - 1
    text = event.GetText()[start_pos:].replace(r"\n", "\n")
    cur_pos = self.GetCurrentPos()
    self.AddText(text.replace("|", ""))
    lines = len(text.split("\n"))
    line = self.LineFromPosition(cur_pos)

    cursor = text.rfind("|")
    if cursor &gt;= 0:
        self.GotoPos(cur_pos + cursor)

    for l in range(1, lines):
        self.autoindent(self.PositionFromLine(line + l), False)

    attrib = event.GetText()

    try:
        #if text has an = show the call tip for the assigned attribute
        attrib = attrib[:attrib.index("=")].strip()
    except ValueError:
        attrib = None

    self.show_call_tip(attrib=attrib)

</t>
<t tx="mr7771.20060609231152.19"></t>
<t tx="mr7771.20060609231152.20">def menu_snapshot(self):
    module = controller().session.get_module(self.model.path)
    create_snapshot = faces.gui.snapshot.create
    recalc, import_name = create_snapshot(module, self.model.get_encoding())
    if import_name:
        imports = filter(lambda c: c.obj_type == pyeditor.IMPORT,
                         self.code_items)
        if not imports:
            #don't know where to place the import statement
            #this case should never happen
            return

        line = imports[-1].get_last_line()
        self.InsertText(self.PositionFromLine(line),
                        _("import %s #This module contains snapshots\n")\
                        % import_name)
        self.sync_text()

    if recalc:
        controller().session.execute_plan()
</t>
<t tx="mr7771.20060609231152.22">def menu_insert_date(self):
    dlg = CalendarDialog(self)
    if dlg.ShowModal() == wx.ID_OK:
        date = dlg.cal.GetDate()
        self.ReplaceSelection('"%s"' % date.FormatDate())

    dlg.Destroy()
</t>
<t tx="mr7771.20060609231152.23">__comment_lines_pattern = re.compile(r'^#+', re.MULTILINE)
__free_lines_pattern = re.compile(r'^', re.MULTILINE)

def menu_uncomment_selection(self):
    text = self.GetSelectedText()
    text = self.__comment_lines_pattern.sub("", text)
    self.ReplaceSelection(text)
</t>
<t tx="mr7771.20060609231152.24">def menu_comment_selection(self):
    text = self.GetSelectedText()
    text = self.__free_lines_pattern.sub("#", text)
    self.ReplaceSelection(text)
</t>
<t tx="mr7771.20060609231152.25">def menu_find_forward(self):
    macro = controller().macro
    if macro: macro.pop()
    self.create_search(SearchTool)
</t>
<t tx="mr7771.20060609231152.26">def menu_find_backward(self):
    macro = controller().macro
    if macro: macro.pop()
    self.create_search(SearchTool, False)
</t>
<t tx="mr7771.20060609231152.27">def menu_replace(self):
    macro = controller().macro
    if macro: macro.pop()
    data = wx.FindReplaceData()
    data.SetFindString(self.GetSelectedText())
    dialog = wx.FindReplaceDialog(self, data, _("Replace"),
                                  wx.FR_REPLACEDIALOG)
    dialog.data = data
    dialog.Show(True)
    self.BeginUndoAction()
</t>
<t tx="mr7771.20060609231152.28">def menu_goto_line(self):
    dialog = wx.TextEntryDialog(self, _("Goto Line"), _("Goto Line"))
    if dialog.ShowModal() == wx.ID_OK:
        val = int(dialog.GetValue()) - 1
        self.GotoLine(val)
        self.SetFocus()

    dialog.Destroy()
</t>
<t tx="mr7771.20060609231152.29"></t>
<t tx="mr7771.20060609231152.30">def no_record_call(self, function, *args):
    macro = self.macro
    self.macro = None
    result = function(*args)
    self.macro = macro
    return result
</t>
<t tx="mr7771.20060609231152.31">def start_macro(self):
    self.menu_macro_execute.enable(False)
    self.menu_macro_start.enable(False)
    self.menu_macro_stop.enable(True)
    ctrl = controller()
    ctrl.status_bar.SetStatusText(_("Recording..."), 1)
    self.macro = ctrl.start_recording()
    self.StartRecord()
</t>
<t tx="mr7771.20060609231152.32">def stop_macro(self):
    self.menu_macro_stop.enable(False)
    self.menu_macro_start.enable(True)
    self.menu_macro_execute.enable(True)
    ctrl = controller()
    ctrl.status_bar.SetStatusText("", 1)
    self.StopRecord()
    ctrl.stop_recording()
</t>
<t tx="mr7771.20060609231152.33">def execute_macro(self):
    if self.macro:
        if not self.macro.execute():
            self.macro = None
            self.menu_macro_execute.enable(False)
</t>
<t tx="mr7771.20060609231152.36">def __find(self, findstr, replacestr, ev_type, flags):
    sflags = 0

    if flags &amp; wx.FR_WHOLEWORD: sflags |= wx.stc.STC_FIND_WHOLEWORD
    if flags &amp; wx.FR_MATCHCASE: sflags |= wx.stc.STC_FIND_MATCHCASE

    utf8findstr = findstr.encode("utf-8", "ignore") # a bug in scincilla

    if ev_type == wx.wxEVT_COMMAND_FIND_REPLACE_ALL:
        self.BeginUndoAction()
        end = self.GetLength()
        start = self.FindText(0, end, findstr, sflags)
        while start &gt;= 0:
            self.GotoPos(start)
            self.SetSelectionEnd(start + len(utf8findstr))
            self.ReplaceSelection(replacestr)
            start = self.FindText(start + len(utf8findstr),
                                  end, findstr, sflags)

        self.EndUndoAction()
        return

    if flags &amp; wx.FR_DOWN:
        start = self.GetCurrentPos() + 1
        end = self.GetLength()
    else:
        start = self.GetSelectionStart() - 1
        end = 0

    pos = self.FindText(start, end, findstr, sflags)
    if pos &gt; 0:
        self.GotoPos(pos)
        self.SetSelectionEnd(pos + len(utf8findstr))
        if ev_type == wx.wxEVT_COMMAND_FIND_REPLACE:
            self.ReplaceSelection(replacestr)
            self.GotoPos(pos)
            self.SetSelectionEnd(pos + len(replacestr))
</t>
<t tx="mr7771.20060609231152.37">__last_module_id = 0
def refresh(self, refresh_text=False):
    module = self.get_module()
    if not refresh_text:
        &lt;&lt; module settings &gt;&gt;
        return

    self.Freeze()
    self.unlisten()

    if self.AutoCompActive(): self.AutoCompCancel()
    model = self.model

    &lt;&lt; save current position &gt;&gt;
    &lt;&lt; create new document &gt;&gt;
    &lt;&lt; misc document settings &gt;&gt;
    &lt;&lt; module settings &gt;&gt;
    &lt;&lt; restore position &gt;&gt;

    self.check_context(line)
    self.listen()
    self.Thaw()
</t>
<t tx="mr7771.20060609231152.39">def inspect_indent_char(self, key):
    super_meth = _EditorBase.inspect_indent_char
    return self.no_record_call(super_meth, self, key)
</t>
<t tx="mr7771.20060609231152.42">def show_call_tip(self, obj=None, attrib=None):
    if not self.show_call_tips: return False

    &lt;&lt; calculate obj and attrib &gt;&gt;

    doc = self.get_doc_object(obj)
    doc = doc and doc.get_doc(attrib)
    if not doc:
        try:
            val = getattr(obj, attrib)
        except AttributeError:
            val = getattr(self.get_module(), attrib, None)

        if isinstance(val, (ftask.Task, PTask)):
            doc = 0, val.title
        else:
            doc = self.get_doc_object(val)
            doc = doc and doc.constructor(attrib)
    else:
        pass

    if doc:
        txt = doc[1].decode(self.model.get_encoding(), 'ignore')
        self.CallTipShow(self.GetCurrentPos(), txt)
        self.CallTipSetHighlight(0, doc[0])
        return True

    return False

</t>
<t tx="mr7771.20060609231152.43">def get_resource_completions(self, obj=None):
    return map(lambda r: (r, r), self.model.resources.keys())</t>
<t tx="mr7771.20060609231152.44">def get_evaluation_completions(self, obj=None):
    return map(lambda kv: (kv[0], kv[0]), self.model.evaluations.iteritems())

</t>
<t tx="mr7771.20060609231152.45">def get_doc_object(self, obj):
    if not obj or isinstance(obj, (int, basestring)): return None

    parser = docparser.ClassDoc
    if inspect.isfunction(obj) or inspect.ismethod(obj):
        parser = docparser.FunctionDoc
    elif inspect.ismodule(obj):
        parser = docparser.ModuleDoc
    elif not isinstance(obj, type):
        try:
            obj = obj.__class__
        except AttributeError:
            pass

    id_ = id(obj)
    try:
        return self.__doc_cache[id_]
    except AttributeError:
        self.__doc_cache = { id_ : parser(obj) }
    except KeyError:
        self.__doc_cache[id_] = parser(obj)

    return self.__doc_cache[id_]</t>
<t tx="mr7771.20060609231152.46">#caching values
__completion_list = None 
__completion_dots = 0
def show_completion(self, force=False):
    current = self.GetCurrentPos()

    text = self.get_word_at(current)
    auto_active = self.AutoCompActive()

    if not text and not force:
        if auto_active: self.AutoCompCancel()
        return

    &lt;&lt; check style &gt;&gt;

    dots = len(filter(lambda c: c == ".", text))
    if not auto_active or self.__completion_dots != dots:
        try:
            &lt;&lt; try to create dot completion list &gt;&gt;
        except ValueError:            
            &lt;&lt; create non dot completion list &gt;&gt;

        self.__completion_dots = dots

    compl = self.__completion_list
    if compl is None: return
    if not compl:
        &lt;&lt; find an alternative completion list &gt;&gt;

    &lt;&lt; show list &gt;&gt;

</t>
<t tx="mr7771.20060609231152.49">def smart_replace_selection(self, text):
    self.ReplaceSelection(text)
    self.inspect_indent_char(text)
</t>
<t tx="mr7771.20060609232136">self.Bind(wx.stc.EVT_STC_USERLISTSELECTION, self._on_insert_completion)
self.Bind(wx.stc.EVT_STC_MACRORECORD, self._on_macro_notify)
self.Bind(wx.EVT_RIGHT_DOWN, self._on_right_down)
self.Bind(wx.EVT_SET_FOCUS, self._on_get_focus)

self.Bind(wx.EVT_COMMAND_FIND, self._on_find)
self.Bind(wx.EVT_COMMAND_FIND_NEXT, self._on_find)
self.Bind(wx.EVT_COMMAND_FIND_REPLACE, self._on_find)
self.Bind(wx.EVT_COMMAND_FIND_REPLACE_ALL, self._on_find)
self.Bind(wx.EVT_FIND_CLOSE, self._on_find_close)
</t>
<t tx="mr7771.20060609232136.1">self.AutoCompStops("(){}[]")
self.AutoCompSetSeparator(ord("\t"))
self.AutoCompSetIgnoreCase(0)
self.AutoCompSetDropRestOfWord(1)
self.AutoCompSetAutoHide(1)
self.SetCaretLineVisible(True)</t>
<t tx="mr7771.20060609235111">__pending_check_context = 0
def _on_pos_changed(self, old, new):
    line = self.LineFromPosition(new)

    if self.LineFromPosition(old or 0) != line:
        def check_context():
            #enables fast scrolling without getting stuck
            self.__pending_check_context -= 1
            if self.__pending_check_context &gt; 0: return
            self.__pending_check_context = 0
            self.check_context(line)
            self.context.make_button(self.context_button,
                                     self.get_expression(line))
            self.move_context_button()

        self.__pending_check_context += 1
        wx.FutureCall(70, check_context)

</t>
<t tx="mr7771.20060610004423.1">def can_activate(self, editor, line, prev, next, inside):
    return is_resource(inside)
</t>
<t tx="mr7771.20060610005033"></t>
<t tx="mr7771.20060610005033.1">def activate(self, editor, line, prev, next, inside):
    self.code_item = inside
    self.editor = editor
    if not prev:
        if next: 
            return line &lt; next.get_line() - 1
        return True

    return False
</t>
<t tx="mr7771.20060610005033.6">def can_activate(self, editor, line, prev, next, inside):
    if is_task(inside):
        self.pseudo = PTask(inside)
        return True
    else:
        self.pseudo = None
        return False
</t>
<t tx="mr7771.20060610005713.1">def can_activate(self, editor, line, prev, next, inside):
    if is_project(inside):
        self.pseudo = PTask(inside)
        return True
    else:
        self.pseudo = None
        return False
</t>
<t tx="mr7771.20060613102529"></t>
<t tx="mr7771.20060613111615">class CResourceOrTask(Context):
    @others

Context.context_list.append(CResourceOrTask())</t>
<t tx="mr7771.20060613111615.2">def can_activate(self, editor, line, prev, next, inside):
    if is_resource(inside): return False
    return not is_resource(next) \
        and (is_import(prev) \
             and line &gt; prev.get_last_line() + 1 \
             or is_resource(prev))</t>
<t tx="mr7771.20060613174236">class CTaskOrEvaluation(Context):
    @others

Context.context_list.append(CTaskOrEvaluation())</t>
<t tx="mr7771.20060613174515.1">def can_activate(self, editor, line, prev, next, inside):
    if is_task(inside): return False
    return (is_task(prev) or is_project(prev)) \
           and not (is_task(next) or is_project(next))</t>
<t tx="mr7771.20060613224409"></t>
<t tx="mr7771.20060614090309">__last_attrib = None
def check_context(self, line):
    prev, next = self.code_items_near(line)
    inside = self.code_item_at(line)
    ctrl = controller()

    last_code_item = self.context.code_item
    &lt;&lt; find and activate the current context &gt;&gt;
    update_siblings = False
    if last_code_item is not self.context.code_item:
        item = self.context.code_item
        &lt;&lt; update browser and refresh &gt;&gt;
        &lt;&lt; highlite context &gt;&gt;

        update_siblings = True
        self.__last_attrib  = None

    &lt;&lt; calculate attribute name &gt;&gt;

    update_siblings += attrib_name != self.__last_attrib
    if update_siblings:
        &lt;&lt; update my siblings &gt;&gt;
</t>
<t tx="mr7771.20060614114501">#no completion inside strings an comments
style = self.GetStyleAt(current)
if style in  (wx.stc.STC_P_TRIPLEDOUBLE,
              wx.stc.STC_P_TRIPLE,
              wx.stc.STC_P_STRING,
              wx.stc.STC_P_COMMENTLINE,
              wx.stc.STC_P_COMMENTBLOCK):
    return</t>
<t tx="mr7771.20060614120349">def get_word_at(self, pos=None, complete=False):
    pos = pos or self.GetCurrentPos()

    #get start of dot sequence
    start = self.WordStartPosition(pos, 1)
    char_before = chr(self.GetCharAt(start - 1))
    while(start &gt; 0 and chr(self.GetCharAt(start - 1)) == "."):
        start = self.WordStartPosition(start - 1, 1)

    prev_word_start = self.WordStartPosition(start - 1, 1)
    if self.GetTextRange(prev_word_start, start).startswith("def"):
        #a def will be included despite the space to allow
        #the autocomplete of functions
        start = prev_word_start

    if complete:
        return self.GetTextRange(start, self.WordEndPosition(pos, 1))
    else:
        return self.GetTextRange(start, pos)
</t>
<t tx="mr7771.20060614121509">line = self.LineFromPosition(current)
start = self.PositionFromLine(line)
subname = self.GetTextRange(start, current)
try:
    subname = subname[:subname.index("=")].strip()
except ValueError:
    try:
        subname = subname[:subname.index("(")].strip()
    except ValueError:
        subname = None

if subname:
    self.__completion_list = self.context.get_sub_completion_list(subname)
else:
    self.__completion_list = self.context.get_main_completion_list()

</t>
<t tx="mr7771.20060614121949">try:
    # cut of last token of dot sequence
    text = text[text.rindex(".") + 1:] 
except ValueError: pass

compl = filter(lambda c: c[0].startswith(text), compl)
if not compl: return

if len(compl) == 1 and text == compl[0][0]:
    try:
        self.show_call_tip()
    except AttributeError: pass
    return  

compl = [ c[1].replace("\n", r"\n") for c in compl ]
compl.sort()
self.UserListShow(len(text) + 1, "\t".join(compl))
</t>
<t tx="mr7771.20060614124044"></t>
<t tx="mr7771.20060614124044.1">class CStructureContext(Context):
@others</t>
<t tx="mr7771.20060614124118">    @others</t>
<t tx="mr7771.20060614124301">def get_main_completion_list(self):
    obj = self.get_object()
    return filter(lambda kv: kv[0][0] != "#",\
                  obj.__attrib_completions__.items())
</t>
<t tx="mr7771.20060614124301.1"></t>
<t tx="mr7771.20060614124751">    @others</t>
<t tx="mr7771.20060614124751.1">def get_default_pseudo(self):
    return None</t>
<t tx="mr7771.20060614124751.2"></t>
<t tx="mr7771.20060614124952">def get_sub_completion_list(self, name):
    obj = self.get_object()
    compl_dir = obj.__attrib_completions__
    try:
        compl = compl_dir["#%s" % name]
    except KeyError:
        return []
    else:
        if isinstance(compl, basestring):
            compl = getattr(self.code_item.editor, compl)(obj)
        else:
            compl = compl.items()

    return compl

</t>
<t tx="mr7771.20060614134507"></t>
<t tx="mr7771.20060614134507.1">def get_default_pseudo(self):
    return fresource.Resource</t>
<t tx="mr7771.20060614140603">@language python
&lt;&lt; Copyright &gt;&gt;
"""
Codeitem classifiers.
"""
&lt;&lt; Imports &gt;&gt;

__all__ = ("is_task", "is_resource", "is_observer", \
           "is_project", "is_evaluation", "is_import",\
           "get_resource_base", "get_observer_base",\
           "is_observer_func", "EVALUATION")

_is_source_ = True

@others</t>
<t tx="mr7771.20060614140603.1">import faces.task as ftask
import faces.resource as fresource
import faces.observer as fobserver
import metapie.gui.pyeditor as pyeditor
</t>
<t tx="mr7771.20060614140603.2">def is_task(item):
    if not item: return False
    try:
        return isinstance(item.obj, ftask.Task) \
            and not isinstance(item.obj, ftask._ProjectBase)
    except AttributeError:
        if item.obj_type == pyeditor.FUNCTION and not item.get_args():
            parent = item.get_parent()
            return is_task(parent) or is_project(parent)

        return False
</t>
<t tx="mr7771.20060614141538">def is_resource(item):
    try:
        return isinstance(item.obj, fresource._MetaResource)
    except AttributeError:
        return bool(get_resource_base(item))
    return False


def get_resource_base(item):
    if not item or item.obj_type != pyeditor.CLASS: return None
    module = item.editor.get_module()
    for base in item.get_args():
        try:
            cls = eval("module.%s" % base)
            if isinstance(cls, fresource._MetaResource):
                return cls
        except: pass
    return None
</t>
<t tx="mr7771.20060614141538.1">
def _sandwich(func):
    def save(*args):
        try:
            return func(*args)
        except AttributeError:
            return False

    return save   


EVALUATION = pyeditor.IMPORT + 1
is_project = _sandwich(lambda i: i.obj_type != EVALUATION \
                       and isinstance(i.obj, ftask._ProjectBase))
is_evaluation = _sandwich(lambda i: i.obj_type == EVALUATION)
is_import = _sandwich(lambda i: i.obj_type == pyeditor.IMPORT)

del _sandwich
</t>
<t tx="mr7771.20060614141538.2">def get_module(self):
    return controller().session.get_module(self.model.path)
</t>
<t tx="mr7771.20060614142353">def is_observer_func(item):
    try:
        if item.obj_type != pyeditor.FUNCTION: return False
        while item.obj_type == pyeditor.FUNCTION:
            item = item.get_parent()
    except AttributeError:
        return False

    return is_observer(item)


def is_observer(item):
    try:
        return issubclass(item.obj, fobserver.Observer)
    except AttributeError:
        return bool(get_observer_base(item))

    except TypeError:
        return False


def get_observer_base(item):
    if not item or item.obj_type != pyeditor.CLASS: return None
    module = item.editor.get_module()
    for base in item.get_args():
        try:
            cls = eval("module.%s" % base)
            if issubclass(cls, fobserver.Observer):
                return cls
        except: pass
    return None
</t>
<t tx="mr7771.20060614145216">try:
    task = item.obj
except AttributeError:
    if item.has_children():
        iclosed = "folderstar16"
        iopened = "folder_openstar16"
    else:
        iopened = iclosed = "leafstar16"
else:
    if item.has_children():
        iclosed = "folder16"
        iopened = "folder_open16"
    else:
        iopened = iclosed = "leaf16"

    task = self.get_display_eval_data(task)
    str_obj = task.to_string
    self.SetItemText(tree_item, str_obj.start, 2)
    self.SetItemText(tree_item, str_obj.end, 3)
    self.SetItemText(tree_item, str_obj.length, 4)
    self.SetItemText(tree_item, str_obj.effort, 5)

</t>
<t tx="mr7771.20060614145216.1">try:
    self.SetItemText(tree_item,
                     locale.format("%.2f", item.obj.efficiency),
                     2)
    iclosed = item.obj.__type_image__
except AttributeError:
    iclosed = get_resource_base(item).__type_image__</t>
<t tx="mr7771.20060614150422">try:
    iclosed = item.obj.__type_image__
except AttributeError:
    iclosed = get_observer_base(item).__type_image__</t>
<t tx="mr7771.20060614203356">def activate(self, editor, line, prev, next, inside):
    """
    try to activate the context
    """
    if self.can_activate(editor, line, prev, next, inside):
        self.code_item = inside
        return True
    else:
        self.code_item = None
        return False</t>
<t tx="mr7771.20060614203713"></t>
<t tx="mr7771.20060614203713.1">def can_activate(self, editor, line, prev, next, inside):
    return is_observer(inside)
</t>
<t tx="mr7771.20060614203713.2">def get_default_pseudo(self):
    return get_observer_pseudo(self.code_item)
</t>
<t tx="mr7771.20060616091420">def make_attrib_list(self, obj):
    def function_mapper(name):
        attr = getattr(obj, name, None)
        if not callable(attr): return name
        return getattr(attr, "__call_completion__", name)

    try:
        attrlist = obj.__all__
    except AttributeError:
        attrlist = dir(obj)

    return map(lambda x: (x, function_mapper(x)), \
               filter(lambda n: n[0] != "_", attrlist or ()))</t>
<t tx="mr7771.20060616091420.1">def get_session_completions(self, obj=None):
    module = self.get_module()
    try:
        return module.__attrib_completions__
    except AttributeError:
        return self.make_attrib_list(module)


</t>
</tnodes>
</leo_file>
